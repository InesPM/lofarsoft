
// ==============================================================================
//
//  CR-Tools/apps
//
// ==============================================================================

/*!
  \defgroup CR_Applications CR-Tools :: Applications collection

  \ingroup CR
  
  \brief Application executables of the CR-Tools
*/

// ==============================================================================
//
//  CR-Tools/implement/Analysis
//
// ==============================================================================

/*!
  \defgroup Analysis CR-Tools :: Analysis module

  \ingroup CR

  \brief Analysis module for the CR-pipeline
*/

// ==============================================================================
//
//  CR-Tools/implement/Calibration
//
// ==============================================================================

/*!
  \defgroup Calibration CR-Tools :: Calibration module

  \ingroup CR

  \brief Calibration module for the CR-pipeline
*/

// ==============================================================================
//
//  CR-Tools/implement/Coordinates
//
// ==============================================================================

/*!
  \defgroup CR_Coordinates CR-Tools :: Coordinates module

  \ingroup CR

  \brief Coordinates module for the CR-pipeline
  
  - \ref crtools_coordinates_types
  - \ref crtools_coordinates_conversions
  - \ref crtools_coordinates_measures
  - \ref crtools_coordinates_references

  <hr>

  \section crtools_coordinates_conventions Basic conventions

  The <b>spherical coordinate</b> system represents points as a tuple of three
  components. For use in physical sciences and technology, the recommended
  international standard notation is \f$ r,\vartheta,\phi \f$ for distance,
  zenith and azimuth (ISO 31-11). (In the standard \f$\vartheta\f$ is preferred
  to \f$\theta\f$, although it is the same Greek letter). Otherwise, in America
  the components are typically notated as \f$(\rho,\phi,\theta)\f$ for
  distance, zenith and azimuth, while elsewhere the notation is reversed for
  zenith and azimuth as \f$(\rho,\theta,\phi)\f$. The former has the advantage
  of being most compatible with the notation for the two-dimensional polar
  coordinate system and the three-dimensional cylindrical coordinate system,
  while the latter has the broader acceptance geographically. The notation
  convention of the author of any work pertaining to spherical coordinates
  should always be checked before using the formulas and equations of that
  author. [from Wikipedia, english version]

  We here use the three coordinates \f$(r,\phi,\theta)\f$ according to the
  following convention:
  <ul>
    <li>\f$r\f$ (radius) is the distance of a point P from the origin O of the
    coordinate system, i.e. the length of the vector \f$\vec r\f$;
    <li>\f$\phi\f$ (azimuth angle) is the angle between the positive x-axis and
    \f$\vec r_{xy}\f$ (i.e. the projection of the vector \f$\vec r\f$ onto the
    x-y-plane), with values running from 0 to \f$2\pi\f$ (\f$0^\circ\f$ to
    \f$360^\circ\f$) counted counter-clockwise
    <li>\f$\theta\f$ (polar angle) is the angle between the positive z-axis
    and the vector \f$\vec r\f$, with values running from 0 to \f$\pi\f$
    (\f$0^\circ\f$ to \f$180^\circ\f$)
  </ul>

  For <b>cylindrical coordinates</b> we closely follow the above convention,
  such that the azmiuthal angle \f$\phi\f$ in the x-y-plane is the same as for
  the case of spherical coordinates (and thereby reflection the relation of
  the cylindrical coordinates to polar coordinates in the plain).

  \image html coordinates.png

  <hr>
  
  \section crtools_coordinates_types Coordinate types
  
  The following list of coordinate type is implemented in CR::CoordinateType
  
  <table border=0>
    <tr>
      <td class="indexkey">Type</td>
      <td class="indexkey">Description</td>
      <td class="indexkey">Coordinates</td>
      <td class="indexkey">Comments</td>
    </tr>
    <tr>
	  <td>Direction</td>
	  <td>Direction on the sky</td>
	  <td>\f$ (Long,Lat) \f$</td>
	  <td></td>
	</tr>
    <tr>
	  <td>DirectionRadius</td>
	  <td>Direction on the sky with radial distance</td>
	  <td>\f$ (Long,Lat,R) \f$</td>
	  <td>Encapsulated through CR::SpatialCoordinate</td>
	</tr>
    <tr>
	  <td>Cartesian</td>
	  <td>Cartesian coordinates</td>
	  <td>\f$ (x,y,z) \f$</td>
	  <td>Encapsulated through CR::SpatialCoordinate</td>
	</tr>
    <tr>
	  <td>Spherical</td>
	  <td>Spherical coordinates</td>
	  <td>\f$ (r,\phi,\theta) \f$</td>
	  <td>Encapsulated through CR::SpatialCoordinate</td>
	</tr>
    <tr>
	  <td>Cylindrical</td>
	  <td>Cylindrical coordinates</td>
	  <td>\f$ (\rho,\phi,z) \f$</td>
	  <td></td>
	</tr>
    <tr>
	  <td>AzElHeight</td>
	  <td>Azimuth-Elevation-Height</td>
	  <td>\f$ (Az,El,H) \f$</td>
	  <td></td>
	</tr>
    <tr>
	  <td>AzElRadius</td>
	  <td>Azimuth-Elevation-Radius</td>
	  <td>\f$ (Az,El,R) \f$</td>
	  <td></td>
	</tr>
    <tr>
	  <td>NorthEastHeight</td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
    <tr>
	  <td>LongLatRadius</td>
	  <td>(Local) Longitude-Latitude-Radius</td>
	  <td>\f$ (Long,Lat,R) \f$</td>
	  <td></td>
	</tr>
    <tr>
	  <td>Time</td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
    <tr>
	  <td>Frequency</td>
	  <td></td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
    <tr>
	  <td></td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
  </table>

  <hr>
  
  \section crtools_coordinates_conversions Coordinate conversions
  
  <ol>

    <li>CR::CoordinateType::Cartesian \f$ (x,y,z) \f$
	
	  <table>
        <tr>
	      <td class="indexkey">... as function of</td>
	      <td class="indexkey">Forward transform</td>
	      <td class="indexkey">\f$ (x,y,z) \f$ to other</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Spherical <br> \f$ (r,\phi,\theta) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} r \sin(\theta) \cos(\phi) \\ r \sin(\theta)
		  \sin(\phi) \\ r \cos(\theta) \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{x^2 + y^2 + z^2} \\[1mm] \mathrm{atan}
		  \left( y/x \right) \\[1mm] \mathrm{acos} \left( \frac{z}{\sqrt{x^2 + y^2
		  + z^2}} \right) \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cylindrical <br> \f$ (\rho,\phi,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \rho \cos(\phi) \\ \rho \sin(\phi) \\ z
		  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{x^2 + y^2} \\ \mathrm{atan}(y/x) \\ z
		  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::AzElRadius <br> \f$ (Az,El,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \cos(El) \sin(Az) \\ R \cos(El) \cos(Az) \\ R
		  \sin(El) \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \mathrm{atan}(x/y) \\ \mathrm{asin}(z/\sqrt{x^2
		  + y^2 + z^2}) \\ \sqrt{x^2 + y^2 + z^2} \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::AzElHeight <br> \f$ (Az,El,H) \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::LongLatRadius <br> \f$ (Long,Lat,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \cos(Lat) \cos(Long) \\ R \cos(Lat) \sin(Long)
		  \\ R \sin(Lat) \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \mathrm{atan}(y/x) \\ \mathrm{asin}(z/\sqrt{x^2
		  + y^2 + z^2}) \\ \sqrt{x^2 + y^2 + z^2} \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::NorthEastHeight <br> \f$ (N,E,H) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} E \\ N \\ H \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} y \\ x \\ z \end{array} \right] \f$</td>
	    </tr>
	  </table>

    <li>CR::CoordinateType::Spherical \f$ (r,\phi,\theta) \f$
	
	  <table>
        <tr>
	      <td class="indexkey">... as function of</td>
	      <td class="indexkey">Forward transform</td>
	      <td class="indexkey">\f$ (r,\phi,\theta) \f$ to other</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cartesian <br> \f$ (x,y,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{x^2 + y^2 + z^2} \\ \mathrm{atan}(y/x) \\
		  \mathrm{acos}(z/\sqrt{x^2 + y^2 + z^2}) \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} r \sin(\theta) \cos(\phi) \\ r \sin(\theta)
		  \sin(\phi) \\ r \cos(\theta) \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cylindrical <br> \f$ (\rho,\phi,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{\rho^2+z^2} \\ \phi \\
		  \mathrm{atan}(\rho/z) \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} r \sin(\theta) \\ \phi \\ r \cos(\theta)
		  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::AzElRadius <br> \f$ (Az,El,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \\ 90^{\circ}-Az \\ 90^{\circ}-El \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} 90^{\circ}-\phi \\ 90^{\circ}-\theta \\ r
		  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::LongLatRadius <br> \f$ (Long,Lat,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \\ Long \\ 90^{\circ}-Lat \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \phi \\ 90^{\circ}-\theta \\ r \end{array} \right] \f$</td>
	    </tr>
	  </table>

    <li>CR::CoordinateType::Cylindrical \f$ (\rho,\phi,z) \f$

	  <table>
        <tr>
	      <td class="indexkey">... as function of</td>
	      <td class="indexkey">Forward transform</td>
	      <td class="indexkey">\f$ (\rho,\phi,z) \f$ to other</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cartesian <br> \f$ (x,y,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{x^2 + y^2} \\ \mathrm{atan}(y/x) \\ z
		  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \rho \cos(\phi) \\ \rho \sin(\phi) \\ z
		  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Spherical <br> \f$ (r,\phi,\theta) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} r \sin(\theta) \\ \phi \\ r \cos(\theta)
		  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \sqrt{\rho^2+z^2} \\ \phi \\
		  \mathrm{atan}(\rho/z) \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::AzElRadius <br> \f$ (Az,El,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::LongLatRadius <br> \f$ (Long,Lat,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	    </tr>
	  </table>

    <li>CR::CoordinateType::AzElRadius \f$ (Az,El,R) \f$

	  <table>
        <tr>
	      <td class="indexkey">... as function of</td>
	      <td class="indexkey">Forward transform</td>
	      <td class="indexkey">\f$ (Az,El,R) \f$ to other</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cartesian <br> \f$ (x,y,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \mathrm{atan}(x/y) \\ \mathrm{asin}(z/\sqrt{x^2
		  + y^2 + z^2}) \\ \sqrt{x^2 + y^2 + z^2} \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \cos(El) \sin(Az) \\ R \cos(El) \cos(Az) \\ R
		  \sin(El) \end{array} \right] \f$</td>
	    </tr>
	  </table>

    <li>CR::CoordinateType::LongLatRadius \f$ (Long,Lat,R) \f$

	  <table>
        <tr>
	      <td class="indexkey">... as function of</td>
	      <td class="indexkey">Forward transform</td>
	      <td class="indexkey">\f$ (Long,Lat,R) \f$ to other</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Cartesian <br> \f$ (x,y,z) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \mathrm{atan}(y/x) \\ \mathrm{asin}(z/\sqrt{x^2
		  + y^2 + z^2}) \\ \sqrt{x^2 + y^2 + z^2} \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \cos(Lat) \cos(Long) \\ R \cos(Lat) \sin(Long)
		  \\ R \sin(Lat) \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::Spherical <br> \f$ (r,\phi,\theta) \f$</td>
	      <td>\f$ \left[ \begin{array}{l} \phi \\ 90^{\circ}-\theta \\ r \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l} R \\ Long \\ 90^{\circ}-Lat \end{array} \right] \f$</td>
	    </tr>
        <tr>
	      <td>CR::CoordinateType::AzElRadius <br> \f$ (Az,El,R) \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	      <td>\f$ \left[ \begin{array}{l}  \end{array} \right] \f$</td>
	    </tr>
	  </table>

  </ol>
  
  <hr>
  
  \section crtools_coordinates_measures casacore Measures & Quantities
  
  - list basic types of Quanta
  - list basic types of Measures
  - describe how to construct a Measure (from scratch, from a Quantity, ...)
  
  <ul>
    <li>Quantity describing instances in time:
	\code
	casa::Quantity q1 (0.0,"d");
	\endcode
    <li>Object construction chain for an instance in time:
    \code
    casa::Time t;
    casa::Quantity q;
    casa::MEpoch epoch;
     
    q     = Quantity(t.modifiedJulianDay(),"d");
    epoch = MEpoch(q);
    \endcode
  
    <li>Retrieval of an observatory position:
    \code
    casa::String obsName("LOFAR");
    casa::MPosition obsPosition;
    
    // initialize the observatory table
    casa::MeasTable::initObservatories ();
    // retrieve the position of the observatory
    casa::MeasTable::Observatory(obsPosition,obsName);
    
    // get the list of available observatories
    casa::Vector<casa::String> observatories = casa::MeasTable::Observatories();
    \endcode
  </ul>

  <hr>
  
  \section crtools_coordinates_references References

  - casacore modules:
    - <a href="http://www.astron.nl/casacore/trunk/casacore/doc/html/group__Measures__module.html">Measures</a> -- physical quantities within a certain reference frame.
    - <a href="http://www.astron.nl/casacore/trunk/casacore/doc/html/group__Coordinates__module.html">Coordinates</a> -- collecting classes to interconvert pixel and world (physical) coordinates.
  - <a href="http://en.wikipedia.org/wiki/Geographic_coordinate">Geographic coordinate
  system</a> (Wikipedia)
  
*/

// ==============================================================================
//
//  CR-Tools/implement/Data
//
// ==============================================================================

/*!
  \defgroup CR_Data CR-Tools :: Data module

  \ingroup CR

  \brief Data module for the CR-pipeline
  
  <h3>Synopsis</h3>

  This module collects various classes and functions used for the interaction
  with datasets - be they from the LOPES experiment or the LOFAR telescope.

  <ul>

    <li>The <b>structure of a dataset</b> containing a dump from the LOFAR
	transient buffer boards (TBBs) is mapped onto a hierarchy of C++ classes:
    <ul>
      <li>DAL::TBB_Timeseries -- Top-level structure of a time-series dataset
      <li>DAL::TBB_StationGroup -- Group collecting the data for an individual
      LOFAR station.
      <li>DAL::TBB_DipoleDataset
    </ul>

	<li><b>Transport of antenna positions:</b> In order to provide the positions
	of the antennas/dipoles for which data where received from the TBBs the
	following set of metadata is required:
	\verbatim
	STATION  NAME    STATION_ID  RSP_ID  RCU_ID  POLARIZATION  POSITION  ORIENTATION
	CS001    center  001         -1      -1      -1            [x,y,z]   [a,b,c]
	CS001    lba0    001         000     000      x            [x,y,z]   [a,b,c]
	CS001    lba0    001         000     001      y            [x,y,z]   [a,b,c]
	CS001    lba1    001         000     002      x            [x,y,z]   [a,b,c]
	CS001    lba1    001         000     003      y            [x,y,z]   [a,b,c]
	CS001    lba2    001         000     004      x            [x,y,z]   [a,b,c]
	CS001    lba2    001         000     005      y            [x,y,z]   [a,b,c]
	CS001    lba3    001         000     006      x            [x,y,z]   [a,b,c]
	CS001    lba3    001         000     007      y            [x,y,z]   [a,b,c]
	CS001    lba4    001         001     008      x            [x,y,z]   [a,b,c]
	CS001    lba4    001         001     009      y            [x,y,z]   [a,b,c]
	\endverbatim
	Notes:
	<ul>
	  <li>Even though in principle one might want/need to account for changes in
	  orientation of the dipoles w.r.t. the underlying reference frame, the
	  additional values almost certainly will not be used (at least not for a
	  long time).
	</ul>

  </ul>
      
*/

// ==============================================================================
//
//  CR-Tools/implement/Filters
//
// ==============================================================================

/*!
  \defgroup CR_Filters CR-Tools :: Filters module
  \ingroup CR

  \brief Collection of various types of filter that can be applied to the data
*/

// ==============================================================================
//
//  CR-Tools/implement/GUI
//
// ==============================================================================

/*!
  \defgroup CR_GUI CR-Tools :: Graphical user-interface module

  \ingroup CR

  \brief The basic data get/put mechanism for the Plotting Tool for LOFAR Data

  <hr>
  
  \section CR_GUI_requirements Requirements
  
  - QT as installed from source
  - <a href="http://www.riverbankcomputing.co.uk/software/sip/download">SIP</a> installiert von Source
  - Python 2.6 installiert als Mac OS binary installer von python.org
  - python 2.6 installiert von source von python.org 
  - PyQt as installed from source
  - MathGl as installed from source
  - DOT ... (http://www.graphviz.org/)

  In the end it worked and I didn't know why. I guess the point is that
  PyQt needs to be built by the packaged python while Mathgl needs to be
  build by the self-built python and using gcc4.3. It may also matter in
  which order this is done ...

  <hr>

  <b>Note:</b> This module is optional and -- at least for the moment -- not
  included in the default build of the CR-Tools software package; since the code
  within this module is highly experimental and still subject to the design 
  process it has to be enabled explicitelty by adding
  \verbatim
  -DCR_WITH_GUI:BOOL=TRUE
  \endverbatim
  to the list of CMake configuration parameters.
  
  <h3>Usage</h3>

  In order to use the generated shared object library in Python run
  \verbatim
  python 
  from libhfget import *
  \endverbatim
  Once you have done this you can make use of the actual functionaly provided 
  by the module:
  \verbatim
  d=Data("LOFAR")
  d.printStatus(1)
  v=d.newObjects("Header")
  d2=d.ObjectID(v[0])
  v=d.newObjects("Header:X")
  len(v)
  d.printDecendants("")
  DIR.TO+1
  
  v2=IntVec()
  v[:]=[0,1,2,3,4,5,6,7]
  v[3:4]=[8,9]
  \endverbatim
*/

// ==============================================================================
//
//  CR-Tools/implement/Imaging
//
// ==============================================================================

/*!
  \defgroup CR_Imaging CR-Tools :: Imaging module

  \ingroup CR

  \brief Imaging module for the CR-pipeline

  - \ref crtools_imaging_geometry
  - \ref crtools_imaging_frames
  - \ref crtools_imaging_implementation
  - \ref crtools_imaging_references

<hr>

\section crtools_imaging_geometry Basic geometry and conventions

\image html beamforming-geometry.png

For the beamforming process we adopt the geometry as shown in the figure above,
from this we derive the following fundamental statements:
<ol>
  <li>Coordinates are given within a cartesian coordinate system frame 
  tied to the center of the array; its origin is designated by
  \f$\vec O = (0,0,0)\f$.
  <li>\f$ \vec x_i \f$ is the  three-dimensional position vector of the
  i-th array antenna, pointing away from the coordinate system origin.
  <li>\f$ \vec \rho_i \f$ denotes the direction vector from the position of
  the i-th antenna towards the position of the source.
  <li>Baseline vectors originate from the chosen phase center; the baseline
  vector between a pair of antennae <i>i</i> and <i>j</i> as therefore is
  given by
  \f[ \vec B_{ij} = \vec x_{j} - \vec x_{i} \f]
  The coordinates of the default array phase center are \f$\vec O = (0,0,0)\f$,
  hence \f$\vec B_j = \vec x_j\f$.
  <li>The light travel time delay, \f$\tau_{ij}\f$, between two antennae
  <i>i</i> and <i>j</i> is defined following the convention for the baselines,
  \f[ \tau_{ij} = \frac{1}{c}\, \Bigl( |\vec \rho_j| - |\vec \rho_i| \Bigr) \f]
  thus \f$\tau_{ij} > 0\f$ if the signal arrives at antenna <i>i</i> before
  arriving at antenna <i>j</i>.
</ol>

<table border=0>
<tr>
<td>\image html Plane.gif</td>
<td>\image html PointPlaneDistance.gif</td>
</tr>
</table>

<hr>

\section crtools_imaging_frames Reference frames

A Terrestrial Reference System (TRS) is a spatial reference system co-rotating
with the Earth in its diurnal motion in space. In such a system, positions of
points anchored on the Earth solid surface have coordinates which undergo only
small variations with time, due to geophysical effects (tectonic or tidal
deformations). A Terrestrial Reference Frame (TRF) is a set of physical points
with precisely determined coordinates in a specific coordinate system (cartesian,
geographic, mapping...) attached to a Terrestrial Reference System. Such a TRF
is said to be a realization of the TRS.

<ol>
  <li><i>Ideal Terrestrial Reference Systems.</i> <br>
  An ideal Terrestrial Reference System (TRS) is defined as a tri-dimensional
  reference frame (in the mathematical sense) close to the Earth and co-rotating
  with it. In the newtonian background, the geometry of the physical space
  considered as an euclidian affine space of dimension 3 provides a standard
  and rigorous model of such a system through the selection of an affine frame
  (O,E). O is a point of the space named origin. E is a vector base of the
  associated vector space.The currently adopted restrictions to E are to be
  orthogonal with same length for the base vectors. Moreover, one adopts a direct
  orientation. The common length of these vectors will express the scale of the
  TRS and the set of unit vectors collinear to the base its orientation:
  \f[ \lambda = || \vec{E}_i ||_{i=1,2,3} \f]
  In the context of IERS, we consider the geocentric systems where the origin
  is close to the geocenter and the orientation is equatorial (Z axis is the
  direction of the pole). In this case, cartesian coordinates, geographical
  coordinates or plane (map) coordinates are currently used.<br>
  Under these hypothesis, the general transformation of the cartesian
  coordinates of any point close to the Earth from a TRS (1) to a TRS (2) will
  be given by a tri-dimensional similarity (\f$ T_{1,2} \f$ is a translation
  vector, \f$ \lambda_{1,2} \f$ a scale factor and \f$ R_{1,2} \f$ a rotation
  matrix):
  \f[ X^{(2)} = T_{1,2} + \lambda_{1,2} \cdot R_{1,2} X^{(1)} \f]

  <li><i>Conventional Terrestrial Reference System (CTRS).</i><br>
  Such a system designates the set of all conventions, algorithms and constants
  which determine the estimation of coordinates of points in a specific ideal TRS.

  <li><i>Conventional Terrestrial Reference Frame (CTRF).</i><br>
  A Conventional Terrestrial Reference Frame is defined as a set of physical
  points with precisely determined coordinates in a specific coordinate system
  as a realization of an ideal Terrestrial Reference System. Two types of
  frames are currently distinguished (this is also valid for celestial
  references), namely dynamical or kinematical ones, depending whether a
  dynamical model is applied in the determination process of these coordinates,
  or not.

  <li><i>Earth Centred Earth Fixed (ECEF) coordinates</i> <br>
  The Earth-centred Earth-fixed (ECEF) or conventional terrestrial coordinate
  system rotates with the Earth and has its origin at the centre of the Earth.
  The \f$X\f$ axis passes through the equator at the prime meridian. The \f$Z\f$ axis
  passes through the north pole. The \f$Y\f$ axis can be determined by the
  right-hand rule to be passing through the equator at \f$90^{\circ}\f$ longitude.

  <li><i>Local east, north, up (ENU) coordinates</i> <br>
  In many targeting and tracking applications the local East, North, Up (ENU)
  Cartesian coordinate system is far more intuitive and practical than ECEF or
  Geodetic coordinates. The local ENU coordinates are formed from a plane tangent
  to the Earth's surface fixed to a specific location and hence it is sometimes
  known as a "Local Tangent" or "local geodetic" plane. By convention the east
  axis is labeled \f$x\f$, the north \f$y\f$ and the up \f$z\f$.

  <li><i>Local north, east, down (NED) coordinates</i> <br>
  In an aeroplane most objects of interest are below you, it is therefore
  sensible to define down as a positive number, the NED coordinates allow you
  to do this as an alternative the ENU local tangent plane. By convention the
  north axis is labeled \f$x'\f$, the east \f$y'\f$ and the down \f$z'\f$. To
  avoid confusion between \f$x\f$ and \f$x'\f$, etc in this web page we will
  restrict the local coordinate frame to ENU.
</ol>

The standard relation of transformation between two reference systems is an
Euclidian similarity of seven parameters: three translation components, one
scale factor, and three rotation angles, designated respectively, T1, T2, T3,
D, R1, R2, R3, and their first times derivations : \f$ \dot{T1} \f$, 
\f$ \dot{T2} \f$, \f$ \dot{T3} \f$, \f$ \dot{D} \f$, \f$ \dot{R1} \f$,
\f$ \dot{R2} \f$, \f$ \dot{R3} \f$. The transformation of coordinate vector
\f$ X_1 \f$, expressed in a reference system (1), into a coordinate vector
\f$ X_2 \f$, expressed in a reference system (2), is given by the following
equation:
\f[ X_2 = X_1 + T + D X_1 + R X_1 \f]
with :
\f[
T = \left( \begin{array}{c} T1 \\ T2 \\ T3 \end{array} \right)
\quad \hbox{and} \qquad
R = \left( \begin{array}{ccc} 0 & -R3 & R2 \\ R3 & 0 & -R1 \\ -R2 & R1 & 0
\end{array} \right)
\f]
It is assumed that first equation is linear for sets of station coordinates
provided by space geodetic technique (origin difference is about a few hundred
meters, and differences in scale and orientation are of \f$ 10^{-5} \f$ level).
Generally, X1, X2, T, D, R are function of time.

<hr>

\section crtools_imaging_implementation Implementation

Image array:
\f[  I = I (\xi_1,\xi_2,\xi_3,\nu,t)  \in C^5 \f]

<h4>Coordinates</h4>

Out of the five standard coordinate axes associated with the image array, two
groups of coupled coordinate axes exist; in order to take account of that fact
and provide the programmer/user with an interface reflecting these
relationships, two custom coordinate object classes have been created:
<ol>
  <li>CR::SpatialCoordinate - Container to combine other coordinates into a
  spatial (3D) coordinate.
  <li>CR::TimeFreqCoordinate - Container for the time-frequency domain
  parameters of a skymap.
</ol>
For both classes the following methods are provided:
<ul>
  <li>Interfaces to the WCS parameters describing the the relationship between
  pixel and world coordinates:
  <ul>
	<li>worldAxisNames
	<li>worldAxisUnits
	<li>referencePixel
	<li>referenceValue
	<li>linearTransform
	<li>increment
	<li>toWorld
	<li>toPixel
  </ul>
  <li>Export of the coordinate objects to a coordinate system.
  <ul>
    <li>toCoordinateSystem
  </ul>
</ul>

The above mentioned coordinate objects contain the major fraction of the data
which are collected within an object of type CR::SkymapCoordinate.

<h4>Beamforming</h4>

The functionality required for beamforming and subsequent imaging is broken
down into a number of classes.

<table border="0">
  <tr>
    <td class="indexkey">Quantity</td>
    <td class="indexkey">implemented in</td>
    <td class="indexkey">Relation</td>
  </tr>
  <tr>
    <td>gemoetrical delay</td>
    <td>CR::GeomDelay</td>
    <td>\f$ \tau_j = \frac{1}{c} \left( |\vec \rho - \vec x_j| - |\vec \rho|
    \right) \f$</td>
  </tr>
  <tr>
    <td>geometrical phase</td>
    <td>CR::GeomPhase</td>
    <td>\f$ \phi (\vec x_j, \vec \rho, \nu) = 2 \pi \nu \tau_{\rm geom} \f$</td>
  </tr>
  <tr>
    <td>geometrical weight</td>
    <td>CR::GeomWeight</td>
    <td>\f$ w (\vec x_j, \vec \rho, \nu) = \exp \Bigl( i\, \phi (\vec x_j,
    \vec \rho, \nu) \Bigr) \f$</td>
  </tr>
</table>

In order to use the slicing operations, the arrays internally used by the
Skymapper or the Beamformer need to be of equal rank -- otherwise the
<tt>putSlice()</tt> and <tt>getSlice()</tt> operations are not well defined (or at
least give trouble.

\code
IPosition start (5,0);

for (uint block(0); block<nofBlocks; block++) {
  for (uint channel(0); channel<nofChannels; channel++) {
    /* do something with the data */
    start(3)++;
  }
  start(3)=0;
  start(4)++;
}
\endcode

<hr>

\section crtools_imaging_references References
  
  <ul>
    <li>casacore <a href="http://www.astron.nl/casacore/doc/html/classcasa_1_1Coordinate.html">Coordinate</a> class
	<li>casacore <a href="http://www.astron.nl/casacore/doc/html/group__Measures__module.html">Measures</a> module
    <li><a href="http://itrf.ensg.ign.fr">itrf.ensg.ign.fr</a>
    <li><a href="http://www.iers.org">International Earth Rotation and Reference
    System Service</a>
    <li>Least-squares image estimation on a multiresolution pyramid. Clippingdale, S.C.; Wilson, R.G. Acoustics, Speech, and Signal Processing, 1989. ICASSP-89., 1989 International Conference on Volume , Issue , 23-26 May 1989 Page(s):1409 - 1412 vol.3
    <li><a href="http://www.gb.nrao.edu/ovlbi/es70_stationLocation.txt">NRAO orbiting VLBI earth station coordinates</a>
    <li><a href="http://mathworld.wolfram.com/Point-PlaneDistance.html">Point-Plane Distance</a> (MathWorld)
  </ul>

*/

// ==============================================================================
//
//  CR-Tools/implement/IO
//
// ==============================================================================

/*!
  \defgroup IO CR-Tools :: IO module

  \ingroup CR

  \brief IO module for the CR-pipeline
*/

// ==============================================================================
//
//  CR-Tools/implement/Math
//
// ==============================================================================

/*!
  \defgroup CR_Math CR-Tools :: Math module

  \ingroup CR

  \brief Math module for the CR-pipeline
  
  <h3>Synopsis</h3>

  Even though we make usage of the extensive functionality of the CASA math
  modules, there sometimes are operations missing which will be required 
  over and over again. The Math module of the CR-Pipeline is a collection of
  such additional functions.
*/

// ==============================================================================
//
//  CR-Tools/implement/Bindings
//
// ==============================================================================

/*!
  \defgroup pycr CR-Tools :: Python bindings

  \ingroup CR

  \brief Python bindings for the classes and functions in libcr
*/
