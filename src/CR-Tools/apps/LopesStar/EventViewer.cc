#include <iostream>
#include <stdlib.h>

#include <fftw3.h>


#include <TROOT.h>
#include <TGraph.h>
#include <TFile.h>
#include <time.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TChain.h>
#include <TCanvas.h>
#include <TF1.h>
#include <TMath.h>
#include <TPad.h>

#include <LopesStar/util.h>

using namespace std;

//! simpel event viewer for the fzk side
/*!

simple viewer for events recordes in the fzk with four antennas. The 8 Channels are pictured interpolated on one TCanvas.
As an input source is a root file needed, which is generated by the db2root proc.

*/


int main(int argc, char *argv[])
{
  setenv("TZ","UTC",1);
  tzset();
  gROOT->SetStyle("Plain");


  printf("Asch@ipe.fzk.de (build %s %s)\n", __DATE__, __TIME__);  

  
  char *StarFileName="$HOME/analysis/default_00.root";
  char *OutputFileName="$HOME/analysis/StarTrace_out.root";
  
  int time_start_sec = 0;
  int time_start_sec_gl = 0;
  unsigned int event_id_offset = 0;
  unsigned int event_id_start = 0;
  bool event_search = false;
  bool time_search = false;
  bool zoom = true;
  int number_analyse = 10;
  bool bMeanTrace = false;
  bool bADCScale = true;
  bool bRFISup = true;
  bool id_timestamp_output = false;
  bool RefAntCal = false;
  bool bZeroPadding = true;
  
  int c;
  opterr = 0;

  while ((c = getopt (argc, argv, "hf:i:e:t:n:zmd:asu:wbo")) != -1) //: after var ->Waits for input
    switch (c)
      {
      case 'f':
	OutputFileName = optarg ;
	break;
      case 'o':
	bZeroPadding = false ;
	break;
      case 'i':
	StarFileName = optarg ;
	break;
      case 'a':
	bADCScale = false;
	break;
      case 'b':
	RefAntCal = true;
	break;
      case 's':
	bRFISup = false;
	break;
      case 'z':
	zoom = (bool)optarg ;
	break;
      case 'd':
	event_id_start = (unsigned int) atoi(optarg) ;
	event_search = true;
	break;
      case 'e':
	event_id_offset = (unsigned int) atoi(optarg) ;
	event_search = true;
	break;
      case 't':
	 time_start_sec = atoi(optarg) ;
	 time_search = true;
	 break;
      case 'u':
	 time_start_sec_gl = atoi(optarg) ;
	 time_search = true;
	 break;
      case 'w':
         id_timestamp_output = true;
	 break;
      case 'm':
	bMeanTrace = true;
	break;
      case 'n':
	 number_analyse = atoi(optarg) ;
	 break;
      case '?':
        if (isprint (optopt))
          fprintf (stderr, "Unknown option `-%c'.\nTry '-h'\n", optopt);
        else
          fprintf (stderr,
                   "Unknown option character `\\x%x'.\nTry '-h'\n",
                   optopt);
        return 1;
      case 'h':
        cout << endl;
	cout << " Overview: Event Viewer for FZK measurements\n";
	cout << "============================================\n\n";
	cout << " -h	HELP -- you already tried :-)\n";
	cout << " -f	output file name (default: " << OutputFileName << ")\n";
	cout << " -i	input file name in STAR format (default: " << StarFileName << ")\n\n";
	
	cout << " -e	event offset to start the viewer (default: from beginning)\n";
	cout << " -d	event ID to start with (default: from beginning)\n";
	cout << " -a	scale not in ADC, but in field strength\n";
	cout << " -b	enable calibration with refererence antenna (default: lab. calibration)\n";
	cout << " -t	time offset in sec to start with (default: from beginning)\n";
	cout << " -u	time in sec (global time) to start with\n";
	cout << " -w	switch ON event_id and time stamp output of the analysed events\n";
	cout << " -o	disable the up-sampling (default: enabled)\n";
	cout << " -s	disable RFISuppression (default: enabled)\n\n";
	
	cout << " -n	number of events to plot or to average over (default: " << number_analyse << ")\n";
	cout << " -z	not to zoom in the time axis between around the expected trigger.\n\n";
	
	cout << " -m	mean envelope from traces over the run is created." << endl;
	cout << "	The option -e or -t defines the start point (default: hole run)" << endl;
	cout << "	End event is related to -n option\n";
	cout << "\n\n\nmailto: asch@ipe.fzk.de\n";
	exit(1);
        break;      
      default:
	abort ();
      }

  if(event_search && time_search && !bMeanTrace){
   cerr << "Event search by time OR id, not both. \n";
   exit (1);
  }
  
  if(event_id_start != 0 && event_id_offset != 0) {
    cerr << " -d & -e option not together allowed!!" << endl;
    exit(1);
  }

  int NoChannels=0;
  static struct event event;
  static struct header header;
  static struct channel_profiles channel_profiles;

  TChain *Theader = new TChain("Theader");
  TChain *Tchannel_profile = new TChain("Tchannel_profile");
  TChain *Tevent = new TChain("Tevent");
  CreateTChain(Tevent, StarFileName);
  
  bool bTeventExtend;
  if(Tevent->FindBranch("run_id")==0) bTeventExtend=false;
  else bTeventExtend=true;
  
  if(bTeventExtend){
    CreateTevent(Tevent, &event);
    CreateTeventExtend(Tevent, &header, &channel_profiles);
    Tevent->GetEntry(0);
    unsigned int tmp=event.event_id;
    NoChannels=0;
    while(tmp==event.event_id){
      NoChannels++;
      if(Tevent->GetEntry(NoChannels)==0) break;
    }
    if(NoChannels==0) {cerr << "NoChannels wrong!" << endl; exit(1); }
  }
  else{
    Theader->Add(StarFileName);
    Tchannel_profile->Add(StarFileName);
  
    CreateTevent(Tevent, &event);
    CreateTheader(Theader, &header);
    CreateTchannel_profiles(Tchannel_profile, &channel_profiles);

    Tevent->GetEntry(0);
    Theader->GetEntry(0);
    NoChannels = Tchannel_profile->GetEntries();
  }



  TFile *output = new TFile (OutputFileName,"RECREATE","trace analaysis ARG06");
  output->Close();
  delete output;
   
  char name[1024];

///////////////////////////////   
  int START = 0;
  
 if(time_search){
   int Sec=0;
   int Nanosec;
   Tevent->GetEntry(0);
   if(time_start_sec_gl==0){
     ConvertTimeStamp(event.timestamp, &Sec, &Nanosec);
     time_start_sec += Sec;
   }
   else time_start_sec = time_start_sec_gl;
//cout << time_start_sec << endl;   

   for(int w=0; w<Tevent->GetEntries(); w += NoChannels){
     Tevent->GetEntry(w);
     START = w;
     if(ConvertTimeStamp(event.timestamp, &Sec, &Nanosec)==0) continue;
//cout << event.timestamp << " - " << Sec << endl;
     if( (Sec)>=(time_start_sec) && (Sec-3600)<time_start_sec){
       cout << "event found by time" << endl;
       break;
     }
     if( (Sec-10)>time_start_sec && (Sec-3.1e7-time_start_sec)<0){
       cout << "event NOT found by time" << endl;
       break;
     }
   }
  }
  
 if(event_search){
  if(event_id_start != 0){
   for(int w=START; w<Tevent->GetEntries(); w += NoChannels){
    Tevent->GetEntry(w);
    START = w;
    if(event.event_id == event_id_start) {
      cout << "event found by id" << endl;
      break;
    }
     if(event.event_id > event_id_start){
      cout << "event NOT found by id" << endl;
      break;
    }
   }
  }
  else{
    START = event_id_offset*NoChannels;
  }
 }
   
   Tevent->GetEntry(0);
 

 int STOP=0;
 STOP = START+NoChannels*number_analyse;

// cout << START << " START" << endl;
// cout << "STOP = " << STOP << endl;

///////////////////////////////
  
  if(STOP>= Tevent->GetEntries()){
   cerr << "entry doesn't exist" << endl;
   STOP = Tevent->GetEntries();
   cerr << "changed end number ... " <<  STOP << endl;
  // exit(1);
  }
  
  cout << "first event id = " << event.event_id << endl;
  
  
  int ChId=0;
  char title[1024];


  
  //Zero Padding enviroment
  int NoZeros = 0;
  if(bZeroPadding) NoZeros = 7;
  int New_window_size = event.window_size*(NoZeros+1);
  float **TraceZP;
  TCanvas **canZP;
  TGraph **gZP;
  float *TRACEZP = new float [New_window_size];
  float TimeFFTZP[New_window_size];
  for(int i=0; i<New_window_size; i++) TimeFFTZP[i]=(float)((i*12.5)/(NoZeros+1)/1000.0);
  
  if(!bMeanTrace) {
    TraceZP = new float *[(STOP-START)];
    for(int i=0; i<(STOP-START); i++) TraceZP[i] = new float [New_window_size]; 
    for(int i=0; i<(STOP-START); i++) for(int j=0; j<New_window_size; j++) TraceZP[i][j]=0.0;
    canZP = new TCanvas *[(STOP-START)];
    gZP = new TGraph *[(STOP-START)];
  }
  
  //RFISuppression
  float *RFITrace = new float [event.window_size];
  for(unsigned int i=0; i<event.window_size; i++) RFITrace[i]=0;
  
  //mean trace including Zero padding
  float **MeanTraceZP_re = new float *[NoChannels];
  float **MeanTraceZP_im = new float *[NoChannels];
  for(int i=0; i<NoChannels; i++){
    MeanTraceZP_re[i] = new float[New_window_size];
    MeanTraceZP_im[i] = new float[New_window_size];
  }
  float *MeanTraceZPtmp_re = new float [New_window_size];
  float *MeanTraceZPtmp_im = new float [New_window_size];
  if(bMeanTrace) for(int i=0; i<NoChannels; i++) for(int j=0; j<New_window_size; j++){
    MeanTraceZP_re[i][j]=0;
    MeanTraceZP_im[i][j]=0;
    MeanTraceZPtmp_re[j]=0;
    MeanTraceZPtmp_im[j]=0;
  }
  int countMeanEvent = (STOP-START) / NoChannels;
  TCanvas *canMeanTrace;
  TGraph **gMeanTrace = new TGraph *[NoChannels];
  
  unsigned int ChID[NoChannels];
  for(int i=0; i<NoChannels; i++){
    ChID[i] = 0;
    if(bTeventExtend){
     if(Tevent->GetEntry(i)==0){
       cerr << "error - Tevent->GetEntry()" << endl;
       exit(0);
      }
    }
    else
     if(Tchannel_profile->GetEntry(i)==0){
       cerr << "error - Tchannel_profile->GetEntry()" << endl;
       exit(0);
      }
    ChID[i] = channel_profiles.ch_id;
   }
  

  int Aevent=-1;
  
for(int i=START; i<Tevent->GetEntries(); i++){
   Aevent++;
   if((Aevent)==((STOP-START))) break;
   
   if(Tevent->GetEntry(i)==0){
     cerr << "error - Tevent->GetEntry()" << endl;
     exit(0);
   }
//cout << i << " " << START << " " << STOP << endl;
//cout << event.event_id << endl;

   if(!TraceCheck(&event)){
     cerr << "ADC overflow -- " << event.event_id  << " -- channel: ";
     cerr << channel_profiles.antenna_pos << " " << channel_profiles.polarisation << endl;
   }
   CorrectADCClipping(event.window_size, event.trace);
   
   for(unsigned int j=0; j<event.window_size; j++) RFITrace[j] = event.trace[j];
   if(!bADCScale) ADC2FieldStrength(event.window_size, RFITrace, header.DAQ_id, 30.0, RefAntCal);
#warning fixed zenith angle to 30 degeree   
   if(bRFISup){
     RFISuppressionMedian((int)event.window_size, RFITrace, RFITrace);
     ZeroPaddingFFT(event.window_size, RFITrace, NoZeros, TRACEZP);
   }
   else ZeroPaddingFFT(event.window_size, RFITrace, NoZeros,  TRACEZP);
   
   if(!bMeanTrace) for(int j=0; j<New_window_size; j++) TraceZP[Aevent][j]=TRACEZP[j];
    else{
      hilbert(New_window_size, TRACEZP, MeanTraceZPtmp_im);
      for(int j=0; j<New_window_size; j++){
        MeanTraceZPtmp_re[j]= TRACEZP[j];
      }
    }

   if(!bTeventExtend){
     ChId=0;
     Tchannel_profile->GetEntry(ChId);
     while( event.channel_profile_id != channel_profiles.ch_id ){
       ChId++;
       if(Tchannel_profile->GetEntry(ChId)==0){
         cerr << "error - Tchannel_profile->GetEntry()" << endl;
         exit(0);
       }
     }
   }

   sprintf(title,"D%i_%s_%s, %s, run=%i, event_id=%i",header.DAQ_id, channel_profiles.antenna_pos, 
   		channel_profiles.polarisation, event.timestamp, header.run_id, event.event_id);

   if(id_timestamp_output && (i%NoChannels)==0) cout << event.event_id << " - " << event.timestamp << endl;

   if(!bMeanTrace){
     gZP[(Aevent)] = new TGraph (New_window_size,TimeFFTZP,TraceZP[(Aevent)]);
     sprintf(name,"traceZP%i_%03i",channel_profiles.ch_id,(Aevent));	
     gZP[(Aevent)]->SetName(name);
     gZP[(Aevent)]->SetTitle(title);
     gZP[(Aevent)]->GetXaxis()->SetTitle("time / #mus");
     if(!bADCScale) gZP[(Aevent)]->GetYaxis()->SetTitle("field strength [#muV #upoint m^{-1}]");
     else gZP[(Aevent)]->GetYaxis()->SetTitle("ADC value");

     //sprintf(name,"canZP%i_%03i",channel_profiles.ch_id,(Aevent));	
     sprintf(name,"canZP_%05i",(Aevent));	
     canZP[(Aevent)]= new TCanvas(name,title);  
   }
   else{
     int j=0;
     for(j=0; j<NoChannels; j++){
       if(ChID[j] == channel_profiles.ch_id) break;
     }
     for(int a=0; a<New_window_size; a++){
       MeanTraceZP_re[j][a] += MeanTraceZPtmp_re[a];
       MeanTraceZP_im[j][a] += MeanTraceZPtmp_im[a];
     }
   }
 

  
} // end for over all traces and events
  



  output = new TFile (OutputFileName,"Update","trace analaysis");
  
  output->cd();
  char position[5];
  char pol[50];
  int division=(int)NoChannels/2;
  if((int)NoChannels%2 != 0 ) division++;
  
  char AntPos[NoChannels][50];
  char AntPol[NoChannels][50];
  for(int i=0; i<NoChannels; i++){
    if(bTeventExtend){
     if(Tevent->GetEntry(i)==0){
       cerr << "error - Tevent->GetEntry()" << endl;
       exit(0);
      }
    }
    else
     if(Tchannel_profile->GetEntry(i)==0){
       cerr << "error - Tchannel_profile->GetEntry()" << endl;
       exit(0);
     }
    strcpy(AntPos[i],channel_profiles.antenna_pos);
    strcpy(AntPol[i],channel_profiles.polarisation);
    strcat(AntPol[i],",");
//    cout << AntPos[i] << " " << AntPol[i] << endl;
  }

   double ymin=0, ymax=0;
   float expectedTrigger = 0;
   if(!bMeanTrace) for(int i=0; i<(Aevent+1)/NoChannels; i++){
     canZP[i*NoChannels]->cd();
     canZP[i*NoChannels]->Divide(2,division);

     if(bTeventExtend) Tevent->GetEntry(START+i*NoChannels);
     if(zoom && header.DAQ_id==30) expectedTrigger = (event.window_size - header.posttrigger - 500);
       else expectedTrigger = (event.window_size - header.posttrigger);
    
     //find max and min y axis range
     ymin=0, ymax=0;
     for(int j=0; j<NoChannels; j++){
      if(gZP[i*NoChannels+j]->GetYaxis()->GetXmax() > ymax) ymax = gZP[i*NoChannels+j]->GetYaxis()->GetXmax();
      if(gZP[i*NoChannels+j]->GetYaxis()->GetXmin() < ymin) ymin = gZP[i*NoChannels+j]->GetYaxis()->GetXmin();
     }

     for(int j=0; j<NoChannels; j++){
//       gZP[i*NoChannels+j]->GetXaxis()->SetRangeUser(400,600);
       
       strcpy(position,"123");
       sscanf(gZP[i*NoChannels+j]->GetTitle(),"%*c%*i_%c%c%c_%s CH0",&position[0], &position[1], &position[2],pol);
//cout << gZP[i*NoChannels+j]->GetTitle() << endl;
//cout << position << " -- " << pol << " -- " << endl;
      
       if(zoom)gZP[i*NoChannels+j]->GetXaxis()->SetRangeUser((double)((expectedTrigger-200)*12.5/1000.0),(double)((expectedTrigger+200)*12.5/1000.0));
       //cout << "Y max = "<< gZP[i*NoChannels+j]->GetYaxis()->GetXmax()<< endl;
       //cout << "Y min = "<< gZP[i*NoChannels+j]->GetYaxis()->GetXmin()<< endl;
       //set the y scaling of one event to the same range
       gZP[i*NoChannels+j]->GetYaxis()->SetRangeUser(ymin,ymax);
       for(int a=0; a<NoChannels; a++){
         if(!strcmp(position,AntPos[a]) && !strcmp(pol,AntPol[a])){
	   //cout << a << " " <<  AntPos[a] << " " << AntPol[a] << " " << position << " " << pol << endl;

//           if(a>4 && header.DAQ_id==17 && header.run_id < 20 ) a++;
#warning solution for old data?

	   canZP[i*NoChannels]->cd(a+1);
           gZP[i*NoChannels+j]->Draw("AL"); 
if(0) gZP[i*NoChannels+j]->Write();

	 }
       }
       
     }
     
     canZP[i*NoChannels]->Write();
     
   }
   else{
     canMeanTrace = new TCanvas("canMeanTrace","mean trace over run");
     canMeanTrace->cd();
     canMeanTrace->Divide(2,division);
  
     for(int i=0; i<NoChannels; i++){
       
       for(int j=0; j<New_window_size; j++){
         MeanTraceZP_re[i][j] /= countMeanEvent;
	 MeanTraceZP_im[i][j] /= countMeanEvent;
	 MeanTraceZP_re[i][j] = sqrt( pow(MeanTraceZP_re[i][j],2) + pow(MeanTraceZP_im[i][j],2) );
       }
       
      if(bTeventExtend){
       if(Tevent->GetEntry(i)==0){
         cerr << "error - Tevent->GetEntry()" << endl;
         exit(0);
        }
      }
      else
       if(Tchannel_profile->GetEntry(i)==0){
         cerr << "error - Tchannel_profile->GetEntry()" << endl;
         exit(0);
       }
       
       gMeanTrace[i] = new TGraph (New_window_size, TimeFFTZP, MeanTraceZP_re[i]);
       sprintf(name,"meantrace%d",ChID[i]);
       //cout << name << endl;
       gMeanTrace[i]->SetName(name);
       sprintf(title,"mean trace over %i events - D%i_%s_%s, run=%i",(STOP-START)/NoChannels, header.DAQ_id, channel_profiles.antenna_pos, channel_profiles.polarisation, header.run_id);
       //cout << title << endl;
       gMeanTrace[i]->SetTitle(title);
       gMeanTrace[i]->GetXaxis()->SetTitle("time / #mus");
       if(!bADCScale) gMeanTrace[i]->GetYaxis()->SetTitle("field strength [#muV #upoint m^{-1}]");
       else gMeanTrace[i]->GetYaxis()->SetTitle("| arbitrary unit |");
       
       strcpy(position,"123");
       sscanf(gMeanTrace[i]->GetTitle(),"%*s %*s %*s %*i %*s - %*c%*i_%c%c%c_%s CH0",&position[0], &position[1], &position[2],pol);
       //cout << position << "-" << pol << "-" << endl;


       for(int a=0; a<NoChannels; a++){
         if(!strcmp(position,AntPos[a]) && !strcmp(pol,AntPol[a])){
           //cout << a << " " <<  AntPos[a] << " " << AntPol[a] << " " << position << " " << pol << endl;
//           if(a>4 && header.DAQ_id==17 && header.run_id < 20 ) a++;
	   canMeanTrace->cd(a+1);
           gMeanTrace[i]->Draw("AL");
if(0) gMeanTrace[i]->Write();	   
	 }
       }
       
     }

     //find max and min y axis range
     ymin=0, ymax=0;
     for(int j=0; j<NoChannels; j++){
       if(gMeanTrace[j]->GetYaxis()->GetXmax() > ymax) ymax = gMeanTrace[j]->GetYaxis()->GetXmax();
       if(gMeanTrace[j]->GetYaxis()->GetXmin() < ymin) ymin = gMeanTrace[j]->GetYaxis()->GetXmin();
     }
     for(int j=0; j<NoChannels; j++){
       gMeanTrace[j]->GetYaxis()->SetRangeUser(ymin,ymax);
     }
     canMeanTrace->Write();
   }
    


output->Close();
delete output;


delete Tevent;
delete Theader;
delete Tchannel_profile;

if(!bMeanTrace)
 for(int i=0; i<(STOP-START); i++){
   delete canZP[i];
   delete gZP[i];
   delete[] TraceZP[i];
 }

if(!bMeanTrace){
  delete canZP;
  delete gZP;
  delete[] TraceZP;
}

delete[] TRACEZP;
delete[] RFITrace;

for(int i=0; i<NoChannels; i++){
 delete[] MeanTraceZP_re[i];
 delete[] MeanTraceZP_im[i];
}

delete gMeanTrace;
if(bMeanTrace) delete canMeanTrace;
delete[] MeanTraceZP_re;
delete[] MeanTraceZP_im;
delete[] MeanTraceZPtmp_re;
delete[] MeanTraceZPtmp_im;

}

