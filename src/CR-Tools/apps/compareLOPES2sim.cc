/*-------------------------------------------------------------------------*
 | $Id::                                                                 $ |
 *-------------------------------------------------------------------------*
 ***************************************************************************
 *   Copyright (C) 2010                                                    *
 *   Frank Schr√∂der , Nunzia Palmieri                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include<cstdlib>
#include<iostream>
#include<fstream>
#include<string>
#include<sstream>
#include<time.h>

#include<TFile.h>
#include<TTree.h>
#include<TMath.h>
#include<TCut.h>
#include <Rtypes.h>

#include <crtools.h>
#include <Analysis/lateralDistribution.h>
#include <Analysis/PulseProperties.h>

// using CR::analyseLOPESevent2;
// using CR::LopesEventIn;


/*!
  \file compareLOPES2sim.cc

  \ingroup CR_Applications

  \brief Compares lateral distribution of LOPES events to REAS simulation

  \author Frank Schr&ouml;der

  \date 2008/20/05

  <h3>Motivation</h3>

 
  <h3>Usage</h3>

  \verbatim
  ./compareLOPES2sim --data results.root  --dict dictionary.txt  --path ../reas3simulations/lopeseventsR3i/
  \endverbatim

  <ul>
    Optional argumens:
    <li> --help                           prints a help message
  </ul>

  <h3>Prerequisites</h3>

  ROOT
  
  <h3>Examples</h3>

  \verbatim
  ./compareLOPES2sim --help
  \endverbatim
*/


const static double gradeg=180./(TMath::Pi());

int main (int argc, char *argv[])
{
  try {
    if(argc<=1) {
      cout << "\n Application to generate lateral distribution plots for both LOPES data and simulations,\n"
           << "based on the ROOT file generated by call_pipeline and REAS3 simulations.\n"
           << "Type: ./compareLOPES2sim --help"
           << endl;
      return 1;
    } else {
      cout << "\nStarting compareLOPES2sim.\n" << endl;
    }

    // check arguments
    string resultsName1(""), resultsName2(""), simDictName(""), simPath("");
    string index1(""), index2("");  // name indices for lateral distribution
    for (int i=1; i < argc; ++i) {
      // get option and argument
      string option(argv[i]);
      ++i;
      // look for keywords which require no argument
      if ( (option == "--help") || (option == "-help")
        || (option == "--h") || (option == "-h")) {
	cout << "Use:\n"
             << "./compareLOPES2sim --data results1.root --data2 results2.root\n"
             << "or\n"
             << "./compareLOPES2sim --data results.root --dict simDictionary.txt --path pathToSimulations\n"
	     << endl;
	return 0;       // exit here
      } 
      // all other options require also an argument
      if (i >= argc) {
        cerr << "ERROR: No argument given for option or unknown option: \"" << option << "\"\n";
        cerr << "Use --help for more information." << endl;
        return 1;                       // Exit the program if argument is missing
      }
      string argument(argv[i]);
      
      // look for keywords which require an option
      if ( (option == "--data") || (option == "-data")
         ||(option == "--data1") || (option == "-data1")) {
        resultsName1 = argument;
        continue;
      }

      if ( (option == "--data2") || (option == "-data2")) {
        resultsName2 = argument;
        continue;
      }

      if ( (option == "--dict") || (option == "-dict")) {
        simDictName = argument;
        continue;
      }

      if ( (option == "--path") || (option == "-path")) {
        simPath = argument;
        continue;
      }

      // if loop comes here, the option was not found
      cerr << "ERROR: Invalid option: \"" << option << "\"\n";
      cerr << "Use --help for more information." << endl;
      return 1;                 // Exit the program if argument is missing
    }

    // check consistency
    if ( (resultsName1=="") || (((simPath=="")||(simDictName=="")) && (resultsName2=="")) ) {
      cerr << "Error: missing / false options specified.\n";
      cerr << "Use --help for more information." << endl;
      return 1;                 
    }
    
    // map dic declaration
    map<int,string> m_dict;
    
    // open dictionary with simulations, if it is provided
    if (simDictName!="") {
      // set indices
      index1 = "dat";
      index2 = "sim";
    
      int GtDict=0;
      string simNameDict;
      double dummy;
      ifstream dictFile(simDictName.c_str());
      if (!dictFile.is_open()) {
        cerr << "ERROR ----- CAN NOT OPEN THE DICTIONARY FILE!" << endl;
        return 1;  
      }
      char buffer[1024];
    
      while (dictFile.is_open()) {
        dictFile.getline(buffer,1024);
        istringstream iss (buffer);
        if(iss.str().size()>0&&iss.str()[0]!='%'&&iss.str()[0]!='#') {
          iss>>GtDict>>simNameDict>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy;
          m_dict[GtDict]=simNameDict; //fill the map dictionary 
          cout<<""<<simNameDict<<endl;
          cout<<""<<GtDict<<endl;
        }
        if (!dictFile.good())
          break;
      } // while...
      dictFile.close();
    }  

    /*root file from call_pipeline*/
    int totAntenna = 30;

    TFile *recRoot = new TFile (resultsName1.c_str(), "READ");
    if(!recRoot || recRoot->IsZombie()) {
      cerr << "Error, cannot open root file: "<< resultsName1 << endl;
      return 1;  
    } 
       
    //recRoot->ls();
    TTree *recTree =  (TTree*)recRoot->Get("T;1");
    //if(!recTree) return;

    //PulseProperties[totAntenna] antPulses; //each antenna 1 pulseProperties
    PulseProperties* antPulses[totAntenna];
    PulseProperties* antPulses2[totAntenna];  // for eventual second root file

    unsigned int Gt;
    float_t Az = 0, Ze = 0, Xc = 0, Yc = 0;                 // KASCADE direction and core
    float_t Azg = 0, Zeg = 0, Xcg = 0, Ycg = 0;             // Grande direction and core
    float_t Size = 0, Sizeg = 0;                            // Electron numbers (KASCADE + Grande)
    float_t Age = 0, Ageg = 0;                              // Age parameter
    float_t Nmu = 0, Lmuo = 0, Sizmg = 0;                   // Muon number, trucated muon number (KASCADE), Muon number (Grande)
    double_t lgE = 0, err_lgE = 0;                          // estimated energy (KASCADE)
    double_t lgEg = 0, err_lgEg = 0;                        // estimated energy (Grande)
    double_t lnA = 0, err_lnA = 0;                          // estimated mass A (KASCADE)
    double_t lnAg = 0, err_lnAg = 0;                        // estimated mass A (Grande)
    double_t kappaMario = 0, lgEMario = 0;                  // mass and energy by Mario's formula
    double_t err_core = 0, err_coreg = 0;                   // error of core position (KASCADE + Grande)
    double_t err_Az = 0, err_Azg = 0;                       // error of azimuth (KASCADE + Grande)
    double_t err_Ze = 0, err_Zeg = 0;                       // error of zenith (KASCADE + Grande)
    double_t geomag_angle = 0, geomag_angleg = 0;           // geomagnetic angle (KASCADE + Grande)
    char KRETAver[1024] = "unknown";
    double_t EfieldMaxAbs = 0;                              // maximum of the absolute e-field strength around +/- 15 min
    double_t EfieldAvgAbs = 0;                              // average of the absolute e-field strength around +/- 15 min    
    char reconstruction = 0;                                // A = KASCADE reconstruction taken, G = Grande reconstruction taken
    bool hasNS = false;                                     // is set to true, if root file contains NS information
    bool hasVE = false;                                     // is set to true, if root file contains VE information
    double CCheight, CCheight_NS, CCheight_VE;                          // CCheight will be used for EW polarization or ANY polarization
    double CCwidth, CCwidth_NS, CCwidth_VE;
    double CCcenter, CCcenter_NS, CCcenter_VE;                    // time of CC beam
    double CCheight_error, CCheight_error_NS, CCheight_error_VE;
    bool CCconverged, CCconvergedNS, CCconvergedVE;                       // is true if the Gaussian fit to the CCbeam converged
    double Xheight, Xheight_NS, Xheight_VE;                            // CCheight will be used for EW polarization or ANY polarization
    double Xheight_error, Xheight_error_NS, Xheight_error_VE;
    bool Xconverged, XconvergedNS, XconvergedVE;                         // is true if the Gaussian fit to the CCbeam converged
    double AzL, ElL, AzL_NS, ElL_NS, AzL_VE, ElL_VE;                       // Azimuth and Elevation
    double distanceResult = 0, distanceResultNS = 0, distanceResultVE = 0;       // distance = radius of curvature
    // values for lateral distribution of arrival times
    double latTimeRcurv = 0, latTimeRcurv_NS = 0, latTimeRcurv_VE = 0;
    double latTimeSigRcurv = 0, latTimeSigRcurv_NS = 0, latTimeSigRcurv_VE = 0;
    double latTimeOffset = 0, latTimeOffset_NS = 0, latTimeOffset_VE = 0;
    double latTimeSigOffset = 0, latTimeSigOffset_NS = 0, latTimeSigOffset_VE = 0;
    double latTimeChi2NDF = 0, latTimeChi2NDF_NS = 0, latTimeChi2NDF_VE = 0;
  
    bool goodEW = false, goodNS = false, goodVE = false;                // true if reconstruction worked
    double rmsCCbeam, rmsCCbeam_NS, rmsCCbeam_VE;                        // rms values of the beams in remote region
    double rmsXbeam, rmsXbeam_NS, rmsXbeam_VE;
    double rmsPbeam, rmsPbeam_NS, rmsPbeam_VE;
    unsigned int NCCbeamAntennas = 0, NlateralAntennas = 0; // antennas used for CC beam and lateral distribution
    unsigned int NCCbeamAntennas_NS = 0, NlateralAntennas_NS = 0; // antennas used for CC beam and lateral distribution
    unsigned int NCCbeamAntennas_VE = 0, NlateralAntennas_VE = 0; // antennas used for CC beam and lateral distribution
    double latMeanDist, latMeanDist_NS, latMeanDist_VE;                 // mean distance of the antennas in the lateral distribution
    double latMeanDistCC, latMeanDistCC_NS, latMeanDistCC_VE;             // mean distance of the antennas used for the CC beam
    double ratioDiffSign, ratioDiffSign_NS, ratioDiffSign_VE;
    double ratioDiffSignEnv, ratioDiffSignEnv_NS, ratioDiffSignEnv_VE;
    double weightedTotSign,weightedTotSign_NS,weightedTotSign_VE;
    double weightedTotSignEnv,weightedTotSignEnv_NS,weightedTotSignEnv_VE;

    
    recTree->SetBranchAddress("Gt", &Gt);
    recTree->SetBranchAddress("Xc",&Xc);
    recTree->SetBranchAddress("Xcg",&Xcg);
    recTree->SetBranchAddress("Yc",&Yc);
    recTree->SetBranchAddress("Ycg",&Ycg);
    recTree->SetBranchAddress("Az",&Az);
    recTree->SetBranchAddress("Azg",&Azg);
    recTree->SetBranchAddress("Ze",&Ze);
    recTree->SetBranchAddress("Zeg",&Zeg);
    recTree->SetBranchAddress("Size",&Size);
    recTree->SetBranchAddress("Sizeg",&Sizeg);
    recTree->SetBranchAddress("Age",&Age);
    recTree->SetBranchAddress("Ageg",&Ageg);
    recTree->SetBranchAddress("Nmu",&Nmu);
    recTree->SetBranchAddress("Lmuo",&Lmuo);
    recTree->SetBranchAddress("Sizmg",&Sizmg);
    recTree->SetBranchAddress("lgE",&lgE);
    recTree->SetBranchAddress("lgEg",&lgEg);
    recTree->SetBranchAddress("lnA",&lnA);
    recTree->SetBranchAddress("lnAg",&lnAg);
    recTree->SetBranchAddress("kappaMario",&kappaMario);
    recTree->SetBranchAddress("lgEMario",&lgEMario);
    recTree->SetBranchAddress("err_lgE",&err_lgE);
    recTree->SetBranchAddress("err_lgEg",&err_lgEg);
    recTree->SetBranchAddress("err_lnA",&err_lnA);
    recTree->SetBranchAddress("err_lnAg",&err_lnAg);
    recTree->SetBranchAddress("err_core",&err_core);
    recTree->SetBranchAddress("err_coreg",&err_coreg);
    recTree->SetBranchAddress("err_Az",&err_Az);
    recTree->SetBranchAddress("err_Azg",&err_Azg);
    recTree->SetBranchAddress("err_Ze",&err_Ze);
    recTree->SetBranchAddress("err_Zeg",&err_Zeg);
    recTree->SetBranchAddress("geomag_angle",&geomag_angle);
    recTree->SetBranchAddress("geomag_angleg",&geomag_angleg);
    recTree->SetBranchAddress("reconstruction",&reconstruction);
    recTree->SetBranchAddress("KRETAver",&KRETAver);
    recTree->SetBranchAddress("EfieldMaxAbs",&EfieldMaxAbs);
    recTree->SetBranchAddress("EfieldAvgAbs",&EfieldAvgAbs);
    
    // look for existing EW branches
    TObjArray* existingBranches = recTree->GetListOfBranches();
    if (existingBranches->FindObject("AzL_EW")==0) {
      cerr << "Error: No EW polarization data found in root file." << endl;
      return 1;
    } else {
      recTree->SetBranchAddress("AzL_EW",&AzL);
      recTree->SetBranchAddress("ElL_EW",&ElL);
      recTree->SetBranchAddress("Distance_EW",&distanceResult);        // radius of curvature
      recTree->SetBranchAddress("CCheight_EW",&CCheight);
      recTree->SetBranchAddress("CCwidth_EW",&CCwidth);
      recTree->SetBranchAddress("CCcenter_EW",&CCcenter);
      recTree->SetBranchAddress("CCheight_error_EW",&CCheight_error);
      recTree->SetBranchAddress("CCconverged_EW",&CCconverged);
      recTree->SetBranchAddress("Xheight_EW",&Xheight);
      recTree->SetBranchAddress("Xheight_error_EW",&Xheight_error);
      recTree->SetBranchAddress("Xconverged_EW",&Xconverged);
      recTree->SetBranchAddress("goodReconstructed_EW",&goodEW);
      recTree->SetBranchAddress("rmsCCbeam_EW",&rmsCCbeam);
      recTree->SetBranchAddress("rmsXbeam_EW",&rmsXbeam);
      recTree->SetBranchAddress("rmsPbeam_EW",&rmsPbeam);
      recTree->SetBranchAddress("latMeanDistCC_EW",&latMeanDistCC);
      recTree->SetBranchAddress("NCCbeamAntennas_EW",&NCCbeamAntennas);
      recTree->SetBranchAddress("ratioDiffSign_EW",&ratioDiffSign);
      recTree->SetBranchAddress("ratioDiffSignEnv_EW",&ratioDiffSignEnv);
      recTree->SetBranchAddress("weightedTotSign_EW",&weightedTotSign);
      recTree->SetBranchAddress("weightedTotSignEnv_EW",&weightedTotSignEnv);
      recTree->SetBranchAddress("latMeanDist_EW",&latMeanDist);
      recTree->SetBranchAddress("NlateralAntennas_EW",&NlateralAntennas);
      recTree->SetBranchAddress("latTimeRcurv_EW",&latTimeRcurv);
      recTree->SetBranchAddress("latTimeSigRcurv_EW",&latTimeSigRcurv);
      recTree->SetBranchAddress("latTimeOffset_EW",&latTimeOffset);
      recTree->SetBranchAddress("latTimeSigOffset_EW",&latTimeSigOffset);
      recTree->SetBranchAddress("latTimeChi2NDF_EW",&latTimeChi2NDF);
    }
    if (existingBranches->FindObject("AzL_NS")==0) {
      cerr << "Warning: No NS polarization data found in root file." << endl;
      hasNS = false;
    } else {
      hasNS = true;
    }
    
    // open second data file, if requested
    UInt_t Gt2;
    TFile *recRoot2;
    TTree *recTree2;   
    if (resultsName2 != "") {
      // set indices
      index1 = "old";
      index2 = "new";

      recRoot2 = new TFile (resultsName2.c_str(), "READ");
      if(!recRoot2 || recRoot2->IsZombie()) {
        cerr << "Error, cannot open root file: "<< resultsName2 << endl;
      return 1;  
      } 
      recTree2 = (TTree*)recRoot2->Get("T;1");
      recTree2->SetBranchAddress("Gt", &Gt2);   
      
      cout << "Comparing files: " << resultsName1 << " and " << resultsName2 <<endl;
    }
        
    for (int i=0; i < totAntenna; ++i) {
      antPulses[i] = new PulseProperties();
      antPulses2[i] = new PulseProperties();
    }

    for(int i=0; i< totAntenna; ++i) {
      stringstream antNumber("");
      antNumber << (i+1);
      string antBranchName;
      antBranchName = "Ant_" + antNumber.str() + "_cal.";
      if (existingBranches->FindObject(antBranchName.c_str())==0) {
        cerr << "Branch \"" << antBranchName << "\" does not exist." << endl;
        return 1;
      }
      recTree->SetBranchAddress(antBranchName.c_str(), &antPulses[i]);
      if (resultsName2 != "") 
        recTree2->SetBranchAddress(antBranchName.c_str(), &antPulses2[i]);
    }

    int entries = recTree->GetEntries();
      cout<<"---------- >  Root file entries :   "<<entries<<endl;
    if (resultsName2 != "") {    
      if (entries > recTree2->GetEntries()) {
        cerr << "Error: The bigger root file must be the last one.\n" << endl;
        return 1;
      }
    }
      
    /* output files*/
    ofstream outputEW("simANDrec_fitvalue_EW.dat");
    ofstream outputNS("simANDrec_fitvalue_NS.dat");
    outputEW<<"#sim id , eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;
    outputNS<<"#sim id , eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;

    for(int i=0; i<entries; ++i) { //loop on the events
      for (int k=0; k < totAntenna; ++k) {
          *antPulses[k] = PulseProperties();
        }
      recTree->GetEntry(i);
      if (resultsName2 != "") {
        while (Gt2 < Gt) {
          recTree2->GetEntry(i);
        }
        if (Gt2 != Gt) {
          cerr << "Error: Event at GT " << Gt << " seems to be missing in second root file.\n" << endl;
          return 1;       
        }
      }

      map<int,PulseProperties> m_recPulses;
      map<int,PulseProperties> m_recPulses2;
      map<int,PulseProperties> m_recEW;
      map<int,PulseProperties> m_recNS;
      map<int,PulseProperties> m_simEW;
      map<int,PulseProperties> m_simNS;

      //int NantR[totAntenna]=antPulses[totAntenna].antennaID; 

      //fill the first rec maps
      for(int j=0; j<totAntenna; j++) {
        m_recPulses[antPulses[j]->antennaID] = *antPulses[j]; //I fill the rec map with pulse properties in the root file
        
        // also fill the second data map, if provided
        if (resultsName2!="") {
          m_recPulses2[antPulses2[j]->antennaID] = *antPulses2[j];
          if (antPulses[j]->antennaID != antPulses2[j]->antennaID) {
            cerr << "Error: Antenna IDs of both root files do not match.\n" << endl;
            return 1;
          }
          if (antPulses[j]->polarization != antPulses2[j]->polarization) {
            cerr << "Error: Polarization of both root files do not match.\n" << endl;
            return 1;
          }
          
          if (antPulses[j]->polarization == "EW") {
            m_recEW[antPulses[j]->antennaID] = *antPulses[j]; 
            m_simEW[antPulses2[j]->antennaID] = *antPulses2[j]; 
          } 
          if (antPulses[j]->polarization == "NS") {
            m_recNS[antPulses[j]->antennaID] = *antPulses[j]; 
            m_simNS[antPulses2[j]->antennaID] = *antPulses2[j]; 
          } 
        }  
      }
      
      /*sim file*/
      if (simDictName!="") {
        int NantS=0;
        double EWfield=0.,NSfield=0.,VEfield=0.;
        double distS=0.,azS=0.;
        double sim2lopesField=(2.9979246e+10/31.); //convert to muV/m/MHz and divide by the band-width
        double distanceS=0., distanceSerr=0.,showerCoord=0.;
        double dummy;
        double distanceR=0.;

        string reasFileName = simPath+m_dict[Gt]+ "_lopesdual_43to74Mhz_allCompMaxima/maxamp_summary.dat";
        //string reasFileName = simPath+m_dict[Gt]+ "_lopesew_43to74Mhz_allCompMaxima/maxamp_summary.dat"; 
        //string reasFileName = simPath+m_dict[Gt]+ "_lopesdual_43to74Mhz/maxamp_summary.dat";
        ifstream reasFile(reasFileName.c_str());
        if (!reasFile.is_open()) {
          cerr << "ERROR ----- CAN NOT OPEN THE FILE for REAS!" <<endl;
          cerr << "No simulated event for Gt: " <<Gt<< endl;
          //return 1;     
          continue;
        }
        char buffer2[1024];
        while (reasFile.good()) {
          reasFile.getline(buffer2,1024);
          istringstream iss2 (buffer2);
          if(iss2.str().size()>0&&iss2.str()[0]!='%'&&iss2.str()[0]!='#') {	//in sim file:az in reas sistem
            iss2>>NantS>>distS>>azS>>NSfield>>EWfield>>VEfield>>dummy;
            cout<<"az sim : "<< azS << " az data LOPES : " << Az<<" ze LOPES "<<Ze<<endl;
            //calc distance
            showerCoord=sqrt(1.0 - pow(cos(azS-Az),2)*pow(sin(Ze),2));
            distanceS=0.01*distS*showerCoord;
            //distanceSerr=15.; 
            //calc field strength
            NSfield*=sim2lopesField;
            EWfield*=sim2lopesField;
            if(NSfield<0.1)
                NSfield=0.1;
            if(EWfield<0.1)
                EWfield=0.1;
            //TODO calc error

            //look if antenna exists at all in data then separe EW and NS
            if (m_recPulses.find(NantS) != m_recPulses.end()) { 
              if (m_recPulses[NantS].polarization == "EW") {
                cout<<"   xxxxxx   EW polarization   xxxxxx  "<<endl;
                //define recEW map
                m_recEW[NantS] = m_recPulses[NantS];
                cout<<"rec EW map size   :"<<m_recEW.size()<<endl;
                //define simEW map
                PulseProperties simPropEW;
                simPropEW.antennaID = NantS; //antennaid vs antenna no?
                simPropEW.height = EWfield;
                cout<<"EW Field  "<<EWfield<<endl;
                simPropEW.heightError = 0.;
                distanceR=m_recEW[NantS].dist;
                if ((distanceS-distanceR)>(distanceS*0.01)) {
                  cout<<"WARNING!"<<endl;
                  cout<<"distance simulated EW channel:  "<<distanceS<<" distance from LOPES  "<<distanceR<<endl;
                }
                simPropEW.dist =distanceR;
                simPropEW.disterr = distanceSerr;
                m_simEW[NantS] = simPropEW; //fill the sim map
              }
              if (m_recPulses[NantS].polarization == "NS") {
                cout<<"   kkkkkk   NS polarization   kkkkkk  "<<endl;
                //define recNS map
                m_recNS[NantS] = m_recPulses[NantS];
                cout<<"rec NS map size   :"<<m_recNS.size()<<endl;
                //define simEW map
                PulseProperties simPropNS;
                simPropNS.antennaID = NantS; //antennaid vs antenna no?
                simPropNS.height = NSfield;
                cout<<"NS Field  "<<NSfield<<endl;
                simPropNS.heightError = 0.;
                distanceR=m_recNS[NantS].dist;
                if ((distanceS-distanceR)>(distanceS*0.01)) {
                  cout<<"WARNING!"<<endl;
                  cout<<"distance simulated NS channel:  "<<distanceS<<" distance from LOPES  "<<distanceR<<endl;
                }
                simPropNS.dist =distanceR;
                simPropNS.disterr = distanceSerr;
          
                m_simNS[NantS] = simPropNS;//fill the sim map
              }
            }
          }
        } // while...
        reasFile.close();
      } 
      
      double Epsilon0=0.,R0=0.,err_Epsilon0=0.,err_R0=0.,chi2NDF=0.;
      double Epsilon0S=0.,R0S=0.,err_Epsilon0S=0.,err_R0S=0.,chi2NDFS=0.;
      CR::lateralDistribution lateralFitter;
      string plotPrefix = "";
      if(m_recEW.size()>=4) {        
        if (simDictName!="") 
          plotPrefix = "lateral-EW-"+m_dict[Gt]+"-";
        else 
          plotPrefix = "lateral-EW-";
        Record ergew = lateralFitter.fitLateralDistribution(plotPrefix,
                                                            m_recEW,m_simEW,
                                                            Gt,(Az*gradeg),(Ze*gradeg),
                                                            index1, index2);
        Epsilon0 = ergew.asDouble("eps");
        R0 = ergew.asDouble("R_0");
        err_Epsilon0 = ergew.asDouble("sigeps");
        err_R0 = ergew.asDouble("sigR_0");
        chi2NDF = ergew.asDouble("chi2NDF");
        Epsilon0S = ergew.asDouble("eps_sim");
        R0S = ergew.asDouble("R_0_sim");
        err_Epsilon0S = ergew.asDouble("sigeps_sim");
        err_R0S = ergew.asDouble("sigR_0_sim");
        chi2NDFS = ergew.asDouble("chi2NDF_sim");

        //write info of the fit into file
        outputEW <<m_dict[Gt]<<"\t"<<Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			
      }
      if ((hasNS) && (m_recNS.size()>=4)) {
        if (simDictName!="") 
          plotPrefix = "lateral-NS-"+m_dict[Gt]+"-";
        else 
          plotPrefix = "lateral-NS-";
        Record ergns = lateralFitter.fitLateralDistribution(plotPrefix,
                                                            m_recNS,m_simNS,
                                                            Gt,(Az*gradeg),(Ze*gradeg),
                                                            index1, index2);
        Epsilon0 = ergns.asDouble("eps");
        R0 = ergns.asDouble("R_0");
        err_Epsilon0 = ergns.asDouble("sigeps");
        err_R0 = ergns.asDouble("sigR_0");
        chi2NDF = ergns.asDouble("chi2NDF");
        Epsilon0S = ergns.asDouble("eps_sim");
        R0S = ergns.asDouble("R_0_sim");
        err_Epsilon0S = ergns.asDouble("sigeps_sim");
        err_R0S = ergns.asDouble("sigR_0_sim");
        chi2NDFS = ergns.asDouble("chi2NDF_sim");

        outputNS <<m_dict[Gt]<<"\t"<<Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			
      }
    }//loop on the rec event 

    outputEW.close();
    outputNS.close();
  } catch (AipsError x) {
    cerr << "compareLOPES2sim: " << x.getMesg() << endl;
  }
  
  return 0;
}

