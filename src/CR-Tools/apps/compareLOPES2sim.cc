/*-------------------------------------------------------------------------*
 | $Id::                                                                 $ |
 *-------------------------------------------------------------------------*
 ***************************************************************************
 *   Copyright (C) 2010                                                    *
 *   Frank Schr√∂der , Nunzia Palmieri                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include<cstdlib>
#include<iostream>
#include<fstream>
#include<string>
#include<sstream>
#include<time.h>

#include<TFile.h>
#include<TTree.h>
#include<TMath.h>
#include<TCut.h>
#include <Rtypes.h>

#include <crtools.h>
#include <Analysis/lateralDistribution.h>
#include <Analysis/PulseProperties.h>

// using CR::analyseLOPESevent2;
// using CR::LopesEventIn;


/*!
  \file compareLOPES2sim.cc

  \ingroup CR_Applications

  \brief Compares lateral distribution of LOPES events to REAS simulation

  \author Frank Schr&ouml;der

  \date 2008/20/05

  <h3>Motivation</h3>

 
  <h3>Usage</h3>

  \verbatim
  ./compareLOPES2sim --data results.root  --dict dictionary.txt  --path ../reas3simulations/lopeseventsR3i/
  \endverbatim

  <ul>
    Optional argumens:
    <li> --help                           prints a help message
  </ul>

  <h3>Prerequisites</h3>

  ROOT
  
  <h3>Examples</h3>

  \verbatim
  ./compareLOPES2sim --help
  \endverbatim
*/


const static double gradeg=180./(TMath::Pi());

int main (int argc, char *argv[])
{
  try {
    if(argc<=1) {
      cout << "\n Application to generate lateral distribution plots for both LOPES data and simulations,\n"
           << "based on the ROOT file generated by call_pipeline and REAS3 simulations.\n"
           << "Type: ./compareLOPES2sim --help"
           << endl;
      return 1;
    } else {
      cout << "\nStarting compareLOPES2sim.\n" << endl;
    }

    // check arguments
    string resultsName1(""), resultsName2(""), simDictName(""), simPath("");
    string index1(""), index2("");  // name indices for lateral distribution
    for (int i=1; i < argc; ++i) {
      // get option and argument
      string option(argv[i]);
      ++i;
      // look for keywords which require no argument
      if ( (option == "--help") || (option == "-help")
        || (option == "--h") || (option == "-h")) {
	cout << "Use:\n"
             << "./compareLOPES2sim --data results1.root --data2 results2.root\n"
             << "or\n"
             << "./compareLOPES2sim --data results.root --dict simDictionary.txt --path pathToSimulations\n"
	     << endl;
	return 0;       // exit here
      } 
      // all other options require also an argument
      if (i >= argc) {
        cerr << "ERROR: No argument given for option or unknown option: \"" << option << "\"\n";
        cerr << "Use --help for more information." << endl;
        return 1;                       // Exit the program if argument is missing
      }
      string argument(argv[i]);
      
      // look for keywords which require an option
      if ( (option == "--data") || (option == "-data")
         ||(option == "--data1") || (option == "-data1")) {
        resultsName1 = argument;
        continue;
      }

      if ( (option == "--data2") || (option == "-data2")) {
        resultsName2 = argument;
        continue;
      }

      if ( (option == "--dict") || (option == "-dict")) {
        simDictName = argument;
        continue;
      }

      if ( (option == "--path") || (option == "-path")) {
        simPath = argument;
        continue;
      }

      // if loop comes here, the option was not found
      cerr << "ERROR: Invalid option: \"" << option << "\"\n";
      cerr << "Use --help for more information." << endl;
      return 1;                 // Exit the program if argument is missing
    }

    // check consistency
    if ( (resultsName1=="") || (((simPath=="")||(simDictName=="")) && (resultsName2=="")) ) {
      cerr << "Error: missing / false options specified.\n";
      cerr << "Use --help for more information." << endl;
      return 1;                 
    }
    
    // map dic declaration
    map<int,string> m_dict;
    
    // open dictionary with simulations, if it is provided
    if (simDictName!="") {
      // set indices
      index1 = "dat";
      index2 = "sim";
    
      int GtDict=0;
      string simNameDict;
      double dummy;
      ifstream dictFile(simDictName.c_str());
      if (!dictFile.is_open()) {
        cerr << "ERROR ----- CAN NOT OPEN THE DICTIONARY FILE!" << endl;
        return 1;  
      }
      char buffer[1024];
    
      while (dictFile.is_open()) {
        dictFile.getline(buffer,1024);
        istringstream iss (buffer);
        if(iss.str().size()>0&&iss.str()[0]!='%'&&iss.str()[0]!='#') {
          iss>>GtDict>>simNameDict>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy;
          m_dict[GtDict]=simNameDict; //fill the map dictionary 
          cout<<""<<simNameDict<<endl;
          cout<<""<<GtDict<<endl;
        }
        if (!dictFile.good())
          break;
      } // while...
      dictFile.close();
    }  

    /*root file from call_pipeline*/
    UInt_t Gt;
    Float_t Az,Ze;
    int totAntenna = 30;

    TFile *recRoot = new TFile (resultsName1.c_str(), "READ");
    if(!recRoot || recRoot->IsZombie()) {
      cerr << "Error, cannot open root file: "<< resultsName1 << endl;
      return 1;  
    } 
       
    //recRoot->ls();
    TTree *recTree =  (TTree*)recRoot->Get("T;1");
    //if(!recTree) return;

    //PulseProperties[totAntenna] antPulses; //each antenna 1 pulseProperties
    PulseProperties* antPulses[totAntenna];
    PulseProperties* antPulses2[totAntenna];  // for eventual second root file

    recTree->SetBranchAddress("Gt", &Gt);
    recTree->SetBranchAddress("Az", &Az);
    recTree->SetBranchAddress("Ze", &Ze);
    
    // open second data file, if requested
    UInt_t Gt2;
    TFile *recRoot2;
    TTree *recTree2;   
    if (resultsName2 != "") {
      // set indices
      index1 = "old";
      index2 = "new";

      recRoot2 = new TFile (resultsName2.c_str(), "READ");
      if(!recRoot2 || recRoot2->IsZombie()) {
        cerr << "Error, cannot open root file: "<< resultsName2 << endl;
      return 1;  
      } 
      recTree2 = (TTree*)recRoot2->Get("T;1");
      recTree2->SetBranchAddress("Gt", &Gt2);   
      
      cout << "Comparing files: " << resultsName1 << " and " << resultsName2 <<endl;
    }
        
    // TODO: use getListOfBranches to check if branch for antenna exists
    for (int i=0; i < totAntenna; ++i) {
      antPulses[i] = new PulseProperties();
      antPulses2[i] = new PulseProperties();
    }

    for(int i=0; i< totAntenna; ++i) {
      stringstream antNumber("");
      antNumber << (i+1);
      string antBranchName;
      antBranchName = "Ant_" + antNumber.str() + "_cal.";
      // TODO: if  can find antBranchName in list
      recTree->SetBranchAddress(antBranchName.c_str(), &antPulses[i]);
      if (resultsName2 != "") 
        recTree2->SetBranchAddress(antBranchName.c_str(), &antPulses2[i]);
    }

    int entries = recTree->GetEntries();
      cout<<"---------- >  Root file entries :   "<<entries<<endl;
    if (resultsName2 != "") {    
      if (entries > recTree2->GetEntries()) {
        cerr << "Error: The bigger root file must be the last one.\n" << endl;
        return 1;
      }
    }
      
    /* output files*/
    ofstream outputEW("simANDrec_fitvalue_EW.dat");
    ofstream outputNS("simANDrec_fitvalue_NS.dat");
    outputEW<<"# eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;
    outputNS<<"# eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;

    for(int i=0; i<entries; ++i) { //loop on the events
      for (int k=0; k < totAntenna; ++k) {
          *antPulses[k] = PulseProperties();
        }
      recTree->GetEntry(i);
      if (resultsName2 != "") {
        while (Gt2 < Gt) {
          recTree2->GetEntry(i);
        }
        if (Gt2 != Gt) {
          cerr << "Error: Event at GT " << Gt << " seems to be missing in second root file.\n" << endl;
          return 1;       
        }
      }

      map<int,PulseProperties> m_recPulses;
      map<int,PulseProperties> m_recPulses2;
      map<int,PulseProperties> m_recEW;
      map<int,PulseProperties> m_recNS;
      map<int,PulseProperties> m_simEW;
      map<int,PulseProperties> m_simNS;

      //int NantR[totAntenna]=antPulses[totAntenna].antennaID; 

      //fill the first rec maps
      for(int j=0; j<totAntenna; j++) {
        m_recPulses[antPulses[j]->antennaID] = *antPulses[j]; //I fill the rec map with pulse properties in the root file
        
        // also fill the second data map, if provided
        if (resultsName2!="") {
          m_recPulses2[antPulses2[j]->antennaID] = *antPulses2[j];
          if (antPulses[j]->antennaID != antPulses2[j]->antennaID) {
            cerr << "Error: Antenna IDs of both root files do not match.\n" << endl;
            return 1;
          }
          if (antPulses[j]->polarization != antPulses2[j]->polarization) {
            cerr << "Error: Polarization of both root files do not match.\n" << endl;
            return 1;
          }
          
          if (antPulses[j]->polarization == "EW") {
            m_recEW[antPulses[j]->antennaID] = *antPulses[j]; 
            m_simEW[antPulses2[j]->antennaID] = *antPulses2[j]; 
          } 
          if (antPulses[j]->polarization == "NS") {
            m_recNS[antPulses[j]->antennaID] = *antPulses[j]; 
            m_simNS[antPulses2[j]->antennaID] = *antPulses2[j]; 
          } 
        }  
      }
      
      /*sim file*/
      if (simDictName!="") {
        int NantS=0;
        double EWfield=0.,NSfield=0.,VEfield=0.;
        double distS=0.,azS=0.;
        double sim2lopesField=(2.9979246e+10/31.); //convert to muV/m/MHz and divide by the band-width
        double distanceS=0., distanceSerr=0.,showerCoord=0.;
        double dummy;
        double distanceR=0.;

        string reasFileName = simPath+m_dict[Gt]+ "_lopesdual_43to74Mhz_allCompMaxima/maxamp_summary.dat";
        //string reasFileName = simPath+m_dict[Gt]+ "_lopesew_43to74Mhz_allCompMaxima/maxamp_summary.dat"; 
        //string reasFileName = simPath+m_dict[Gt]+ "_lopesdual_43to74Mhz/maxamp_summary.dat";
        ifstream reasFile(reasFileName.c_str());
        if (!reasFile.is_open()) {
          cerr << "ERROR ----- CAN NOT OPEN THE FILE for REAS!" <<endl;
          cerr << "No simulated event for Gt: " <<Gt<< endl;
          //return 1;     
          continue;
        }
        char buffer2[1024];
        while (reasFile.good()) {
          reasFile.getline(buffer2,1024);
          istringstream iss2 (buffer2);
          if(iss2.str().size()>0&&iss2.str()[0]!='%'&&iss2.str()[0]!='#') {	//in sim file:az in reas sistem
            iss2>>NantS>>distS>>azS>>NSfield>>EWfield>>VEfield>>dummy;
            cout<<"az sim : "<< azS << " az data LOPES : " << Az<<" ze LOPES "<<Ze<<endl;
            //calc distance
            showerCoord=sqrt(1.0 - pow(cos(azS-Az),2)*pow(sin(Ze),2));
            distanceS=0.01*distS*showerCoord;
            //distanceSerr=15.; 
            //calc field strength
            NSfield*=sim2lopesField;
            EWfield*=sim2lopesField;
            if(NSfield<0.1)
                NSfield=0.1;
            if(EWfield<0.1)
                EWfield=0.1;
            //TODO calc error

            //look if antenna exists at all in data then separe EW and NS
            if (m_recPulses.find(NantS) != m_recPulses.end()) { 
              if (m_recPulses[NantS].polarization == "EW") {
                cout<<"   xxxxxx   EW polarization   xxxxxx  "<<endl;
                //define recEW map
                m_recEW[NantS] = m_recPulses[NantS];
                cout<<"rec EW map size   :"<<m_recEW.size()<<endl;
                //define simEW map
                PulseProperties simPropEW;
                simPropEW.antennaID = NantS; //antennaid vs antenna no?
                simPropEW.height = EWfield;
                cout<<"EW Field  "<<EWfield<<endl;
                simPropEW.heightError = 0.;
                distanceR=m_recEW[NantS].dist;
                if ((distanceS-distanceR)>(distanceS*0.01)) {
                  cout<<"WARNING!"<<endl;
                  cout<<"distance simulated EW channel:  "<<distanceS<<" distance from LOPES  "<<distanceR<<endl;
                }
                simPropEW.dist =distanceR;
                simPropEW.disterr = distanceSerr;
                m_simEW[NantS] = simPropEW; //fill the sim map
              }
              if (m_recPulses[NantS].polarization == "NS") {
                cout<<"   kkkkkk   NS polarization   kkkkkk  "<<endl;
                //define recNS map
                m_recNS[NantS] = m_recPulses[NantS];
                cout<<"rec NS map size   :"<<m_recNS.size()<<endl;
                //define simEW map
                PulseProperties simPropNS;
                simPropNS.antennaID = NantS; //antennaid vs antenna no?
                simPropNS.height = NSfield;
                cout<<"NS Field  "<<NSfield<<endl;
                simPropNS.heightError = 0.;
                distanceR=m_recNS[NantS].dist;
                if ((distanceS-distanceR)>(distanceS*0.01)) {
                  cout<<"WARNING!"<<endl;
                  cout<<"distance simulated NS channel:  "<<distanceS<<" distance from LOPES  "<<distanceR<<endl;
                }
                simPropNS.dist =distanceR;
                simPropNS.disterr = distanceSerr;
          
                m_simNS[NantS] = simPropNS;//fill the sim map
              }
            }
          }
        } // while...
        reasFile.close();
      } 
      
      double Epsilon0=0.,R0=0.,err_Epsilon0=0.,err_R0=0.,chi2NDF=0.;
      double Epsilon0S=0.,R0S=0.,err_Epsilon0S=0.,err_R0S=0.,chi2NDFS=0.;
      CR::lateralDistribution lateralFitter;
      string plotPrefix = "";
      if(m_recEW.size()>=4) {        
        if (simDictName!="") 
          plotPrefix = "lateral-EW-"+m_dict[Gt]+"-";
        else 
          plotPrefix = "lateral-EW-";
        Record ergew = lateralFitter.fitLateralDistribution(plotPrefix,
                                                            m_recEW,m_simEW,
                                                            Gt,(Az*gradeg),(Ze*gradeg),
                                                            index1, index2);
        Epsilon0 = ergew.asDouble("eps");
        R0 = ergew.asDouble("R_0");
        err_Epsilon0 = ergew.asDouble("sigeps");
        err_R0 = ergew.asDouble("sigR_0");
        chi2NDF = ergew.asDouble("chi2NDF");
        Epsilon0S = ergew.asDouble("eps_sim");
        R0S = ergew.asDouble("R_0_sim");
        err_Epsilon0S = ergew.asDouble("sigeps_sim");
        err_R0S = ergew.asDouble("sigR_0_sim");
        chi2NDFS = ergew.asDouble("chi2NDF_sim");

        //write info of the fit into file
        outputEW << Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			
      }
      if(m_recNS.size()>=4) {
        if (simDictName!="") 
          plotPrefix = "lateral-NS-"+m_dict[Gt]+"-";
        else 
          plotPrefix = "lateral-NS-";
        Record ergns = lateralFitter.fitLateralDistribution(plotPrefix,
                                                            m_recNS,m_simNS,
                                                            Gt,(Az*gradeg),(Ze*gradeg),
                                                            index1, index2);
        Epsilon0 = ergns.asDouble("eps");
        R0 = ergns.asDouble("R_0");
        err_Epsilon0 = ergns.asDouble("sigeps");
        err_R0 = ergns.asDouble("sigR_0");
        chi2NDF = ergns.asDouble("chi2NDF");
        Epsilon0S = ergns.asDouble("eps_sim");
        R0S = ergns.asDouble("R_0_sim");
        err_Epsilon0S = ergns.asDouble("sigeps_sim");
        err_R0S = ergns.asDouble("sigR_0_sim");
        chi2NDFS = ergns.asDouble("chi2NDF_sim");

        outputNS << Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			
      }
    }//loop on the rec event 

    outputEW.close();
    outputNS.close();
  } catch (AipsError x) {
    cerr << "compareLOPES2sim: " << x.getMesg() << endl;
  }
  
  return 0;
}

