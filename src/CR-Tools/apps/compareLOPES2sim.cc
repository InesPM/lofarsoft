/*-------------------------------------------------------------------------*
 | $Id::                                                                 $ |
 *-------------------------------------------------------------------------*
 ***************************************************************************
 *   Copyright (C) 2010                                                    *
 *   Frank Schr√∂der , Nunzia Palmieri                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include<cstdlib>
#include<iostream>
#include<fstream>
#include<string>
#include<sstream>
#include<time.h>

#include<TFile.h>
#include<TTree.h>
#include<TMath.h>
#include<TCut.h>
#include <Rtypes.h>

#include <crtools.h>
#include <Analysis/lateralDistribution.h>
#include <Analysis/PulseProperties.h>

// using CR::analyseLOPESevent2;
// using CR::LopesEventIn;


/*!
  \file compareLOPES2sim.cc

  \ingroup CR_Applications

  \brief Compares lateral distribution of LOPES events to REAS simulation

  \author Frank Schr&ouml;der

  \date 2008/20/05

  <h3>Motivation</h3>

 
  <h3>Usage</h3>

  \verbatim
  ./compareLOPES2sim results.root  dictionary.txt  ../reas3simulations/lopeseventsR3i/
  \endverbatim

  <ul>
    Optional argumens:
    <li> --help                           prints a help message
  </ul>

  <h3>Prerequisites</h3>

  ROOT
  
  <h3>Examples</h3>

  \verbatim
  ./compareLOPES2sim --help
  \endverbatim
*/




int main (int argc, char *argv[])
{
     try {
         //cout << "\nStarting compareLOPES2sim.\n" << endl;

     if(argc!=4&&argc!=3) {
         cout << "\n Application to generate lateral distribution plots for both LOPES data and simulations, based on the ROOT file generated by call_pipeline and REAS3 simulations.\n"
         << " Syntax: ./genREASinputList results.root dictionary.txt ../directoryWithSim/ [\"optional selection string\"] "
         << endl;
         cout<<"Wrong number of arguments!"<<endl;
         return 1;
    } else {
        cout << "\nStarting compareLOPES2sim.\n" << endl;
     }

     // check arguments
     for (int i=1; i < argc; ++i) {
     // get option and argument
          string option(argv[i]);
          i++;
          // look for keywords which require no argument
          if ( (option == "--help") || (option == "-help")
               || (option == "--h") || (option == "-h")) {
	        cout << "Use: ./compareLOPES2sim --help"
	             << endl;
	        return 0;       // exit here
	      }
	}

     // map dic declaration
     map<int,string> m_dict;
     /*dictionary file*/
     int GtDict=0;
     string simNameDict;
     double dummy;
     ifstream dictFile(argv[2]);
     if (!dictFile.is_open())
     {
          cout << "ERROR ----- CAN NOT OPEN THE DICTIONARY FILE!" << endl;
     }
     char buffer[512];
     while (1) 
     {
          dictFile.getline(buffer,512);
          istringstream iss (buffer);
          if(iss.str().size()>0&&iss.str()[0]!='%'&&iss.str()[0]!='#')
          {
               iss>>GtDict>>simNameDict>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy>>dummy;

               m_dict[GtDict]=simNameDict; //fill the map dictionary 
          }
          if (!dictFile.good())
          break;
     } // while...
	dictFile.close();


     /*root file from call_pipeline*/
     UInt_t Gt;
     Float_t Az,Ze;
     int entries;
     int totAntenna = 30;


     TFile *recRoot = new TFile (argv[1], "READ");
     //if(!recRoot || recRoot->IsZombie()) return;
     //recRoot->ls();
     TTree *recTree =  (TTree*)recRoot->Get("T;1");
     //if(!recTree) return;
 
     //PulseProperties[totAntenna] antPulses; //each antenna 1 pulseProperties
     PulseProperties* antPulses[totAntenna];

     recTree->SetBranchAddress("Gt", &Gt);
     recTree->SetBranchAddress("Az", &Az);
     recTree->SetBranchAddress("Ze", &Ze);
// use getListOfBranches to check if branch for antenna exists
    for (int i=0; i < totAntenna; ++i) {
      antPulses[i] = new PulseProperties();
    }

     for(int i=0; i< totAntenna; ++i) {
          stringstream antNumber("");
          antNumber << (i+1);
          string antBranchName;
          antBranchName = "Ant_" + antNumber.str() + "_cal.";
// if  can find antBranchName in list
          recTree->SetBranchAddress(antBranchName.c_str(), &antPulses[i]);
     }

     entries = recTree->GetEntries();
	
     /* output files*/
     ofstream outputEW("simANDrec_fitvalue_EW.dat");
     ofstream outputNS("simANDrec_fitvalue_EW.dat");
     outputEW<<"# eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;
     outputNS<<"# eps0 , sigeps0,  R0 ,  sigR0 , chi2 , eps0_sim , sigeps0_sim , R0_sim , sigR0_sim , chi2_sim"<<endl;

     for(int i=0; i<entries; i++) //lop on the events
     {
          recTree->GetEntry(i);

          map<int,PulseProperties> m_recPulses;
          map<int,PulseProperties> m_recEW;
          map<int,PulseProperties> m_recNS;
          map<int,PulseProperties> m_simEW;
          map<int,PulseProperties> m_simNS;

          //int NantR[totAntenna]=antPulses[totAntenna].antennaID; 

          //fill the first rec map
          for(int j=0; j<totAntenna; j++) {
               m_recPulses[antPulses[j]->antennaID] = *antPulses[j]; //I fill the rec map with pulse properties in the root file

			//m_recPulses[NantR[j]] = antPulses[j]; //I fill the rec map with pulse properties in the root file

          }
	

          /*sim file*/
          int NantS=0;
          double EWfield=0.,NSfield=0.,VEfield=0.;
          double distS=0.,azS=0.;
          double sim2lopesField=(2.9979246e+10/31.); //muV/m into muV/m/MHz
          double gradeg=180./(TMath::Pi());
          double distanceS=0., distanceSerr=0.,showerCoord=0.;

          string reasFileName = argv[3]+m_dict[Gt]+ "_lopes_rect43to76/maxamp_summary.dat"; //path correct??
          ifstream reasFile(reasFileName.c_str());
          if (!reasFile.is_open())
          {
               cout << "ERROR ----- CAN NOT OPEN THE FILE for REAS!" << endl;
          }
          char buffer2[512];
          while (1) 
          {
               reasFile.getline(buffer2,512);
               istringstream iss2 (buffer2);
               if(iss2.str().size()>0&&iss2.str()[0]!='%'&&iss2.str()[0]!='#')
               {	//in sim file:az in reas sistem
                    iss2>>NantS>>distS>>azS>>NSfield>>EWfield>>VEfield>>dummy;

                    //calc distance
                    showerCoord=sqrt(1.0 - pow(cos(azS-Az),2)*pow(sin(Ze),2));
                    distanceS=0.01*distS*showerCoord;
                    //distanceSerr=15.; //????????
                    //calc field strength
                    NSfield*=sim2lopesField;
                    EWfield*=sim2lopesField;
                    if(NSfield<0.1)
                     NSfield=0.1;
                    if(EWfield<0.1)
                     EWfield=0.1;
				//calc error
				///to be done!


                    //look if antenna exists at all in data then separe EW and NS
                    if (m_recPulses.find(NantS) != m_recPulses.end()) { ///check thet it works!!!!!
                         if (m_recPulses[NantS].polarization == "EW") {
                              //define recEW map
                              m_recEW[NantS] = m_recPulses[NantS];
                              //define simEW map
                              PulseProperties simPropEW;
                              simPropEW.antennaID = NantS; //antennaid vs antenna no?
                              simPropEW.height = EWfield;
                              simPropEW.heightError = 1.;
                              double distanceR=m_recEW[NantS].dist;
                              if ((distanceS-distanceR)>(distanceS*0.01)){
                                   cout<<"WARNING!"<<endl;
                                   cout<<"distance simulated:  "<<distanceS<<"distance from LOPES  "<<distanceR<<endl;
                              }
                              simPropEW.dist =distanceR;
                              //simPropEW.disterr = distanceSerr;
                              m_simEW[NantS] = simPropEW; //fill the sim map
                           }
                         if (m_recPulses[NantS].polarization == "NS") {
                              //define recNS map
                              m_recNS[NantS] = m_recPulses[NantS];
                              //define simEW map
                              PulseProperties simPropNS;
                              simPropNS.antennaID = NantS; //antennaid vs antenna no?
                              simPropNS.height = NSfield;
                              //simPropNS.heightError = ???;
                              double distanceR=m_recEW[NantS].dist;
                              simPropNS.dist =distanceR;
                              //simPropNS.disterr = distanceSerr;
			
                              m_simNS[NantS] = simPropNS;//fill the sim map
                         }
                    }
               }
               if (!reasFile.good())
               break;
          } // while...
          reasFile.close();
	
          double Epsilon0=0.,R0=0.,err_Epsilon0=0.,err_R0=0.,chi2NDF=0.;
          double Epsilon0S=0.,R0S=0.,err_Epsilon0S=0.,err_R0S=0.,chi2NDFS=0.;
          CR::lateralDistribution lateralFitter;
          if(m_recEW.size()>=4){

               Record ergew = lateralFitter.fitBothLateralDistribution("lateral"+m_dict[Gt]+"-",m_recEW,m_simEW,Gt,(Az*gradeg),(Ze*gradeg));

               Epsilon0 = ergew.asDouble("eps");
               R0 = ergew.asDouble("R_0");
               err_Epsilon0 = ergew.asDouble("sigeps");
               err_R0 = ergew.asDouble("sigR_0");
               chi2NDF = ergew.asDouble("chi2NDF");
               Epsilon0S = ergew.asDouble("eps_sim");
               R0S = ergew.asDouble("R_0sim");
               err_Epsilon0S = ergew.asDouble("sigeps_sim");
               err_R0S = ergew.asDouble("sigR_0sim");
               chi2NDFS = ergew.asDouble("chi2NDF_sim");

               //write info of the fit into file
               outputEW << Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			
          }
          if(m_recNS.size()>=4){
               Record ergns = lateralFitter.fitBothLateralDistribution("lateral"+m_dict[Gt]+"-",m_recNS,m_simNS,Gt,(Az*gradeg),(Ze*gradeg));

               Epsilon0 = ergns.asDouble("eps");
               R0 = ergns.asDouble("R_0");
               err_Epsilon0 = ergns.asDouble("sigeps");
               err_R0 = ergns.asDouble("sigR_0");
               chi2NDF = ergns.asDouble("chi2NDF");
               Epsilon0S = ergns.asDouble("eps_sim");
               R0S = ergns.asDouble("R_0sim");
               err_Epsilon0S = ergns.asDouble("sigeps_sim");
               err_R0S = ergns.asDouble("sigR_0sim");
               chi2NDFS = ergns.asDouble("chi2NDF_sim");

               outputNS << Epsilon0<<"\t"<<err_Epsilon0<<"\t"<<R0<<"\t"<<err_R0<<"\t"<<chi2NDF<<"\t"<<Epsilon0S<<"\t"<<err_Epsilon0S<<"\t"<<R0S<<"\t"<<err_R0S<<"\t"<<chi2NDF<<"\t"<<chi2NDFS<<endl;			

          }

     }//loop on the rec event 

     outputEW.close();
     outputNS.close();

  } catch (AipsError x) {
    cerr << "compareLOPES2sim: " << x.getMesg() << endl;
  }
  
  return 0;
}

