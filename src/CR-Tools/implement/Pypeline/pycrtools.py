# Import module
from math import *
from hftools import *
from pydoc import help as pyhelp
import os,sys
LOFARSOFT=os.environ["LOFARSOFT"]

pydocpyfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.py"
pydoctxtfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.tex"

#Read in the doc strings for the functions in hftools
execfile(pydocpyfilename)
f=open(pydoctxtfilename);pycralldocstring=f.read();f.close()

#======================================================================
#  Help Functions
#======================================================================

def all():
    pass

all.__doc__=pycralldocstring

def hhelpstring(func):
    """
    Returns the doc string of a function. Check if the docstring
    contains informations from the CRTOOLS. If so, return only that
    part.
    """
    if func.__doc__==None: return ""
    iscr=func.__doc__.find("\nPYCRTOOLS ")
    if iscr>=0: doc=func.__doc__[iscr+1:]
    else: doc=func.__doc__
    return doc

#    Included to overwrite the pydoc help function.
def help():
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    help(help)


def help(func=help,brief=True):
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help). 

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    if func==None: func=help
    if (hasattr(func,"__class__")): print "Class: ", func.__class__
    if brief: print hhelpstring(func)
    else: print pyhelp(func)
    methods=dir(func)
    methods2=[]
    for m in methods:
        if not ((m.find("_")==0) | (m.find("func_")==0)): methods2.append(m)
    if len(methods2)>0:
        print "\nAvailable methods: ",
        for m in methods2[0:-1]:
            print m+", ",
        print methods2[-1]
        if (hasattr(func,"__name__")):
            print "\nType help("+func.__name__+".METHOD) to get more info on the individual methods."
        else:
            print "\nType help(func.METHOD) to get more info on the individual methods."
                        

#======================================================================
#  Pretty Printing
#======================================================================

#Some definitons to make pretty (and short) output of vectors
def VecToString(self,maxlen=10):
    veclen=len(self)
    stringval=""
    if veclen>0:
        stringval+=str(self[0])
    for i in range(1,min(len(self),maxlen)):
        stringval+=","+str(self[i])
    if veclen>maxlen:
        stringval+=",..."
    return stringval


def VecToPrintString(self,maxlen=10):
    return "Vec("+str(len(self))+")=[" +VecToString(self)+"]"

def MatrixToPrintString(self,maxlen=10):
    return "Matrix("+str(len(self))+")=[" +VecToString(self)+"]"

setattr(IntMatrix,"__repr__",MatrixToPrintString)

#========================================================================
# Adding multi-dimensional array capabilities to vector class
#========================================================================

def multiply_list(l):
    """
    multiply_list([n1,n2,...]) -> n1*n2*n3 ....

    Multiplies all elements of a list with each other and returns the
    result.
    """
    return reduce(lambda x,y:x*y,l)

def hArray_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) 
    
    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list. 
    """
    newsize=multiply_list(dimensions_list) # dim1*dim2*...*dimN
    if (not len(self)==newsize): self.resize(newsize)
    self.dimension=dimensions_list
    self.ndim=len(dimensions_list)
    return self

def hArray_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    if self.ndim>0: return self.dimension
    else: return len(self)

def hArray_elem(self,n):
    """
    self.elem(n) -> nth element of the first dimension of the array

    """
    if self.ndim>1: # this actually is a multi-dim array
        if type(n)==int: #select just one element
            size=multiply_list(self.dimension[1:])
            return self[n*size:(n+1)*size]
        else:
            print "elem: index unknown ..."
            return self
    else:
        return self[n]

        
        

def extendflat(self,l):
    """
    vector.extendflat([[e1-1,e1-2,...],[e2-1,e2-2,...],..]) -> [e1-1,e1-2,...,e2-1,e2-2,...]

    Appendinh all elements in a list of lists to a one-dimensional
    vector with a flat dat structure (just 1D).
    """
    map(lambda x:self.extend(x),l)


#======================================================================
#  Vector Methods/Attributes
#======================================================================

"""
Here we add the functions defined in the hftools.cc as
methods/attributes to the (STL) vector classes in python.
"""

Vectordoc= """
A number of vector types are provided: bool, int, float, complex, and
str.

This vector is subscriptable and sliceable, using the
standard python syntax, e.g. v[1:3], or v[2]=0.

To creat a vector most efficently, use the original vector
constructors: BoolVec() - IntVec() - FloatVec() - ComplexVec() -
StringVec()

There is also a more convenient constructor function "Vector" that is
useful for interactive use: 

Vector(Type) , where Type=float,int,complex,str, or bool
Vector(Type,size)
Vector(Type,size,fill) 
Vector(list), Vector(tuple)
Vector() defaults to a float vector

Use the resize method to allocate more or less memory.

Some of the basic arithmetic is available in an intuitve way, e.g.,
vec+1, vec1+vec2, vec+=vec2).

See the tutorial (tutorial.py) for more details.
"""

IntVec.__doc__="c++ standard template library (STL) vector of type 'int'\n"+Vectordoc 
FloatVec.__doc__="c++ standard template library (STL) vector of type 'float'\n"+Vectordoc 
StringVec.__doc__="c++ standard template library (STL) vector of type 'str'\n"+Vectordoc 
BoolVec.__doc__="c++ standard template library (STL) vector of type 'bool'\n"+Vectordoc 
ComplexVec.__doc__="c++ standard template library (STL) vector of type 'complex'\n"+Vectordoc 

IntVec.__name__="IntVec"
FloatVec.__name__="FloatVec"
BoolVec.__name__="BoolVec"
ComplexVec.__name__="ComplexVec"
StringVec.__name__="StringVec"

hRealVectorTypes=[IntVec,FloatVec]
hNumericalVectorTypes=hRealVectorTypes+[ComplexVec]
hOtherVectorTypes=[BoolVec,StringVec]
hAllVectorTypes=hOtherVectorTypes+hNumericalVectorTypes
hAllListTypes=hAllVectorTypes+[list,tuple]

#Operator Overloading - basic arithmetic 

# Operator:  +=
def Vec_iadd(vec1,vec2):
    """
    Provides the += operator for adding two vectors in place.
    vec1+=vec2 will add all elements in vec2 to the corresponding
    elements in vec1 and store the result in vec1.
    """
    hiAdd(vec1,vec2)
    return vec1

# Operator:  -=
def Vec_isub(vec1,vec2):
    "Provides the -= operator for addig two vectors in place. \
    vec1-=vec2 will subtract all elements in vec2 from the corresponding elements in vec1\
    and store the result in vec1."
    hiSub(vec1,vec2)
    return vec1

# Operator:  /=
def Vec_idiv(vec1,vec2):
    "Provides the /= operator for addig two vectors in place. \
    vec1/=vec2 will divide all elements in vec1 by the corresponding elements in vec2\
    and store the result in vec1."
    hiDiv(vec1,vec2)
    return vec1

# Operator:  *=
def Vec_imul(vec1,vec2):
    "Provides the *= operator for addig two vectors in place. \
    vec1=vec2 will multiply all elements in vec1 with the corresponding elements in vec2\
    and store the result in vec1."
    hiMul(vec1,vec2)
    return vec1

# Operator:  +
def Vec_add(vec1,val):
    "Provides the + operator for adding two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hAdd(vec1,val,vecout)
    return vecout

# Operator:  -
def Vec_sub(vec1,val):
    "Provides the - operator for subtracting two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hSub(vec1,val,vecout)
    return vecout

# Operator:  *
def Vec_mul(vec1,val):
    "Provides the * operator for multiplying two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hMul(vec1,val,vecout)
    return vecout

# Operator:  /
def Vec_div(vec1,val):
    "Provides the / operator for dividing two vectors or a vector by a scalar. The result will be a new vector."
    vecout=vec1.new()
    hDiv(vec1,val,vecout)
    return vecout


#Fourier Transforms 
setattr(FloatVec,"fft",hFFT)


for v in hAllVectorTypes:
    setattr(v,"__repr__",VecToPrintString)
    setattr(v,"extendflat",extendflat)
    setattr(v,"setDim",hArray_setDim)
    setattr(v,"getDim",hArray_getDim)
    setattr(v,"elem",hArray_elem)
    setattr(v,"dimension",[])
    setattr(v,"ndim",0)
    for s in ["hResize","hFill","hNew","hCopy","hSort"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hRealVectorTypes:
    for s in ["hMean","hStdDev","hDownsample","hNorm","hNormalize","hAcos","hAsin","hAtan","hCeil","hFloor","hFindGreaterThan","hFindGreaterEqual","hFindGreaterThanAbs","hFindGreaterEqualAbs","hFindLessThan","hFindLessEqual","hFindLessThanAbs","hFindLessEqualAbs"]:
        setattr(v,s[1:].lower(),eval(s))


for s in ["hSpectralPower","hArg","hImag","hNorm","hReal","hConj","hCrossCorrelateComplex"]:
    setattr(ComplexVec,s[1:].lower(),eval(s))

for v in hNumericalVectorTypes:
    setattr(v,"__add__",Vec_add)
    setattr(v,"__sub__",Vec_sub)
    setattr(v,"__div__",Vec_div)
    setattr(v,"__mul__",Vec_mul)
    setattr(v,"__iadd__",Vec_iadd)
    setattr(v,"__imul__",Vec_imul)
    setattr(v,"__idiv__",Vec_idiv)
    setattr(v,"__isub__",Vec_isub)
    for s in ["hAbs","hConvert","hMul","hDiv","hSub","hAdd","hMulAdd","hDivAdd","hSubAdd","hAddAdd","hMulAddConv","hDivAddConv","hSubAddConv","hAddAddConv","hiMul","hiDiv","hiSub","hiAdd","hCos","hCosh","hExp","hLog","hLog10","hSin","hSinh","hSqrt","hSquare","hTan","hTanh","hSum","hSortMedian","hMedian","hFindLowerBound"]:
        setattr(v,s[1:].lower(),eval(s))


#========================================================================
# Convenience Vector Constructor
#========================================================================

def Vector(Type=float,size=-1,fill=None):
    """
    The basic Boost Python STL vector constructor takes no arguments and
    hence is a litte cumbersome to use. Here we provide a wrapper function
    that is useful for interactive use. If speed is of the essence, use
    the original vector constructors: BoolVec(), IntVec(), FloatVec(),
    ComplexVec(), StringVec()
    
    Usage:

    Vector(Type) -  will create an empty vector of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Vector(Type,size) - will create an vector of type "Type", with length "size".

    Vector(Type,size,fill) - will create an vector of type "Type", with length
    "size" and initialized with the value "fill"

    Vector([1,2,3,...]) or Vector((1,2,3,...)) - if a list or a tuple is
    provided as first argument then a vector is created of the type of the
    first element in the list or tuple (here an integer) and filled with
    the contents of the list or tuple.

    Vector() defaults to a float vector.

    Note, that size and fill take precedence over the list and tuple
    input. Hence if you create a vector with Vector([1,2,3],size=2) it
    will contain only [1,2]. Vector([1,2,3],size=2,fill=4) will give
    [4,4].
    """
    if (Type==float): vec=FloatVec()
    if (Type==int): vec=IntVec()
    if (Type==complex): vec=ComplexVec()
    if (Type==str): vec=StringVec()
    if (Type==bool): vec=BoolVec()
    if (type(Type) in hAllListTypes): vec=Vector(type(Type[0])); vec.extend(Type)
    if (size>=0): vec.resize(size)
    if (not fill==None): vec.fill(fill)
    return vec

#------------------------------------------------------------------------
# cr DataReader Class
#------------------------------------------------------------------------

def crfile(filename):
    """
    file=crfile("FILENAME.h5") -> DataReader Object

    This is a simple class to interface with the LOFAR CRTOOLS
    datareader class. It deals with LOFAR and LOEPS data alike. You
    can read data vectors, read or set parameters and get summary of the contents.
    """
    file=hFileOpen(filename)
    file.filename=filename
    return file

DataReader.read=hFileRead
DataReader.__doc__=crfile.__doc__

#------------------------------------------------------------------------
# Pypeline Extension, Functions and Algorithms
#------------------------------------------------------------------------

def CheckParameterConformance(data,limits):
    """
    CheckParameterConformance([12,-10],[("mean",(-15,15)),("rms",(10,40))])  ->  ["rms"]
    
    Checks whether a list of numbers is within a range of limits
    specified beforehand. The limits are provided as a list of tuples,
    of the form ("FIELDNAME",(LOWERLIMT,UPPERLIMIT)). A list of
    fieldnames is returned where the data does not fall within the
    specified range.

    """
    result=[]
    for i in range(len(data)):
        if (data[i]<limits[i][1][0]) | (data[i]>limits[i][1][1]): result.append(limits[i][0])
    return result


def CRQualityCheck(file,limits,maxblocksize=65536,nsigma=5):
    """
    CRQualityCheck(file,[("mean",(-15,15)),("rms",(5,15)),("nonGaussianity",(-1,3))]) 

    Will step through all antennas of a file assess the data quality. For each 

    """
#Initialize some parameters
    nAntennas=file.get("nofAntennas")
    filesize=file.get("Filesize")
    blocksize=min(filesize/4,maxblocksize)
    file.set("Blocksize",blocksize)
    nBlocks=filesize/blocksize; 
    blocklist=range(nBlocks/4)+range(3*nBlocks/4,nBlocks)
#Create the some scratch vectors
    qualityflaglist=[]
    where=Vector(int,blocksize)
    rawdata=Vector(float)
    rawdata.setDim([nAntennas,blocksize])
#Calculate probabilities to find certain peaks
    probability=funcGaussian(nsigma,1,0) # what is the probability of a 5 sigma peak
    npeaksexpected=probability*blocksize # what is the probability to see such a peak with the blocksize
    npeakserror=sqrt(npeaksexpected) # what is the statisitcal error on that expectation
#Start checking
    print "Quality checking of file ",file.filename
    print "Considering",nAntennas," antennas and the Blocks:",blocklist
    print "Blocksize=",blocksize,", nsigma=",nsigma, ", number of peaks expected per block=",npeaksexpected
    for Block in blocklist:
        file.set("Block",Block).read("Voltage",rawdata)
        for Antenna in range(nAntennas):
            print "Antenna={0:2d},".format(Antenna),"Block={0:3d}:".format(Block),
            datamean = rawdata.mean(Antenna*blocksize,(Antenna+1)*blocksize)
            datarms = rawdata.elem(Antenna).stddev(datamean)
            datanpeaks=rawdata.elem(Antenna).findgreaterthanabs(int(round(nsigma*datarms)),where)
            dataNonGaussianity=(datanpeaks-npeaksexpected)/npeakserror
            print "mean={0:4.2f},".format(datamean),"rms={0:5.1f},".format(datarms),"npeaks={0:5d},".format(datanpeaks),"nonGaussianity={0:5.2f}".format(dataNonGaussianity),
            noncompliancelist=CheckParameterConformance([datamean,datarms,dataNonGaussianity],limits)
            if noncompliancelist:
                qualityflaglist.append((Antenna,Block,noncompliancelist))
                print noncompliancelist,"!!"
            else: print ""
    return qualityflaglist

