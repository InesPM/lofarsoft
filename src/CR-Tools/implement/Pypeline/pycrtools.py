# Import module
from math import *
from hftools import *
from pydoc import help as pyhelp
import os,sys,re
LOFARSOFT=os.environ["LOFARSOFT"]

pydocpyfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.py"
pydoctxtfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.tex"

#Read in the doc strings for the functions in hftools
execfile(pydocpyfilename)
f=open(pydoctxtfilename);pycralldocstring=f.read();f.close()

#======================================================================
#  Help Functions
#======================================================================

def all():
    pass

all.__doc__=pycralldocstring

def hhelpstring(func):
    """
    Returns the doc string of a function. Check if the docstring
    contains informations from the CRTOOLS. If so, return only that
    part.
    """
    doc=func.__doc__
    if doc==None: return ""
    match=re.search("^PYCRTOOLS .*",doc,re.MULTILINE)
    if (match):
        predoc=doc[match.start():match.end()]
        doc=re.sub("PYCRTOOLS .*","",doc[match.end():])
        doc = predoc + doc;
    return doc

#    Included to overwrite the pydoc help function.
def help():
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    help(help)


def help(func=help,brief=True):
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help). 

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    if func==None: func=help
    if (hasattr(func,"__class__")): print "Class: ", func.__class__
    if brief: print hhelpstring(func)
    else: print pyhelp(func)
    methods=dir(func)
    methods2=[]
    for m in methods:
        if not ((m.find("_")==0) | (m.find("func_")==0)): methods2.append(m)
    if len(methods2)>0:
        print "\nAvailable methods: ",
        for m in methods2[0:-1]:
            print m+", ",
        print methods2[-1]
        if (hasattr(func,"__name__")):
            print "\nType help("+func.__name__+".METHOD) to get more info on the individual methods."
        else:
            print "\nType help(func.METHOD) to get more info on the individual methods."
                        

#======================================================================
#  Pretty Printing
#======================================================================

#Some definitons to make pretty (and short) output of vectors
def VecToString(self,maxlen=10):
    veclen=len(self)
    stringval=""
    if veclen>0:
        stringval+=str(self[0])
    for i in range(1,min(len(self),maxlen)):
        stringval+=","+str(self[i])
    if veclen>maxlen:
        stringval+=",..."
    return stringval


def VecToPrintString(self,maxlen=10):
    s=typename(basetype(self))+","
    return "Vec("+s+str(len(self))+")=[" +VecToString(self,maxlen)+"]"

def ArrayToPrintString(self,maxlen=10):
    s=typename(basetype(self))+", "
    return "Array("+s+str(self.getDim())+"="+str(len(self))+", ["+str(self.getBegin())+":"+str(self.getEnd())+"]) -> [" +VecToString(self.getVector()[self.getBegin():self.getEnd()],maxlen)+"]"

#========================================================================
# Adding multi-dimensional array capabilities to vector class
#========================================================================

def multiply_list(l):
    """
    multiply_list([n1,n2,...]) -> n1*n2*n3 ....

    Multiplies all elements of a list with each other and returns the
    result.
    """
    return reduce(lambda x,y:x*y,l)

def hVector_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) 
    
    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list. 
    """
    newsize=multiply_list(dimensions_list) # dim1*dim2*...*dimN
    if (not len(self)==newsize): self.resize(newsize)
    self.dimension=dimensions_list
    self.ndim=len(dimensions_list)
    return self

def hVector_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    if self.ndim>0: return self.dimension
    else: return len(self)

def hVector_elem(self,n):
    """
    self.elem(n) -> nth element of the first dimension of the array

    """
    if self.ndim>1: # this actually is a multi-dim array
        if type(n)==int: #select just one element
            size=multiply_list(self.dimension[1:])
            return self[n*size:(n+1)*size]
        else:
            print "elem: index unknown ..."
            return self
    else:
        return self[n]


def extendflat(self,l):
    """
    vector.extendflat([[e1-1,e1-2,...],[e2-1,e2-2,...],..]) -> [e1-1,e1-2,...,e2-1,e2-2,...]

    Appending all elements in a list of lists to a one-dimensional
    vector with a flat dat structure (just 1D).
    """
    map(lambda x:self.extend(x),l)


def hArray_newreference(self):
    """
    array.newreference() -> copy of array referencing the same vector

    Will make an exact copy of the array, and reference the same
    vector. Hence the new array can be assigned a new slice, but will
    still access the same underlying vector in memory.
    """
    return self.shared_copy()

def hArray_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) -> Array with new dimensions
     
    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list. 
    """
    apply(self.setDimensions,dimensions_list)
    return self;

def hArray_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    return list(self.getDimensions())

def hArray_return_slice_start(val): 
    """ Reduces a slice to its start value"""
    if val==Ellipsis: 
        return 0
    elif type(val)==slice:
        return val.start
    else:
        return val


def hArray_getitem(self,dimlist):
    """
    self[]
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    
    if not type(dimlist) in [list,tuple]: 
        print "NOT:",dimlist
        dimlist=[dimlist]
    sizes=self.getSizes()
    ary=Array(self)
    if dimlist[-1]==Ellipsis: ary.loop()
    dimliststarts=Vector(map(hArray_return_slice_start,dimlist))
    start=dimliststarts.mulsum(sizes)
    if type(dimlist[-1])==slice:
        end=start+(dimlist[-1].stop-dimlist[-1].start+1)*sizes[len(dimlist)-1]
    else:
        end=start+sizes[len(dimlist)-1]
    ary.setSlice(start,end)
    return ary;

def hArray_setitem(self,dims):
    """
    self[]
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    return (dims)

 
#======================================================================
#  Define Lists of Array and Vector Types that we will use 
#======================================================================

hBaseTypes=[int,float,complex,bool,str]
hBaseNames=["Int","Float","Complex","Bool","String"]
hBaseNamesPy=["int","float","complex","bool","str"]

hRealTypes=[int,float]
hComplexTypes=[complex]
hNumericalTypes=hRealTypes+hComplexTypes
hOtherTypes=[bool,str]

#------------------------------------------------------------

hVectorBaseTypeDictionary={}
hArrayBaseTypeDictionary={}
hArrayTypeDictionary={}
hVectorTypeDictionary={}
hTypeDictionary={}
hTypeNamesDictionary={}
hAllVectorTypes=[]
hAllArrayTypes=[]
for i in range(len(hBaseTypes)):
    btype=hBaseTypes[i]
    vtype=eval(hBaseNames[i]+"Vec")
    atype=eval(hBaseNames[i]+"Array")
    hAllVectorTypes.append(vtype)
    hAllArrayTypes.append(atype)
    hVectorBaseTypeDictionary[vtype]=btype
    hArrayBaseTypeDictionary[atype]=btype
    hVectorTypeDictionary[btype]=vtype
    hArrayTypeDictionary[btype]=atype
    hTypeDictionary[btype]=btype
    hTypeNamesDictionary[btype]=hBaseNamesPy[i]

hAllListTypes=hAllVectorTypes+[list,tuple]


basetypedictionary=dict(zip(hVectorBaseTypeDictionary.keys()+hArrayBaseTypeDictionary.keys()+hTypeDictionary.keys(),hVectorBaseTypeDictionary.values()+hArrayBaseTypeDictionary.values()+hTypeDictionary.values()))

def type2vector(basetype):
    """type2vector(float) -> Vec(0)=[]

    Creates a vector with elements of type 'basetype'. Returns None if
    a vector of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hVectorTypeDictionary[basetype]()
    else: return None

def type2array(basetype):
    """type2array(float) -> Vec(0)=[]

    Creates an array with elements of type 'basetype'. Returns None if
    an array of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hArrayTypeDictionary[basetype]()
    else: return None

def basetype(vec_or_array): 
    """
    basetype(IntVec) -> <type 'int'>
    basetype(FloatArray) -> <type 'float'>
    basetype(complex) -> <type 'complex'>
    
    Returns the basic type contained in the vector or array. Input can be either a vector, an array, or a type thereof.
    """
    t=type(vec_or_array)
    if t==type: t=vec_or_array
    return basetypedictionary[t]

def typename(btype): 
    """
    basetype(float) -> "float"    
    basetype(str) -> "str"
    
    Returns the name of the base type as a short string.
    """
    t=type(btype)
    if t==type: t=btype
    return hTypeNamesDictionary[t]


def isArray(ary): 
    """
    isArray(array) -> True or False

    Returns true if the argument is one of the hArray arrays, i.e. those listed in hAllVectorTypes.
    """
    return type(ary) in hAllArrayTypes

def isVector(vec): 
    """
    isVector(vec) -> True or False

    Returns true if the argument is one of the standard c++ vectors i.e. those liste in hAllVectorTypes.
    """
    return type(vec) in hAllVectorTypes

hRealVectorTypes=map(lambda t:hVectorTypeDictionary[t],hRealTypes)
hComplexVectorTypes=map(lambda t:hVectorTypeDictionary[t],hComplexTypes)
hNumericalVectorTypes=map(lambda t:hVectorTypeDictionary[t],hNumericalTypes)
hOtherVectorTypes=map(lambda t:hVectorTypeDictionary[t],hOtherTypes)

hRealArrayTypes=map(lambda t:hArrayTypeDictionary[t],hRealTypes)
hComplexArrayTypes=map(lambda t:hArrayTypeDictionary[t],hComplexTypes)
hNumericalArrayTypes=map(lambda t:hArrayTypeDictionary[t],hNumericalTypes)
hOtherArrayTypes=map(lambda t:hArrayTypeDictionary[t],hOtherTypes)

hRealContainerTypes=hRealVectorTypes+hRealArrayTypes
hComplexContainerTypes=hComplexVectorTypes+hComplexArrayTypes
hNumericalContainerTypes=hNumericalVectorTypes+hNumericalArrayTypes
hOtherContainerTypes=hOtherVectorTypes+hOtherArrayTypes
hAllContainerTypes=hAllVectorTypes+hAllArrayTypes

#======================================================================
#  Vector Methods/Attributes
#======================================================================

"""
Here we add the functions defined in the hftools.cc as
methods/attributes to the (STL) vector classes in python.
"""

Vectordoc= """
A number of vector types are provided: bool, int, float, complex, and
str.

This vector is subscriptable and sliceable, using the
standard python syntax, e.g. v[1:3], or v[2]=0.

To creat a vector most efficently, use the original vector
constructors: BoolVec() - IntVec() - FloatVec() - ComplexVec() -
StringVec()

There is also a more convenient constructor function "Vector" that is
useful for interactive use: 

Vector(Type) , where Type=float,int,complex,str, or bool
Vector(Type,size)
Vector(Type,size,fill) 
Vector(list), Vector(tuple)
Vector() defaults to a float vector

Use the resize method to allocate more or less memory.

Some of the basic arithmetic is available in an intuitve way, e.g.,
vec+1, vec1+vec2, vec+=vec2).

See the tutorial (tutorial.py) for more details.
"""

IntVec.__doc__="c++ standard template library (STL) vector of type 'int'\n"+Vectordoc 
FloatVec.__doc__="c++ standard template library (STL) vector of type 'float'\n"+Vectordoc 
StringVec.__doc__="c++ standard template library (STL) vector of type 'str'\n"+Vectordoc 
BoolVec.__doc__="c++ standard template library (STL) vector of type 'bool'\n"+Vectordoc 
ComplexVec.__doc__="c++ standard template library (STL) vector of type 'complex'\n"+Vectordoc 

IntVec.__name__="IntVec"
FloatVec.__name__="FloatVec"
BoolVec.__name__="BoolVec"
ComplexVec.__name__="ComplexVec"
StringVec.__name__="StringVec"

#Operator Overloading - basic arithmetic 

# Operator:  +=
def Vec_iadd(vec1,vec2):
    """
    Provides the += operator for adding two vectors in place.
    vec1+=vec2 will add all elements in vec2 to the corresponding
    elements in vec1 and store the result in vec1.
    """
    hAdd(vec1,vec2)
    return vec1

# Operator:  -=
def Vec_isub(vec1,vec2):
    "Provides the -= operator for addig two vectors in place. \
    vec1-=vec2 will subtract all elements in vec2 from the corresponding elements in vec1\
    and store the result in vec1."
    hSub(vec1,vec2)
    return vec1

# Operator:  /=
def Vec_idiv(vec1,vec2):
    "Provides the /= operator for addig two vectors in place. \
    vec1/=vec2 will divide all elements in vec1 by the corresponding elements in vec2\
    and store the result in vec1."
    hDiv(vec1,vec2)
    return vec1

# Operator:  *=
def Vec_imul(vec1,vec2):
    "Provides the *= operator for addig two vectors in place. \
    vec1=vec2 will multiply all elements in vec1 with the corresponding elements in vec2\
    and store the result in vec1."
    hMul(vec1,vec2)
    return vec1

# Operator:  +
def Vec_add(vec1,val):
    "Provides the + operator for adding two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hAdd(vec1,val,vecout)
    return vecout

# Operator:  -
def Vec_sub(vec1,val):
    "Provides the - operator for subtracting two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hSub(vec1,val,vecout)
    return vecout

# Operator:  *
def Vec_mul(vec1,val):
    "Provides the * operator for multiplying two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hMul(vec1,val,vecout)
    return vecout

# Operator:  /
def Vec_div(vec1,val):
    "Provides the / operator for dividing two vectors or a vector by a scalar. The result will be a new vector."
    vecout=vec1.new()
    hDiv(vec1,val,vecout)
    return vecout


#Fourier Transforms 
setattr(FloatVec,"fft",hFFT)
setattr(FloatArray,"fft",hFFT)

for v in hAllArrayTypes:
    setattr(v,"__repr__",ArrayToPrintString)
    setattr(v,"setDim",hArray_setDim)
    setattr(v,"getDim",hArray_getDim)
    setattr(v,"newreference",hArray_newreference)
    setattr(v,"__getitem__",hArray_getitem)
    setattr(v,"__setitem__",hArray_setitem)

for v in hAllVectorTypes:
    setattr(v,"__repr__",VecToPrintString)
    setattr(v,"extendflat",extendflat)
    setattr(v,"setDim",hVector_setDim)
    setattr(v,"getDim",hVector_getDim)
    setattr(v,"elem",hVector_elem)
    setattr(v,"dimension",[])
    setattr(v,"ndim",0)
    for s in ["hResize","hNew"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hAllContainerTypes:
    for s in ["hFill","hCopy","hSort"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hRealContainerTypes:
    for s in ["hMean","hStdDev","hDownsample","hNegate","hNorm","hNormalize","hAcos","hAsin","hAtan","hCeil","hFloor","hFindGreaterThan","hFindGreaterEqual","hFindGreaterThanAbs","hFindGreaterEqualAbs","hFindLessThan","hFindLessEqual","hFindLessThanAbs","hFindLessEqualAbs"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hComplexContainerTypes:
    for s in ["hSpectralPower","hArg","hImag","hNorm","hReal","hConj","hCrossCorrelateComplex","hInvFFT"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hNumericalContainerTypes:
    setattr(v,"__add__",Vec_add)
    setattr(v,"__sub__",Vec_sub)
    setattr(v,"__div__",Vec_div)
    setattr(v,"__mul__",Vec_mul)
    setattr(v,"__iadd__",Vec_iadd)
    setattr(v,"__imul__",Vec_imul)
    setattr(v,"__idiv__",Vec_idiv)
    setattr(v,"__isub__",Vec_isub)
    for s in ["hAbs","hConvert","hMul","hDiv","hSub","hAdd","hMulAdd","hDivAdd","hSubAdd","hAddAdd","hMulAddConv","hDivAddConv","hSubAddConv","hAddAddConv","hCos","hCosh","hExp","hLog","hLog10","hSin","hSinh","hSqrt","hSquare","hTan","hTanh","hSum","hMulSum","hRandom","hSortMedian","hMedian","hFindLowerBound"]:
        setattr(v,s[1:].lower(),eval(s))

#========================================================================
# Convenience Vector Constructor
#========================================================================

def Vector(Type=float,size=-1,fill=None):
    """
    The basic Boost Python STL vector constructor takes no arguments and
    hence is a litte cumbersome to use. Here we provide a wrapper function
    that is useful for interactive use. If speed is of the essence, use
    the original vector constructors: BoolVec(), IntVec(), FloatVec(),
    ComplexVec(), StringVec()
    
    Usage:

    Vector(Type) -  will create an empty vector of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Vector(Type,size) - will create an vector of type "Type", with length "size".

    Vector(Type,size,fill) - will create an vector of type "Type", with length
    "size" and initialized with the value "fill"

    Vector([1,2,3,...]) or Vector((1,2,3,...)) - if a list or a tuple is
    provided as first argument then a vector is created of the type of the
    first element in the list or tuple (here an integer) and filled with
    the contents of the list or tuple.

    Vector() defaults to a float vector.

    Note, that size and fill take precedence over the list and tuple
    input. Hence if you create a vector with Vector([1,2,3],size=2) it
    will contain only [1,2]. Vector([1,2,3],size=2,fill=4) will give
    [4,4].
    """
    vtype=Type
    if (type(vtype) in hAllArrayTypes):  # ArrayClass
        vtype=basetype(Type)
        vec=Vector(Type.getVector())
    elif (type(vtype) in hAllListTypes):  #List or Vector 
        vtype=type(Type[0])
        vec=type2vector(vtype)
        vec.extend(Type)
    else:
        vec=type2vector(vtype)
    vec.type=vtype
    if (size>=0): vec.resize(size)
    if (not fill==None): vec.fill(fill)
    return vec

#======================================================================
#  Array Class and Vector Methods/Attributes
#======================================================================

def Array(Type=float,dimensions=None,size=-1,fill=None):
    if isVector(Type):  #Make a new array with refernece to the input vector
        ary=type2array(basetype(Type))
        ary.vec=Type
        ary.setVector(ary.vec)
    elif isArray(Type):  # Just make a copy with reference to same vector
        ary=Type.newreference()
    else: # Create a new vector
        vec=Vector(Type=Type,size=size)
        ary=type2array(basetype(vec))
        ary.vec=vec
        ary.setVector(ary.vec)
    if (type(dimensions) in [list,tuple,IntVec]): ary.setDim(dimensions)
    if not (fill == None): ary.fill(fill)
    return ary


#------------------------------------------------------------------------
# cr DataReader Class
#------------------------------------------------------------------------

def crfile(filename):
    """
    file=crfile("FILENAME.h5") -> DataReader Object

    This is a simple class to interface with the LOFAR CRTOOLS
    datareader class. It deals with LOFAR and LOEPS data alike. You
    can read data vectors, read or set parameters and get summary of the contents.
    """
    file=hFileOpen(filename)
    file.filename=filename
    return file

DataReader.read=hFileRead
DataReader.__doc__=crfile.__doc__

#------------------------------------------------------------------------
# Pypeline Extension, Functions and Algorithms
#------------------------------------------------------------------------

def CheckParameterConformance(data,limits):
    """
    CheckParameterConformance([12,-10],[("mean",(-15,15)),("rms",(10,40))])  ->  ["rms"]
    
    Checks whether a list of numbers is within a range of limits
    specified beforehand. The limits are provided as a list of tuples,
    of the form ("FIELDNAME",(LOWERLIMT,UPPERLIMIT)). A list of
    fieldnames is returned where the data does not fall within the
    specified range.

    """
    result=[]
    for i in range(len(data)):
        if (data[i]<limits[i][1][0]) | (data[i]>limits[i][1][1]): result.append(limits[i][0])
    return result


def CRQualityCheck(file,limits,maxblocksize=65536,nsigma=5):
    """
    CRQualityCheck(file,[("mean",(-15,15)),("rms",(5,15)),("nonGaussianity",(-1,3))]) 

    Will step through all antennas of a file assess the data quality. For each 

    """
#Initialize some parameters
    nAntennas=file.get("nofAntennas")
    filesize=file.get("Filesize")
    blocksize=min(filesize/4,maxblocksize)
    file.set("Blocksize",blocksize)
    nBlocks=filesize/blocksize; 
    blocklist=range(nBlocks/4)+range(3*nBlocks/4,nBlocks)
#Create the some scratch vectors
    qualityflaglist=[]
    where=Vector(int,blocksize)
    rawdata=Vector(float)
    rawdata.setDim([nAntennas,blocksize])
#Calculate probabilities to find certain peaks
    probability=funcGaussian(nsigma,1,0) # what is the probability of a 5 sigma peak
    npeaksexpected=probability*blocksize # what is the probability to see such a peak with the blocksize
    npeakserror=sqrt(npeaksexpected) # what is the statisitcal error on that expectation
#Start checking
    print "Quality checking of file ",file.filename
    print "Considering",nAntennas," antennas and the Blocks:",blocklist
    print "Blocksize=",blocksize,", nsigma=",nsigma, ", number of peaks expected per block=",npeaksexpected
    for Block in blocklist:
        file.set("Block",Block).read("Voltage",rawdata)
        for Antenna in range(nAntennas):
            print "Antenna={0:2d},".format(Antenna),"Block={0:3d}:".format(Block),
            datamean = rawdata.mean(Antenna*blocksize,(Antenna+1)*blocksize)
            datarms = rawdata.elem(Antenna).stddev(datamean)
            datanpeaks=rawdata.elem(Antenna).findgreaterthanabs(int(round(nsigma*datarms)),where)
            dataNonGaussianity=(datanpeaks-npeaksexpected)/npeakserror
            print "mean={0:4.2f},".format(datamean),"rms={0:5.1f},".format(datarms),"npeaks={0:5d},".format(datanpeaks),"nonGaussianity={0:5.2f}".format(dataNonGaussianity),
            noncompliancelist=CheckParameterConformance([datamean,datarms,dataNonGaussianity],limits)
            if noncompliancelist:
                qualityflaglist.append((Antenna,Block,noncompliancelist))
                print noncompliancelist,"!!"
            else: print ""
    return qualityflaglist




