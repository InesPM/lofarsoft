# Import module
import pdb
debugon=False


from math import *
from hftools import *
from pydoc import help as pyhelp
import os,sys,re
import matplotlib.pyplot as plt
import time as time
import numpy as np

LOFARSOFT=os.environ["LOFARSOFT"]
pydocpyfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.py"
pydoctxtfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.tex"

#Read in the doc strings for the functions in hftools
execfile(pydocpyfilename)
f=open(pydoctxtfilename);pycralldocstring=f.read();f.close()

#======================================================================
#  Help Functions
#======================================================================

def all():
    pass

all.__doc__=pycralldocstring

def hhelpstring(func):
    """
    Returns the doc string of a function. Check if the docstring
    contains informations from the CRTOOLS. If so, return only that
    part.
    """
    doc=func.__doc__
    if doc==None: return ""
    match=re.search("^PYCRTOOLS .*",doc,re.MULTILINE)
    if (match):
        predoc=doc[match.start():match.end()]
        doc=re.sub("PYCRTOOLS .*","",doc[match.end():])
        doc = predoc + doc;
    return doc

#    Included to overwrite the pydoc help function.
def help():
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    help(help)


def help(func=help,brief=True):
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the underlying c++
    code (if the function was wrapped from c++).
    """
    if func==None: func=help
    if (hasattr(func,"__class__")): print "Class: ", func.__class__
    if brief: print hhelpstring(func)
    else: print pyhelp(func)
    methods=dir(func)
    methods2=[]
    for m in methods:
        if not ((m.find("_")==0) | (m.find("func_")==0) | (m.find("im_")==0)): methods2.append(m)
    if len(methods2)>0:
        print "\nAvailable methods: ",
        for m in methods2[0:-1]:
            print m+", ",
        print methods2[-1]
        if (hasattr(func,"__name__")):
            print "\nType help("+func.__name__+".METHOD) to get more info on the individual methods."
        else:
            print "\nType help(func.METHOD) to get more info on the individual methods."


#======================================================================
#  Pretty Printing
#======================================================================

#Some definitons to make pretty (and short) output of vectors
def VecToString(self,maxlen=10):
    veclen=len(self)
    stringval=""
    if veclen>0:
        stringval+=str(self[0])
    for i in range(1,min(len(self),maxlen)):
        stringval+=","+str(self[i])
    if veclen>maxlen:
        stringval+=",..."
    return stringval


def VecToPrintString(self,maxlen=5):
    s=typename(basetype(self))+","
    return "Vec("+s+str(len(self))+")=[" +VecToString(self,maxlen)+"]"

def hArrayToPrintString(self,maxlen=5):
    s=typename(basetype(self))+", "
    loops=""
    if self.loopingMode(): loops="*"
    name=self.getKey("name");
    if name=="": name="hArray";
    return name+"("+s+str(self.getDim())+"="+str(len(self))+", ["+str(self.getBegin())+":"+str(self.getEnd())+"]"+loops+") -> [" +VecToString(self.getVector()[self.getBegin():self.getEnd()],maxlen)+"]"

#========================================================================
# Adding multi-dimensional array capabilities to vector class
#========================================================================

def multiply_list(l):
    """
    multiply_list([n1,n2,...]) -> n1*n2*n3 ....

    Multiplies all elements of a list with each other and returns the
    result.
    """
    return reduce(lambda x,y:x*y,l)

def hVector_list(self):
    """
    vec.list() -> [x1,x2,x3, ...]

    Retrieve the STL vector as a python list.
    """
    return list(self)

def hVector_val(self):
    """
    vec.val() -> a             : if length == 1
    vec.val() -> [a,b,c,...]   : if length > 1

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    if len(self)==1: return self[0]
    else: return list(self)

def hVector_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN])

    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list.
    """
    newsize=multiply_list(dimensions_list) # dim1*dim2*...*dimN
    if (not len(self)==newsize): self.resize(newsize)
    self.dimension=dimensions_list
    self.ndim=len(dimensions_list)
    return self

def hVector_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)

    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    if self.ndim>0: return self.dimension
    else: return len(self)

def hVector_elem(self,n):
    """
    self.elem(n) -> nth element of the first dimension of the array

    """
    if self.ndim>1: # this actually is a multi-dim array
        if type(n)==int: #select just one element
            size=multiply_list(self.dimension[1:])
            return self[n*size:(n+1)*size]
        else:
            print "elem: index unknown ..."
            return self
    else:
        return self[n]

def hVector_vec(self):
    """
     vector.vec() -> vector Convenience method that allows one to
    treat hArrays and hVectors in the same way, i.e. using the vec()
    method returns the intrinsic vector for both.
    """
    return self;

def extendflat(self,l):
    """
    vector.extendflat([[e1-1,e1-2,...],[e2-1,e2-2,...],..]) -> [e1-1,e1-2,...,e2-1,e2-2,...]

    Appending all elements in a list of lists to a one-dimensional
    vector with a flat dat structure (just 1D).
    """
    map(lambda x:self.extend(x),l)
    return self

def hArray_none(self):
    """
    array.none() -> None

    Simply retuens the None object. Can be used to suppress unwanted
    output, when an operation returns an array.
    """
    return None

def hArray_newreference(self):
    """
    array.newreference() -> copy of array referencing the same vector

    Will make an exact copy of the array, and reference the same
    vector. Hence the new array can be assigned a new slice, but will
    still access the same underlying vector in memory.
    """
    ary=self.shared_copy()
    ary.par=self.par
    return ary

def hArray_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) -> hArray with new dimensions

    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list.
    """
    apply(self.setDimensions,dimensions_list)
    return self;

def hArray_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)

    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    return list(self.getDimensions())

def hArray_return_slice_start(val):
    """ Reduces a slice to its start value"""
    if (val==Ellipsis):
        return 0
    elif type(val)==slice:
         if (val.start == None): return 0
         return val.start
    elif type(val)==list:
        return val[0]
    elif type(val) in hAllArrayTypes:
        return val[0].val()
    elif type(val) in hAllVectorTypes:
        return val[0]
    else:
        return val

def hArray_return_slice_end(val):
    """ Reduces a slice to its end value"""
    if val==Ellipsis:
        return -1
    elif type(val)==slice:
        return hNone2Value(val.stop,-1)
    elif type(val)==list:
        return val[-1]
    elif type(val) in hAllArrayTypes:
        return val[-1].val()
    elif type(val) in hAllVectorTypes:
        return val[-1]
    else:
        return val+1

def hNone2Value(none,defval):
    """
    Returns a default value if the the first input is the None object,
    otherwise return the value of the first argument.
    """
    if none==None: return defval
    else: return none

def hSliceToNormalValues(s,dim):
    """
    Returns a slice object where none and negative numbers are replaced by the appropriate integers, given a dimension (length) dim of the full slice.
    """
    if type(s)==int:
        if s<0: return s+dim
    if not type(s)==slice: return s
    s1=s.start;s2=s.stop;s3=s.step
    if s1==None: s1=0
    elif s1<0: s1+=dim
    elif s1>dim: s1=dim;
    if s2==None: s2=dim
    elif s2<0: s2+=dim
    elif s2>dim: s2=dim;
    if s3==None: s3=1
    return slice(s1,s2,s3)


def hArray_vec(self):
    """
    array.vec() -> Vector([x1,x2,x3, ...])

    Retrieve the currently selected slice from the stored vector. If
    the entire vector is to be returned a reference to the internal
    data vector is returned. Otherwise, if a slice is active, a copy
    of that slice is returned. Use getVector() to ensure you always
    get only a reference.
    """
    beg=self.getBegin(); end=self.getEnd()
    if ((beg==0 )& (end==len(self))): return self.getVector()
    else: return self.getVector()[beg:end]

def hArray_list(self):
    """
    array.list() -> [x1,x2,x3, ...]

    Retrieve the currently selected slice from the stored vector as a
    python list.
    """
    return list(self.getVector()[self.getBegin():self.getEnd()])

def hArray_new(self):
    """
    ary.new() -> new_array

    Create a new array of the same type and dimensions
    """
    return hArray(basetype(self),self)

def hArray_val(self):
    """
    ary.val() -> a             : if length == 1
    ary.val() -> [a,b,c,...]   : if length > 1

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    return self.vec().val()

def hArray_copy_resize(self,ary):
    """
    Retrieve the first element of the currently selected slice from the stored vector.
    """
    ary.resize(len(self))
    ary.copy(self)
    return ary

def hArray_getitem(self,indexlist):
    """
    self[n1,n2,n3]-> return Element with these indices

    Retrieves a copy of the array with the internal slices set to reflect ...
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    if type(indexlist)==tuple: indexlist=list(indexlist)
    else: indexlist=[indexlist]
    ary=hArray(self)
    ary.par=self.par
    dimensions=ary.getDim()
#   Now check if there is an ellipsis in the index list, which indicates looping.
    ellipsiscount=indexlist.count(Ellipsis)
#    pdb.set_trace()
    if ellipsiscount==0:
        ellipsislocation=0
    elif ellipsiscount==1:
        ellipsislocation=indexlist.index(Ellipsis)
        if ellipsislocation==0:
            indexlist[0]=slice(0,None,None) # replace ellipsis with slice
        else:
            if type(indexlist[ellipsislocation-1]) in [slice,list]: # check if Ellipsis is preceded by a slice specification over which to loop.
                del indexlist[ellipsislocation] # delete ellipsis
                ellipsislocation -= 1; #looping is over preceding index
            else:
                indexlist[ellipsislocation]=slice(0,None,None) # replace ellipsis with slice
    else:
        print "Error: hArray_getitem - only one Ellipsis (...) allowed in index list"
        return ary
    nindices=len(indexlist)
    for i in range(nindices):
        indexlist[i]=hSliceToNormalValues(indexlist[i],dimensions[i])
    indexliststarts=Vector(map(hArray_return_slice_start,indexlist))
    lastelement=indexlist[-1]
    start_off=0; end_off=0;
    if ellipsiscount:
        ellipsiselement=indexlist[ellipsislocation]
        if ellipsislocation<nindices-1:
            start_off=hArray_return_slice_start(lastelement);
            end_off=dimensions[nindices-1]-hArray_return_slice_end(lastelement)
            indexlist=indexlist[0:-1]
        if type(ellipsiselement)==slice: ary.loop(indexliststarts[0:ellipsislocation],hNone2Value(ellipsiselement.start,0),hNone2Value(ellipsiselement.stop,-1),hNone2Value(ellipsiselement.step,1),start_off,end_off)
        elif type(lastelement)==list:
            ary.loop(indexliststarts[0:ellipsislocation],Vector(indexlist[ellipsislocation]),start_off,end_off)
    elif type(lastelement)==slice: #Non-looping slice
        ary.setSliceVector(indexliststarts[0:-1],hArray_return_slice_start(lastelement),hArray_return_slice_end(lastelement))
    elif type(lastelement) in [list,IntVec,IntArray]: #make new vector 
        if len(dimensions)==nindices: ## only implemented for last slice.
            arycopy=hArray(Type=basetype(ary),dimensions=[len(lastelement)])
            if nindices>1: 
                ary.setSliceVector(indexliststarts[0:-1],0,-1)
            arycopy.copy(ary,hArray(lastelement),-1)
            return arycopy
        else:
            print "Error: hArray_getitem - list of indices has to be at the position of the last index."
    else: # normal integer index
        ary.setSliceVector(indexliststarts[0:-1],lastelement,lastelement+1)
    return ary;

def hArray_setitem(self,dims,fill):
    """
    vec[n1,n2,..] = [0,1,2] -> set slice of array to input vector/value

    """
    if (type(fill)) in hAllListTypes: fill=hArray(fill)
    hFill(hArray_getitem(self,dims),fill)

def hArray_read(self,datafile,key):
    """
    array.read(file,"Time") -> read key Data Array "Time" from file into array.

    Will also set the attributes par.file and par.filename of the array and
    make a history entry.
    """
    self.par.filename=datafile.filename
    self.addHistory("read","Reading data from file "+self.par.filename)
    self.par.file=datafile.read(key,self)
    return self

def hArray_setPar(self,key,value):
    """
    array.setPar("keyword",value) -> array.par.keyword=value

    returns array.

    Provides a method to set a paramter associated with an array, e.g.,

    Example:

    fftdata=datafile["FFT"].setPar("xvalue",datafile["Frequency"])

    to set the default x-axis values.
    """
    setattr(self.par,key,value)
    return self

class hArray_par:
    """
    Parameter attribute. Used to hold and inherit arbitrary additional
    paramaters used by python methods (e.g. xvalues for the plotting
    command).
    """
    def __repr__(self):
        s=""
        for attr in dir(self)[2:]:
            if not (attr.find("_")==0):
                s+="par."+str(attr)+" = "+str(getattr(self,attr))+"\n"
        return s
    def __list__(self):
        l=[]
        for attr in dir(self)[2:]:
            if not (attr.find("_")==0):
                l.append((str(attr),getattr(self,attr)))
        return l


def hArray_setUnit(self,*arg):
    self.setUnit_(*arg)
    return self

#======================================================================
#  Define Plotting functions for vectors and arrays
#======================================================================

#    plt.subplot(1,2,1)
#%SKIP
#plt.title("Average Spectrum for Two Antennas")


def hPlot_plot(self,xvalues=None,xlabel=None,ylabel=None,title=None,clf=True,logplot=None,xlim=None,ylim=None,legend=None):
    """
    array[0].plot(self,xvalues=vec,xlabel="x",ylabel="y",title="Title",clf=True,logplot="xy") -> plot the array (loglog)

    Method of arrays. Plots the current slice. If the array is in
    looping mode, multiple curves are plotted in one windows.

    You can set the plotting parameters also as attributes to the .par
    class of the array, e.g., "array.par.xvalues=x_vector; array.plot()"

    Parameters:

    xvalues: an array with corresponding x values, if "None" numbers
    from 0 to length of the array are used

    xlabel: the x-axis label, if not specified, use the "name" keyword
    of the xvalues array - units will be added automatically

    ylabel: the y-axis label, if not specified, use the "name" keyword
    of the array - units will be added automatically

    xlim: tuple with minimum and maximum limits for the x-axis

    ylim: tuple with minimum and maximum limits for the y-axis

    legend: plots a legen taking a tuple of strings for each plotted
    line as input, e.g. legend=("A","B",...)

    title: a title for the plot

    clf: if True (default) clear the screen beforehand (use False to
    compose plots with multiple lines from different arrays.

    logplot: can be used to make loglog or semilog plots:
            "x" ->semilog in x
            "y" ->semilog in y
            "xy"->loglog plot
    """
    if xvalues==None:
        if hasattr(self.par,"xvalues"): xvalues=self.par.xvalues
        else: xvalues=hArray(range(len(self.vec())))
    xunit=xvalues.getUnit().replace("\\mu","$\\mu$")
    if not xunit=="": xunit=" ["+xunit+"]"
    yunit=self.getUnit().replace("\\mu","$\\mu$")
    if not yunit=="": yunit=" ["+yunit+"]"
    if xlabel==None: xlabel=xvalues.getKey("name")
    if ylabel==None: ylabel=self.getKey("name")
    var="clf"; dflt=True; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="xlabel"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="ylabel"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="xlim"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="ylim"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="legend"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="title"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        elif hasattr(self.par,"filename"): exec(var+"=self.par.filename")
        else: exec("var=dflt")
    var="logplot"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    if clf: self.plt.clf()
    if logplot=="x": _plot=self.plt.semilogx
    elif logplot=="y": _plot=self.plt.semilogy
    elif (logplot=="xy") | (logplot=="yx"): _plot=self.plt.loglog
    else: _plot=self.plt.plot
    iterate=True;
    while (iterate):
        _plot(xvalues.vec(),self.vec())
        xvalues.next; iterate=self.next().doLoopAgain()
    self.plt.ylabel(ylabel+yunit)
    self.plt.xlabel(xlabel+xunit)
    if not xlim==None: self.plt.xlim(*xlim)
    if not ylim==None: self.plt.ylim(*ylim)
    if not legend==None: self.plt.legend(legend)
    if not ((title=="") | (title==None)): self.plt.title(title)

#======================================================================
#  Define Lists of hArray and Vector Types that we will use
#======================================================================

hBaseTypes=[int,float,complex,bool,str]
hBaseNames=["Int","Float","Complex","Bool","String"]
hBaseNamesPy=["int","float","complex","bool","str"]

hRealTypes=[int,float]
hComplexTypes=[complex]
hNumericalTypes=hRealTypes+hComplexTypes
hOtherTypes=[bool,str]

#------------------------------------------------------------

hVectorBaseTypeDictionary={}
hArrayBaseTypeDictionary={}
hArrayTypeDictionary={}
hVectorTypeDictionary={}
hTypeDictionary={}
hTypeNamesDictionary={}
hAllVectorTypes=[]
hAllArrayTypes=[]
for i in range(len(hBaseTypes)):
    btype=hBaseTypes[i]
    vtype=eval(hBaseNames[i]+"Vec")
    atype=eval(hBaseNames[i]+"Array")
    hAllVectorTypes.append(vtype)
    hAllArrayTypes.append(atype)
    hVectorBaseTypeDictionary[vtype]=btype
    hArrayBaseTypeDictionary[atype]=btype
    hVectorTypeDictionary[btype]=vtype
    hArrayTypeDictionary[btype]=atype
    hTypeDictionary[btype]=btype
    hTypeNamesDictionary[btype]=hBaseNamesPy[i]

hAllListTypes=hAllVectorTypes+[list,tuple]


basetypedictionary=dict(zip(hVectorBaseTypeDictionary.keys()+hArrayBaseTypeDictionary.keys()+hTypeDictionary.keys(),hVectorBaseTypeDictionary.values()+hArrayBaseTypeDictionary.values()+hTypeDictionary.values()))

def type2vector(basetype):
    """type2vector(float) -> Vec(0)=[]

    Creates a vector with elements of type 'basetype'. Returns None if
    a vector of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hVectorTypeDictionary[basetype]()
    else: return None

def type2array(basetype):
    """type2array(float) -> Vec(0)=[]

    Creates an array with elements of type 'basetype'. Returns None if
    an array of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hArrayTypeDictionary[basetype]()
    else: return None

def basetype(vec_or_array):
    """
    basetype(IntVec) -> <type 'int'>
    basetype(FloatArray) -> <type 'float'>
    basetype(complex) -> <type 'complex'>

    Returns the basic type contained in the vector or array. Input can be either a vector, an array, or a type thereof.
    """
    t=type(vec_or_array)
    if t==type: t=vec_or_array
    return basetypedictionary[t]

def typename(btype):
    """
    basetype(float) -> "float"
    basetype(str) -> "str"

    Returns the name of the base type as a short string.
    """
    t=type(btype)
    if t==type: t=btype
    return hTypeNamesDictionary[t]


def ishArray(ary):
    """
    ishArray(array) -> True or False

    Returns true if the argument is one of the hArray arrays, i.e. those listed in hAllVectorTypes.
    """
    return type(ary) in hAllArrayTypes

def isVector(vec):
    """
    isVector(vec) -> True or False

    Returns true if the argument is one of the standard c++ vectors i.e. those liste in hAllVectorTypes.
    """
    return type(vec) in hAllVectorTypes

hRealVectorTypes=map(lambda t:hVectorTypeDictionary[t],hRealTypes)
hComplexVectorTypes=map(lambda t:hVectorTypeDictionary[t],hComplexTypes)
hNumericalVectorTypes=map(lambda t:hVectorTypeDictionary[t],hNumericalTypes)
hOtherVectorTypes=map(lambda t:hVectorTypeDictionary[t],hOtherTypes)

hRealArrayTypes=map(lambda t:hArrayTypeDictionary[t],hRealTypes)
hComplexArrayTypes=map(lambda t:hArrayTypeDictionary[t],hComplexTypes)
hNumericalArrayTypes=map(lambda t:hArrayTypeDictionary[t],hNumericalTypes)
hOtherArrayTypes=map(lambda t:hArrayTypeDictionary[t],hOtherTypes)

hRealContainerTypes=hRealVectorTypes+hRealArrayTypes
hComplexContainerTypes=hComplexVectorTypes+hComplexArrayTypes
hNumericalContainerTypes=hNumericalVectorTypes+hNumericalArrayTypes
hOtherContainerTypes=hOtherVectorTypes+hOtherArrayTypes
hAllContainerTypes=hAllVectorTypes+hAllArrayTypes

#======================================================================
#  Vector Methods/Attributes
#======================================================================

"""
Here we add the functions defined in the hftools.cc as
methods/attributes to the (STL) vector classes in python.
"""

Vectordoc= """
A number of vector types are provided: bool, int, float, complex, and
str.

This vector is subscriptable and sliceable, using the
standard python syntax, e.g. v[1:3], or v[2]=0.

To creat a vector most efficently, use the original vector
constructors: BoolVec() - IntVec() - FloatVec() - ComplexVec() -
StringVec()

There is also a more convenient constructor function "Vector" that is
useful for interactive use:

Vector(Type) , where Type=float,int,complex,str, or bool
Vector(Type,size)
Vector(Type,size,fill)
Vector(list), Vector(tuple)
Vector() defaults to a float vector

Use the resize method to allocate more or less memory.

Some of the basic arithmetic is available in an intuitve way, e.g.,
vec+1, vec1+vec2, vec+=vec2).

See the tutorial (tutorial.py) for more details.
"""

Arraydoc= """

hArray(Type=int,dimensions=[n1,n2,n3...],fill=None) -> IntArray

hArray(Type=float,dimensions=[n1,n2,n3...],fill=None) -> FloatArray

....

While the basic underlying data structures are plain STL vectors, in
many cases, however, one has to deal with multi-dimensional data. For
this case we introduce a new wrapper class, named hArrays, that
mimicks a multi-dimensional array, but still operates on an underlying
vector with essentially a flat, horizontal data structure. Given that
a major concern is to minimize duplication of large data structures,
the array class will share memory with its associated vector and also
with arrays that are derived from it. Explicit copying will have to be
done in order to avoid this. Access to various dimensions (rows,
columns, etc...) is done via slices that need to be contiguous in
memory! Since the array is vector-based, all methods defined for
vectors are also inherited by hArrays and can be applied to slices or
even automatically loop over multiple slices (e.g., rows or columns).

An array is defined using the hArray function. This is a constructor
function and not a class of its own. It will return array classes of
different types, such as IntArray, FloatArray, ComplexArray,
StringArray, BoolArray, referring to the different data types they
contain. As for vectors, each array can only contain one type of data.

where Type can be a Python type, a Python list/tuple (where the first
element determines the type), an STL vector, or another hArray.

Dimensions are given as a list of the form [dim1,dim2,dim3, ...]. The
size of the underlying vector will automatically be resized to
dim1*dim2*dim3* ... to be able to contain all elements. Alternatively,
one can provide another array, who's dimensions will be copied.

The array can be filled with an initialization values that can be
either a single value, a list, a tuple, or an STL vector of the same
type.
"""

IntArray.__doc__="c++ hftools array of type 'int'\n"+Arraydoc
FloatArray.__doc__="c++ hftools array of type 'float'\n"+Arraydoc
StringArray.__doc__="c++ hftools array of type 'str'\n"+Arraydoc
BoolArray.__doc__="c++ hftools array of type 'bool'\n"+Arraydoc
ComplexArray.__doc__="c++ hftools array of type 'complex'\n"+Arraydoc

IntVec.__doc__="c++ standard template library (STL) vector of type 'int'\n"+Vectordoc
FloatVec.__doc__="c++ standard template library (STL) vector of type 'float'\n"+Vectordoc
StringVec.__doc__="c++ standard template library (STL) vector of type 'str'\n"+Vectordoc
BoolVec.__doc__="c++ standard template library (STL) vector of type 'bool'\n"+Vectordoc
ComplexVec.__doc__="c++ standard template library (STL) vector of type 'complex'\n"+Vectordoc

IntVec.__name__="IntVec"
FloatVec.__name__="FloatVec"
BoolVec.__name__="BoolVec"
ComplexVec.__name__="ComplexVec"
StringVec.__name__="StringVec"

#Operator Overloading - basic arithmetic

# Operator:  +=
def Vec_iadd(vec1,vec2):
    """
    Provides the += operator for adding two vectors in place.
    vec1+=vec2 will add all elements in vec2 to the corresponding
    elements in vec1 and store the result in vec1.
    """
    hAdd(vec1,vec2)
    return vec1

# Operator:  -=
def Vec_isub(vec1,vec2):
    "Provides the -= operator for addig two vectors in place. \
    vec1-=vec2 will subtract all elements in vec2 from the corresponding elements in vec1\
    and store the result in vec1."
    hSub(vec1,vec2)
    return vec1

# Operator:  /=
def Vec_idiv(vec1,vec2):
    "Provides the /= operator for addig two vectors in place. \
    vec1/=vec2 will divide all elements in vec1 by the corresponding elements in vec2\
    and store the result in vec1."
    hDiv(vec1,vec2)
    return vec1

# Operator:  *=
def Vec_imul(vec1,vec2):
    "Provides the *= operator for addig two vectors in place. \
    vec1=vec2 will multiply all elements in vec1 with the corresponding elements in vec2\
    and store the result in vec1."
    hMul(vec1,vec2)
    return vec1

# Operator:  +
def Vec_add(vec1,val):
    "Provides the + operator for adding two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hAdd(vecout,vec1,val)
    return vecout

# Operator:  -
def Vec_sub(vec1,val):
    "Provides the - operator for subtracting two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hSub(vecout,vec1,val)
    return vecout

# Operator:  *
def Vec_mul(vec1,val):
    "Provides the * operator for multiplying two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hMul(vecout,vec1,val)
    return vecout

# Operator:  /
def Vec_div(vec1,val):
    "Provides the / operator for dividing two vectors or a vector by a scalar. The result will be a new vector."
    vecout=vec1.new()
    hDiv(vecout,vec1,val)
    return vecout


#Fourier Transforms
setattr(FloatVec,"fft",hFFTCasa)
setattr(FloatArray,"fft",hFFTCasa)

for v in hAllArrayTypes:
    setattr(v,"__repr__",hArrayToPrintString)
    setattr(v,"setPar",hArray_setPar)
    setattr(v,"setDim",hArray_setDim)
    setattr(v,"getDim",hArray_getDim)
    setattr(v,"vec",hArray_vec)
    setattr(v,"val",hArray_val)
    setattr(v,"new",hArray_new)
    setattr(v,"none",hArray_none)
    setattr(v,"read",hArray_read)
    setattr(v,"list",hArray_list)
    setattr(v,"plt",plt)
    setattr(v,"plot",hPlot_plot)
    setattr(v,"copy_resize",hArray_copy_resize)
    setattr(v,"newreference",hArray_newreference)
    setattr(v,"__getitem__",hArray_getitem)
    setattr(v,"__setitem__",hArray_setitem)
    setattr(v,"setUnit",hArray_setUnit)

for v in hAllVectorTypes:
    setattr(v,"__repr__",VecToPrintString)
    setattr(v,"extendflat",extendflat)
    setattr(v,"setDim",hVector_setDim)
    setattr(v,"getDim",hVector_getDim)
    setattr(v,"elem",hVector_elem)
    setattr(v,"val",hVector_val)
    setattr(v,"vec",hVector_vec)
    setattr(v,"list",hVector_list)
    setattr(v,"dimension",[])
    setattr(v,"ndim",0)
    for s in ["hResize","hNew"]:
        setattr(v,s[1:].lower(),eval(s))


for v in hAllContainerTypes:
    for s in ["hFill","hCopy","hSort","hZipper","hReadDump","hWriteDump","hRedistribute","hPPrint","hPrettyString"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hRealContainerTypes:
    for s in ["hMean","hStdDev","hDownsample","hUpsample","hDownsampleSpikyData","hInterpolate2P","hInterpolate2PSubpiece","hNegate","hVectorLength","hNormalize","hArg","hImag","hNorm","hReal","hAcos","hAsin","hAtan","hCeil","hFloor","hMeanGreaterThanThreshold","hMeanGreaterEqualThreshold","hMeanLessThanThreshold","hMeanLessEqualThreshold","hFindGreaterThan","hFindGreaterEqual","hFindGreaterThanAbs","hFindGreaterEqualAbs","hFindLessThan","hFindLessEqual","hFindLessThanAbs","hFindLessEqualAbs","hCountGreaterThan","hCountGreaterEqual","hCountGreaterThanAbs","hCountGreaterEqualAbs","hCountLessThan","hCountLessEqual","hCountLessThanAbs","hCountLessEqualAbs","hFindBetween","hFindBetweenOrEqual","hFindOutside","hFindOutsideOrEqual","hRunningAverage","hDelayToPhase","hInvFFTCasa","hFFTw","hInvFFTw","hGetHanningFilter","hApplyHanningFilter","hSpectralPower","hRFIDownsampling","hRFIBaselineFitting","hRFIFlagging","hLinearFitPolynomialX","hLinearFit","hErrorsToWeights","hPolynomial"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hComplexContainerTypes:
    for s in ["hConj","hCrossCorrelateComplex","hFFTCasa","hInvFFTw","hFFTw","hNyquistSwap","hPhaseToComplex","hAmplitudePhaseToComplex","hRFIDownsampling"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hNumericalContainerTypes:
    setattr(v,"__add__",Vec_add)
    setattr(v,"__sub__",Vec_sub)
    setattr(v,"__div__",Vec_div)
    setattr(v,"__mul__",Vec_mul)
    setattr(v,"__iadd__",Vec_iadd)
    setattr(v,"__imul__",Vec_imul)
    setattr(v,"__idiv__",Vec_idiv)
    setattr(v,"__isub__",Vec_isub)
    for s in ["hFillRange","hAbs","hMax","hMin","hConvert","hConvertResize","hMul","hDiv","hSub","hAdd","hMulTo","hDivTo","hSubTo","hAddTo","hMulAdd","hDivAdd","hSubAdd","hAddAdd","hCos","hCosh","hExp","hLog","hLog10","hSin","hSinh","hSqrt","hSquare","hTan","hTanh","hSum","hMulSum","hRandom","hSortMedian","hMedian","hFindLowerBound"]:
        setattr(v,s[1:].lower(),eval(s))

#========================================================================
# Convenience Vector Constructor
#========================================================================

def Vector(Type=float,size=-1,fill=None):
    """
    The basic Boost Python STL vector constructor takes no arguments and
    hence is a litte cumbersome to use. Here we provide a wrapper function
    that is useful for interactive use. If speed is of the essence, use
    the original vector constructors: BoolVec(), IntVec(), FloatVec(),
    ComplexVec(), StringVec()

    Usage:

    Vector(Type) -  will create an empty vector of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Vector(Type,size) - will create an vector of type "Type", with length "size".

    Vector(Type,size,fill) - will create an vector of type "Type", with length
    "size" and initialized with the value "fill"

    Vector([1,2,3,...]) or Vector((1,2,3,...)) - if a list or a tuple is
    provided as first argument then a vector is created of the type of the
    first element in the list or tuple (here an integer) and filled with
    the contents of the list or tuple.

    Vector() defaults to a float vector.

    Note, that size and fill take precedence over the list and tuple
    input. Hence if you create a vector with Vector([1,2,3],size=2) it
    will contain only [1,2]. Vector([1,2,3],size=2,fill=4) will give
    [4,4].
    """
    vtype=Type
    if (type(vtype) in hAllArrayTypes):  # hArrayClass
        vtype=basetype(Type)
        vec=Vector(Type.getVector())
    elif (type(vtype) in hAllListTypes):  #List or Vector
        vtype=type(Type[0])
        vec=type2vector(vtype)
        vec.extend(Type)
    else:
        vec=type2vector(vtype)
    vec.type=vtype
    if (size>=0): vec.resize(size)
    if type(fill) in [tuple,list]: fill=Vector(fill)
    if type(fill) in hAllArrayTypes: fill=fill.vec()
    if (not fill==None):
        vec.fill(fill)
    return vec

#======================================================================
#  hArray Class and Vector Methods/Attributes
#======================================================================

def hArray(Type=float,dimensions=None,fill=None,name=None,copy=None,properties=None, xvalues=None,units=None,par=None):
    """
    Python convenience constructor function for hArrays. If speed is
    of the essence, use the original vector constructors: BoolArray(),
    IntArray(), FloatArray(), ComplexArray(), StringArray()

    Usage:

    hArray(Type=float,dimensions=[n1,n2,n3...],fill=array/scalar,name="String", copy=array, properties=array, xvalues=array,units=("prefix","unit"),par=(keyword,value)) -> FloatArray

    Array(Type) -  will create an empty array of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Array([1,2,3,...]) or Array((1,2,3,...)) - if a list or a tuple is
    provided as first argument then an array is created of the type of
    the first element in the list or tuple (here an integer) and
    filled with the contents of the list or tuple.

    Array(vec) - will create an array of the type of a vector and use
    the vector as its underlying memory storage. To copy the value,
    use the fill parameter described below.

    Array(Type,dimensions) - will create an array of type "Type",
    specifiying its dimensions. Input for dimensions can be a list or
    a another array (who's dimensions are coopied).

    Array(Type,dimensions,fill) - same as above but fill the array with
    particular values. Input can be a single value, a list, a vector,
    or another array.

    Array() defaults to a float array.

    Note, that dimensions and fill take precedence over the list and tuple
    input. Hence if you create a array with Array([1,2,3],dimension=[2]) it
    will contain only [1,2]. Array([1,2,3],dimension=[2],fill=4) will give
    [4,4].

    Parameters:
    ===========

    dimensions = list or array: set the dimension of the array
    specified as a list of integers, or an array from which to copy
    the dimensions.

    copy = array: make a copy of 'array' in terms of type, dimension,
    fill, and parameter object.

    properties = array: make a new object with the same properties of 'array' in terms of type, dimension,
    and parameter object, but NOT copying the data.

    xvalues = array: set the default x-axis values for plotting to array
    (simply sets self.par.xvalues to array)

    units = (prefixstring,unitname) - will set the initial units of the
    array accordingly, e.g. units=("M","Hz") states that the values
    are provided in units of MHz.

    par = tuple or list of tuples: set additional (arbitrary)
    parameter values that are stored in the .par attribute of the
    array, and are used, e.g., by the plot method to use certain
    defaults.

    """
    if type(copy) in hAllArrayTypes:
        if properties==None: properties=copy
        if fill==None: fill=copy
    if type(properties) in hAllArrayTypes:
        if Type==None: Type=basetype(properties)
        if dimensions==None: dimensions=properties.getDim()
        par=properties.par.__list__()
    if isVector(Type):  #Make a new array with reference to the input vector
        ary=type2array(basetype(Type))
        ary.stored_vector=Type
        ary.setVector(ary.stored_vector)
    elif ishArray(Type):  # Just make a copy with reference to same vector
        ary=Type.newreference()
    else: # Create a new vector
        vec=Vector(Type=Type)
        ary=type2array(basetype(vec))
        ary.stored_vector=vec
        ary.setVector(ary.stored_vector)
    if not hasattr(ary,"par"): setattr(ary,"par",hArray_par())
    if (type(dimensions) in [list,tuple,IntVec]): ary.setDim(dimensions)
    if (type(dimensions) in hAllArrayTypes): ary.setDim(dimensions.getDim())
    if type(par) == tuple: setattr(ary.par,par[0],par[1])
    if type(par) == list: map(lambda elem:setattr(ary.par,elem[0],elem[1]),par)
    if not (xvalues == None): ary.par.xvalues=xvalues
    if not (units == None): 
        if type(units)==str: ary.setUnit("",units) 
        elif type(units)==tuple: ary.setUnit(*units)
        else: print "Error - hArray: Wrong format for units specified."
    if not (fill == None):
        if type(fill) in hAllVectorTypes: ary.vec().fill(fill)
        if type(fill) in [tuple,list]: ary.vec().fill(Vector(fill))
        else: ary.fill(fill)
    if type(name)==str: ary.setKey("name",name);
    return ary

#------------------------------------------------------------------------
# cr DataReader Class
#------------------------------------------------------------------------

def DataReader_getHeaderVariables(self):
    """
    Method to read out the header information from the DataReader and
    put it into attributes of the DataReader object.
    """
    self.keywords=map(lambda s:s[0].lower()+s[1:],set(self.get("keywords").split(", ")).difference(['keywords','help', 'positions','dDate', 'presync', 'TL', 'LTL', 'EventClass', 'SampleFreq', 'StartSample']))
    for v in self.keywords:
        setattr(self,v,self.get(v))

def DataReader_getitem(self,*keys):
    """
    datafile["key"] -> value
    datafile["key1","key2",...] -> [value1, value2,...]

    Method to obtain header information from the DataReader.
    """
    keys0=keys[0]
    if type(keys0)==tuple: return map(lambda k:hFileGetParameter(self,k),keys0)
    if not type(keys0)==str:
        print "Error - DataReader(Py): keyword",keys0,"must be a string!"
        return
    emptyarray=(keys0[0:5]=='empty')
    if emptyarray: keys0=keys0[5:]
    if keys0 in ["Time","Frequency","Fx","Voltage","FFT","CalFFT","TimeLag"]: #these are the data vectors
        if keys0=="Time": ary=hArray(float,dimensions=[self.blocksize],name="Time",units="s")
        if keys0=="Frequency": ary=hArray(float,dimensions=[self.fftLength],name="Frequency",units="Hz")
        if keys0=="Fx": ary=hArray(float,dimensions=[self.nofSelectedAntennas,self.blocksize],name="E-Field",units="ADC Counts")
        if keys0=="Voltage": ary=hArray(float,dimensions=[self.nofSelectedAntennas,self.blocksize],name="Voltage",units="V")
        if keys0=="FFT": ary=hArray(complex,dimensions=[self.nofSelectedAntennas,self.fftLength],name="FFT(E-Field)",units="ar.u.")
        if keys0=="CalFFT": ary=hArray(complex,dimensions=[self.nofSelectedAntennas,self.fftLength],name="CalFFT(E-Field)",units="ar.u.")
        if keys0=="TimeLag": ary=hArray(float,dimensions=[self.blocksize],name="Time Lag",units="s")
        if not emptyarray:
            if keys0=="TimeLag": ary.fillrange(-self.blocksize/2*self.sampleInterval,self.sampleInterval)
            else: ary.read(self,keys0)
        return ary
    else: return hFileGetParameter(self,keys0)

def DataReader_set(self,key,val):
    """
    datafile.set("key",value) -> set the appropriate header parameter

    Method to set header information in the DataReader and
    put it into attributes of the DataReader object.
    """
    ok=hFileSetParameter(self,key,val)
    self.getHeaderVariables()
    return self

def DataReader_setitem(self,*keyval):
    """
    datafile["key"]=value -> set the appropriate header parameter
    datafile[["key1","key2",...]]=[value1, value2,...] -> set multiple  header parameters

    Method to set header information in the DataReader and
    put it into attributes of the DataReader object.
    """
    if len(keyval)!=2:
        print "Wrong NUmber of Argument for DataReader['key']=value!"
        return
    key=keyval[0]
    val=keyval[1]
    if (type(key)==tuple):
        for k,v in zip(key,val):
            self.set(k,v)
    else: self.set(key,val)

def crfile(filename):
    """
    file=crfile("FILENAME.h5") -> DataReader Object

    This is a simple class to interface with the LOFAR CRTOOLS
    datareader class. It deals with LOFAR and LOEPS data alike. You
    can read data vectors, read or set parameters and get summary of the contents.
    """
    cfile=hFileOpen(filename)
    cfile.filename=filename
    cfile.getHeaderVariables()
    return cfile

#------------------------------------------------------------------------
# Getting Metadata like Antenna positions or instrumental delays
#------------------------------------------------------------------------

def hgetCalData(datafile,keyword):
    obsname=datafile["observatory"]
    if obsname=='LOPES':
        result=hCalTableVector(LOFARSOFT+"/data/lopes/LOPES-CalTable",keyword,datafile["date"],list(datafile["antennaIDs"]))
    else:
        print "ERROR: No caltables for non-LOPES files."
        return
    if keyword=="Position": return hArray(result,dimensions=[datafile["nofAntennas"],3])
    elif keyword=="Delay": return hArray(result,dimensions=[datafile["nofAntennas"]])
    else: return

DataReader.read=hFileRead
DataReader.set=DataReader_set
DataReader.__setitem__=DataReader_setitem
DataReader.__getitem__=DataReader_getitem
DataReader.getHeaderVariables=DataReader_getHeaderVariables
DataReader.__doc__=crfile.__doc__
DataReader.getCalData = hgetCalData
#------------------------------------------------------------------------
# Pypeline Extension, Functions and Algorithms
#------------------------------------------------------------------------

def CheckParameterConformance(data,keys,limits):
    """
    Usage:

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    CheckParameterConformance([Antenna,mean,rms,npeaks,nonGaussianity],{"mean":1,"rms":2,"nonGaussianity":4},qualitycriteria)  ->  ["rms",...]

    Parameters:

    data -  is a list of quality values (i.e. numbers) to check

    keys - a dictionary of fieldnames to be checked and indices
           telling, where in data the field can be found

    limits - a dictionary of fieldnames and limits (lowerlimit,
             upperlimit)

    Checks whether a list of numbers is within a range of limits. The
    limits are provided as a dictionary of fieldnames and tuples, of
    the form FIELDNAME:(LOWERLIMT,UPPERLIMIT). A list of fieldnames is
    returned where the data does not fall within the specified range.

    """
    result=[]
    for k in keys:
        if (data[keys[k]]<limits[k][0]) | (data[keys[k]]>limits[k][1]): result.append(k)
    return result


def CRQualityCheck(limits,datafile=None,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True):
    """
    Usage:

    CRQualityCheck(qualitycriteria,datafile,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True) -> list of antennas failing the limits

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    Will step through all antennas of a file assess the data quality
    and return a list with antennas which have failed the quality
    check and their statistical properties.

    Parameters:


    qualitycriteria - a Python dict with keywords of parameters and limits thereof (lower, upper)

    datafile - Data Reader file object, if none, use values in dataarray and don't read in again

    array - an optional data storage array to read in the data

    maxblocksize - The algorithms takes by default the first and last
    quarter of a file but not more samples than given in this
    paramter.

    nsigma - determines for the peak counting algorithm the threshold
    for peak detection in standard deviations

    verbose - sets whether or not to print additional information
    """
#Initialize some parameters
    if not datafile==None:
        nAntennas=datafile.get("nofSelectedAntennas")
        selected_antennas=datafile.get("selectedAntennas")
        filesize=datafile.get("filesize")
        blocksize=min(filesize/4,maxblocksize)
        datafile.set("blocksize",blocksize)
        nBlocks=filesize/blocksize;
        blocklist=range(nBlocks/4)+range(3*nBlocks/4,nBlocks)
        if dataarray==None: dataarray=hArray(float,[nAntennas,blocksize])
    else:
        nAntennas=dataarray.getDim()[0]
        blocksize=dataarray.getDim()[1]
        selected_antennas=range(nAntennas)
        blocklist=[0]
#Create the some scratch vectors
    qualityflaglist=[]
#Calculate probabilities to find certain peaks
    probability=funcGaussian(nsigma,1,0) # what is the probability of a 5 sigma peak
    npeaksexpected=probability*blocksize # what is the probability to see such a peak with the blocksize
    npeakserror=sqrt(npeaksexpected) # what is the statisitcal error on that expectation
#Start checking
    if verbose:
        if not datafile==None: print "Quality checking of file ",datafile.filename
        print "Considering",nAntennas," antennas and the Blocks:",blocklist
        print "Blocksize=",blocksize,", nsigma=",nsigma, ", number of peaks expected per block=",npeaksexpected
    for Block in blocklist:
        if verbose:
            print "\nBlock = ", Block
            print "-----------------------------------------------------------------------------------------"
        if not datafile==None: datafile.set("block",Block).read("Voltage",dataarray.vec())
        datamean = dataarray[...].mean()
        datarms = dataarray[...].stddev(datamean)
        datanpeaks = dataarray[...].countgreaterthanabs(datarms*nsigma)
        dataNonGaussianity = Vector(float,nAntennas)
        dataNonGaussianity.sub(datanpeaks,npeaksexpected)
        dataNonGaussianity /= npeakserror
        dataproperties=zip(selected_antennas,datamean,datarms,datanpeaks,dataNonGaussianity)
        noncompliancelist=[]
        for prop in iter(dataproperties):
            noncompliancelist=CheckParameterConformance(prop,{"mean":1,"rms":2,"nonGaussianity":4},limits)
            if noncompliancelist: qualityflaglist.append([prop[0],Block,prop[1:],noncompliancelist])
            if verbose:
                print "Antenna {0:3d}: mean={1: 6.2f}, rms={2:6.1f}, npeaks={3:5d}, nonGaussianity={4: 7.2f}".format(*prop)," ",noncompliancelist
    return qualityflaglist


#qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}
#CRQualityCheck(datafile,qualitycriteria,maxblocksize=65536,nsigma=5,verbose=True)

