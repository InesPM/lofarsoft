# Import module
from math import *
from hftools import *
from pydoc import help as pyhelp
import os,sys,re
LOFARSOFT=os.environ["LOFARSOFT"]

pydocpyfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.py"
pydoctxtfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.tex"

#Read in the doc strings for the functions in hftools
execfile(pydocpyfilename)
f=open(pydoctxtfilename);pycralldocstring=f.read();f.close()

#======================================================================
#  Help Functions
#======================================================================

def all():
    pass

all.__doc__=pycralldocstring

def hhelpstring(func):
    """
    Returns the doc string of a function. Check if the docstring
    contains informations from the CRTOOLS. If so, return only that
    part.
    """
    doc=func.__doc__
    if doc==None: return ""
    match=re.search("^PYCRTOOLS .*",doc,re.MULTILINE)
    if (match):
        predoc=doc[match.start():match.end()]
        doc=re.sub("PYCRTOOLS .*","",doc[match.end():])
        doc = predoc + doc;
    return doc

#    Included to overwrite the pydoc help function.
def help():
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    help(help)


def help(func=help,brief=True):
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help). 

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py 
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    if func==None: func=help
    if (hasattr(func,"__class__")): print "Class: ", func.__class__
    if brief: print hhelpstring(func)
    else: print pyhelp(func)
    methods=dir(func)
    methods2=[]
    for m in methods:
        if not ((m.find("_")==0) | (m.find("func_")==0)): methods2.append(m)
    if len(methods2)>0:
        print "\nAvailable methods: ",
        for m in methods2[0:-1]:
            print m+", ",
        print methods2[-1]
        if (hasattr(func,"__name__")):
            print "\nType help("+func.__name__+".METHOD) to get more info on the individual methods."
        else:
            print "\nType help(func.METHOD) to get more info on the individual methods."
                        

#======================================================================
#  Pretty Printing
#======================================================================

#Some definitons to make pretty (and short) output of vectors
def VecToString(self,maxlen=10):
    veclen=len(self)
    stringval=""
    if veclen>0:
        stringval+=str(self[0])
    for i in range(1,min(len(self),maxlen)):
        stringval+=","+str(self[i])
    if veclen>maxlen:
        stringval+=",..."
    return stringval


def VecToPrintString(self,maxlen=10):
    s=typename(basetype(self))+","
    return "Vec("+s+str(len(self))+")=[" +VecToString(self,maxlen)+"]"

def hArrayToPrintString(self,maxlen=10):
    s=typename(basetype(self))+", "
    loops=""
    if self.loopingMode(): loops="*"
    name=self.getKey("name"); 
    if name=="": name="hArray";
    return name+"("+s+str(self.getDim())+"="+str(len(self))+", ["+str(self.getBegin())+":"+str(self.getEnd())+"]"+loops+") -> [" +VecToString(self.getVector()[self.getBegin():self.getEnd()],maxlen)+"]"

#========================================================================
# Adding multi-dimensional array capabilities to vector class
#========================================================================

def multiply_list(l):
    """
    multiply_list([n1,n2,...]) -> n1*n2*n3 ....

    Multiplies all elements of a list with each other and returns the
    result.
    """
    return reduce(lambda x,y:x*y,l)

def hVector_list(self):
    """
    vec.list() -> [x1,x2,x3, ...]

    Retrieve the STL vector as a python list.
    """
    return list(self)

def hVector_val(self):
    """
    vec.val() -> a             : if length == 1 
    vec.val() -> [a,b,c,...]   : if length > 1 

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    if len(self)==1: return self[0]
    else: return list(self)
    
def hVector_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) 
    
    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list. 
    """
    newsize=multiply_list(dimensions_list) # dim1*dim2*...*dimN
    if (not len(self)==newsize): self.resize(newsize)
    self.dimension=dimensions_list
    self.ndim=len(dimensions_list)
    return self

def hVector_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    if self.ndim>0: return self.dimension
    else: return len(self)

def hVector_elem(self,n):
    """
    self.elem(n) -> nth element of the first dimension of the array

    """
    if self.ndim>1: # this actually is a multi-dim array
        if type(n)==int: #select just one element
            size=multiply_list(self.dimension[1:])
            return self[n*size:(n+1)*size]
        else:
            print "elem: index unknown ..."
            return self
    else:
        return self[n]


def extendflat(self,l):
    """
    vector.extendflat([[e1-1,e1-2,...],[e2-1,e2-2,...],..]) -> [e1-1,e1-2,...,e2-1,e2-2,...]

    Appending all elements in a list of lists to a one-dimensional
    vector with a flat dat structure (just 1D).
    """
    map(lambda x:self.extend(x),l)


def hArray_newreference(self):
    """
    array.newreference() -> copy of array referencing the same vector

    Will make an exact copy of the array, and reference the same
    vector. Hence the new array can be assigned a new slice, but will
    still access the same underlying vector in memory.
    """
    return self.shared_copy()

def hArray_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) -> hArray with new dimensions
     
    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list. 
    """
    apply(self.setDimensions,dimensions_list)
    return self;

def hArray_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)
    
    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    return list(self.getDimensions())

def hArray_return_slice_start(val): 
    """ Reduces a slice to its start value"""
    if (val==Ellipsis):
        return 0
    elif type(val)==slice:
         if (val.start == None): return 0
         return val.start
    elif type(val)==list:
        return val[0]
    else:
        return val

def hArray_return_slice_end(val): 
    """ Reduces a slice to its end value"""
    if val==Ellipsis: 
        return -1
    elif type(val)==slice:
        return hNone2Value(val.stop,-1)
    elif type(val)==list:
        return val[-1]
    else:
        return val+1

def hNone2Value(none,defval): 
    """
    Returns a default value if the the first input is the None object,
    otherwise return the value of the first argument.
    """
    if none==None: return defval
    else: return none

def hArray_vec(self):
    """
    array.vec() -> Vector([x1,x2,x3, ...])

    Retrieve the currently selected slice from the stored vector. If
    the entire vector is to be returned a reference to the internal
    data vector is returned. Otherwise, if a slice is active, a copy
    of that slice is returned. Use getVector() to ensure you always
    get only a reference.
    """
    beg=self.getBegin(); end=self.getEnd()
    if ((beg==0 )& (end==len(self))): return self.getVector()
    else: return self.getVector()[beg:end]

def hArray_list(self):
    """
    array.list() -> [x1,x2,x3, ...]

    Retrieve the currently selected slice from the stored vector as a
    python list.
    """
    return list(self.getVector()[self.getBegin():self.getEnd()])

def hArray_new(self):
    """
    ary.new() -> new_array

    Create a new array of the same type and dimensions
    """
    return hArray(basetype(self),self)

def hArray_val(self):
    """
    ary.val() -> a             : if length == 1 
    ary.val() -> [a,b,c,...]   : if length > 1 

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    return self.vec().val()

def hArray_copy_resize(self,ary):
    """
    Retrieve the first element of the currently selected slice from the stored vector.
    """
    ary.resize(len(self))
    ary.copy(self)
    return ary

def hArray_getitem(self,dimlist):
    """
    self[n1,n2,n3]-> return Element with these indices
    
    Retrieves a copy of the array with the internal slices set to reflect ...
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions. 
    """
    if not type(dimlist)==tuple: dimlist=(dimlist,)
    ary=hArray(self)
    lastelement=dimlist[-1]
    dimliststarts=Vector(map(hArray_return_slice_start,dimlist))
    if (lastelement==Ellipsis):   # looping is requested
        if len(dimlist)>=2:      # but ...
            if not type(dimlist[-2])==int:  # .. there is a slice or list preceding the ellipsis, over which to loop
                lastelement=dimlist[-2]
        if type(lastelement)==slice: ary.loop(dimliststarts[0:-2],hNone2Value(lastelement.start,0),hNone2Value(lastelement.stop,-1),hNone2Value(lastelement.step,1))
        elif lastelement==Ellipsis: ary.loop(dimliststarts[0:-1],0,-1,1)
        elif type(lastelement)==list: ary.loop(dimliststarts[0:-2],Vector(lastelement))
    elif type(lastelement) in [slice,list]: #Non-looping slice
        ary.setSliceVector(dimliststarts[0:-1],hArray_return_slice_start(lastelement),hArray_return_slice_end(lastelement))
    else: # normal integer index
        ary.setSliceVector(dimliststarts[0:-1],lastelement,lastelement+1)
    return ary;

def hArray_setitem(self,dims,fill):
    """
    vec[n1,n2,..] = [0,1,2] -> set slice of array to input vector/value
    
    """
    if (type(fill)) in [list,tuple]: fill=hArray(fill)
    return hFill(hArray_getitem(self,dims),fill)
 
#======================================================================
#  Define Lists of hArray and Vector Types that we will use 
#======================================================================

hBaseTypes=[int,float,complex,bool,str]
hBaseNames=["Int","Float","Complex","Bool","String"]
hBaseNamesPy=["int","float","complex","bool","str"]

hRealTypes=[int,float]
hComplexTypes=[complex]
hNumericalTypes=hRealTypes+hComplexTypes
hOtherTypes=[bool,str]

#------------------------------------------------------------

hVectorBaseTypeDictionary={}
hArrayBaseTypeDictionary={}
hArrayTypeDictionary={}
hVectorTypeDictionary={}
hTypeDictionary={}
hTypeNamesDictionary={}
hAllVectorTypes=[]
hAllArrayTypes=[]
for i in range(len(hBaseTypes)):
    btype=hBaseTypes[i]
    vtype=eval(hBaseNames[i]+"Vec")
    atype=eval(hBaseNames[i]+"Array")
    hAllVectorTypes.append(vtype)
    hAllArrayTypes.append(atype)
    hVectorBaseTypeDictionary[vtype]=btype
    hArrayBaseTypeDictionary[atype]=btype
    hVectorTypeDictionary[btype]=vtype
    hArrayTypeDictionary[btype]=atype
    hTypeDictionary[btype]=btype
    hTypeNamesDictionary[btype]=hBaseNamesPy[i]

hAllListTypes=hAllVectorTypes+[list,tuple]


basetypedictionary=dict(zip(hVectorBaseTypeDictionary.keys()+hArrayBaseTypeDictionary.keys()+hTypeDictionary.keys(),hVectorBaseTypeDictionary.values()+hArrayBaseTypeDictionary.values()+hTypeDictionary.values()))

def type2vector(basetype):
    """type2vector(float) -> Vec(0)=[]

    Creates a vector with elements of type 'basetype'. Returns None if
    a vector of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hVectorTypeDictionary[basetype]()
    else: return None

def type2array(basetype):
    """type2array(float) -> Vec(0)=[]

    Creates an array with elements of type 'basetype'. Returns None if
    an array of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hArrayTypeDictionary[basetype]()
    else: return None

def basetype(vec_or_array): 
    """
    basetype(IntVec) -> <type 'int'>
    basetype(FloatArray) -> <type 'float'>
    basetype(complex) -> <type 'complex'>
    
    Returns the basic type contained in the vector or array. Input can be either a vector, an array, or a type thereof.
    """
    t=type(vec_or_array)
    if t==type: t=vec_or_array
    return basetypedictionary[t]

def typename(btype): 
    """
    basetype(float) -> "float"    
    basetype(str) -> "str"
    
    Returns the name of the base type as a short string.
    """
    t=type(btype)
    if t==type: t=btype
    return hTypeNamesDictionary[t]


def ishArray(ary): 
    """
    ishArray(array) -> True or False

    Returns true if the argument is one of the hArray arrays, i.e. those listed in hAllVectorTypes.
    """
    return type(ary) in hAllArrayTypes

def isVector(vec): 
    """
    isVector(vec) -> True or False

    Returns true if the argument is one of the standard c++ vectors i.e. those liste in hAllVectorTypes.
    """
    return type(vec) in hAllVectorTypes

hRealVectorTypes=map(lambda t:hVectorTypeDictionary[t],hRealTypes)
hComplexVectorTypes=map(lambda t:hVectorTypeDictionary[t],hComplexTypes)
hNumericalVectorTypes=map(lambda t:hVectorTypeDictionary[t],hNumericalTypes)
hOtherVectorTypes=map(lambda t:hVectorTypeDictionary[t],hOtherTypes)

hRealArrayTypes=map(lambda t:hArrayTypeDictionary[t],hRealTypes)
hComplexArrayTypes=map(lambda t:hArrayTypeDictionary[t],hComplexTypes)
hNumericalArrayTypes=map(lambda t:hArrayTypeDictionary[t],hNumericalTypes)
hOtherArrayTypes=map(lambda t:hArrayTypeDictionary[t],hOtherTypes)

hRealContainerTypes=hRealVectorTypes+hRealArrayTypes
hComplexContainerTypes=hComplexVectorTypes+hComplexArrayTypes
hNumericalContainerTypes=hNumericalVectorTypes+hNumericalArrayTypes
hOtherContainerTypes=hOtherVectorTypes+hOtherArrayTypes
hAllContainerTypes=hAllVectorTypes+hAllArrayTypes

#======================================================================
#  Vector Methods/Attributes
#======================================================================

"""
Here we add the functions defined in the hftools.cc as
methods/attributes to the (STL) vector classes in python.
"""

Vectordoc= """
A number of vector types are provided: bool, int, float, complex, and
str.

This vector is subscriptable and sliceable, using the
standard python syntax, e.g. v[1:3], or v[2]=0.

To creat a vector most efficently, use the original vector
constructors: BoolVec() - IntVec() - FloatVec() - ComplexVec() -
StringVec()

There is also a more convenient constructor function "Vector" that is
useful for interactive use: 

Vector(Type) , where Type=float,int,complex,str, or bool
Vector(Type,size)
Vector(Type,size,fill) 
Vector(list), Vector(tuple)
Vector() defaults to a float vector

Use the resize method to allocate more or less memory.

Some of the basic arithmetic is available in an intuitve way, e.g.,
vec+1, vec1+vec2, vec+=vec2).

See the tutorial (tutorial.py) for more details.
"""

Arraydoc= """

hArray(Type=int,dimensions=[n1,n2,n3...],fill=None) -> IntArray

hArray(Type=float,dimensions=[n1,n2,n3...],fill=None) -> FloatArray

....

While the basic underlying data structures are plain STL vectors, in
many cases, however, one has to deal with multi-dimensional data. For
this case we introduce a new wrapper class, named hArrays, that
mimicks a multi-dimensional array, but still operates on an underlying
vector with essentially a flat, horizontal data structure. Given that
a major concern is to minimize duplication of large data structures,
the array class will share memory with its associated vector and also
with arrays that are derived from it. Explicit copying will have to be
done in order to avoid this. Access to various dimensions (rows,
columns, etc...) is done via slices that need to be contiguous in
memory! Since the array is vector-based, all methods defined for
vectors are also inherited by hArrays and can be applied to slices or
even automatically loop over multiple slices (e.g., rows or columns).

An array is defined using the hArray function. This is a constructor
function and not a class of its own. It will return array classes of
different types, such as IntArray, FloatArray, ComplexArray,
StringArray, BoolArray, referring to the different data types they
contain. As for vectors, each array can only contain one type of data.

where Type can be a Python type, a Python list/tuple (where the first
element determines the type), an STL vector, or another hArray.

Dimensions are given as a list of the form [dim1,dim2,dim3, ...]. The
size of the underlying vector will automatically be resized to
dim1*dim2*dim3* ... to be able to contain all elements. Alternatively,
one can provide another array, who's dimensions will be copied.

The array can be filled with an initialization values that can be
either a single value, a list, a tuple, or an STL vector of the same
type.
"""

IntArray.__doc__="c++ hftools array of type 'int'\n"+Arraydoc 
FloatArray.__doc__="c++ hftools array of type 'float'\n"+Arraydoc 
StringArray.__doc__="c++ hftools array of type 'str'\n"+Arraydoc 
BoolArray.__doc__="c++ hftools array of type 'bool'\n"+Arraydoc 
ComplexArray.__doc__="c++ hftools array of type 'complex'\n"+Arraydoc 

IntVec.__doc__="c++ standard template library (STL) vector of type 'int'\n"+Vectordoc 
FloatVec.__doc__="c++ standard template library (STL) vector of type 'float'\n"+Vectordoc 
StringVec.__doc__="c++ standard template library (STL) vector of type 'str'\n"+Vectordoc 
BoolVec.__doc__="c++ standard template library (STL) vector of type 'bool'\n"+Vectordoc 
ComplexVec.__doc__="c++ standard template library (STL) vector of type 'complex'\n"+Vectordoc 

IntVec.__name__="IntVec"
FloatVec.__name__="FloatVec"
BoolVec.__name__="BoolVec"
ComplexVec.__name__="ComplexVec"
StringVec.__name__="StringVec"

#Operator Overloading - basic arithmetic 

# Operator:  +=
def Vec_iadd(vec1,vec2):
    """
    Provides the += operator for adding two vectors in place.
    vec1+=vec2 will add all elements in vec2 to the corresponding
    elements in vec1 and store the result in vec1.
    """
    hAdd(vec1,vec2)
    return vec1

# Operator:  -=
def Vec_isub(vec1,vec2):
    "Provides the -= operator for addig two vectors in place. \
    vec1-=vec2 will subtract all elements in vec2 from the corresponding elements in vec1\
    and store the result in vec1."
    hSub(vec1,vec2)
    return vec1

# Operator:  /=
def Vec_idiv(vec1,vec2):
    "Provides the /= operator for addig two vectors in place. \
    vec1/=vec2 will divide all elements in vec1 by the corresponding elements in vec2\
    and store the result in vec1."
    hDiv(vec1,vec2)
    return vec1

# Operator:  *=
def Vec_imul(vec1,vec2):
    "Provides the *= operator for addig two vectors in place. \
    vec1=vec2 will multiply all elements in vec1 with the corresponding elements in vec2\
    and store the result in vec1."
    hMul(vec1,vec2)
    return vec1

# Operator:  +
def Vec_add(vec1,val):
    "Provides the + operator for adding two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hAdd(vecout,vec1,val)
    return vecout

# Operator:  -
def Vec_sub(vec1,val):
    "Provides the - operator for subtracting two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hSub(vecout,vec1,val)
    return vecout

# Operator:  *
def Vec_mul(vec1,val):
    "Provides the * operator for multiplying two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hMul(vecout,vec1,val)
    return vecout

# Operator:  /
def Vec_div(vec1,val):
    "Provides the / operator for dividing two vectors or a vector by a scalar. The result will be a new vector."
    vecout=vec1.new()
    hDiv(vecout,vec1,val)
    return vecout


#Fourier Transforms 
setattr(FloatVec,"fft",hFFT)
setattr(FloatArray,"fft",hFFT)

for v in hAllArrayTypes:
    setattr(v,"__repr__",hArrayToPrintString)
    setattr(v,"setDim",hArray_setDim)
    setattr(v,"getDim",hArray_getDim)
    setattr(v,"vec",hArray_vec)
    setattr(v,"val",hArray_val)
    setattr(v,"new",hArray_new)
    setattr(v,"list",hArray_list)
    setattr(v,"copy_resize",hArray_copy_resize)
    setattr(v,"newreference",hArray_newreference)
    setattr(v,"__getitem__",hArray_getitem)
    setattr(v,"__setitem__",hArray_setitem)

for v in hAllVectorTypes:
    setattr(v,"__repr__",VecToPrintString)
    setattr(v,"extendflat",extendflat)
    setattr(v,"setDim",hVector_setDim)
    setattr(v,"getDim",hVector_getDim)
    setattr(v,"elem",hVector_elem)
    setattr(v,"val",hVector_val)
    setattr(v,"list",hVector_list)
    setattr(v,"dimension",[])
    setattr(v,"ndim",0)
    for s in ["hResize","hNew"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hAllContainerTypes:
    for s in ["hFill","hCopy","hSort"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hRealContainerTypes:
    for s in ["hMean","hStdDev","hDownsample","hNegate","hNorm","hNormalize","hAcos","hAsin","hAtan","hCeil","hFloor","hFindGreaterThan","hFindGreaterEqual","hFindGreaterThanAbs","hFindGreaterEqualAbs","hFindLessThan","hFindLessEqual","hFindLessThanAbs","hFindLessEqualAbs","hCountGreaterThan","hCountGreaterEqual","hCountGreaterThanAbs","hCountGreaterEqualAbs","hCountLessThan","hCountLessEqual","hCountLessThanAbs","hCountLessEqualAbs"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hComplexContainerTypes:
    for s in ["hSpectralPower","hArg","hImag","hNorm","hReal","hConj","hCrossCorrelateComplex","hInvFFT"]:
        setattr(v,s[1:].lower(),eval(s))

for v in hNumericalContainerTypes:
    setattr(v,"__add__",Vec_add)
    setattr(v,"__sub__",Vec_sub)
    setattr(v,"__div__",Vec_div)
    setattr(v,"__mul__",Vec_mul)
    setattr(v,"__iadd__",Vec_iadd)
    setattr(v,"__imul__",Vec_imul)
    setattr(v,"__idiv__",Vec_idiv)
    setattr(v,"__isub__",Vec_isub)
    for s in ["hAbs","hConvert","hMul","hDiv","hSub","hAdd","hMulAdd","hDivAdd","hSubAdd","hAddAdd","hCos","hCosh","hExp","hLog","hLog10","hSin","hSinh","hSqrt","hSquare","hTan","hTanh","hSum","hMulSum","hRandom","hSortMedian","hMedian","hFindLowerBound"]:
        setattr(v,s[1:].lower(),eval(s))

#========================================================================
# Convenience Vector Constructor
#========================================================================

def Vector(Type=float,size=-1,fill=None):
    """
    The basic Boost Python STL vector constructor takes no arguments and
    hence is a litte cumbersome to use. Here we provide a wrapper function
    that is useful for interactive use. If speed is of the essence, use
    the original vector constructors: BoolVec(), IntVec(), FloatVec(),
    ComplexVec(), StringVec()
    
    Usage:

    Vector(Type) -  will create an empty vector of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Vector(Type,size) - will create an vector of type "Type", with length "size".

    Vector(Type,size,fill) - will create an vector of type "Type", with length
    "size" and initialized with the value "fill"

    Vector([1,2,3,...]) or Vector((1,2,3,...)) - if a list or a tuple is
    provided as first argument then a vector is created of the type of the
    first element in the list or tuple (here an integer) and filled with
    the contents of the list or tuple.

    Vector() defaults to a float vector.

    Note, that size and fill take precedence over the list and tuple
    input. Hence if you create a vector with Vector([1,2,3],size=2) it
    will contain only [1,2]. Vector([1,2,3],size=2,fill=4) will give
    [4,4].
    """
    vtype=Type
    if (type(vtype) in hAllArrayTypes):  # hArrayClass
        vtype=basetype(Type)
        vec=Vector(Type.getVector())
    elif (type(vtype) in hAllListTypes):  #List or Vector 
        vtype=type(Type[0])
        vec=type2vector(vtype)
        vec.extend(Type)
    else:
        vec=type2vector(vtype)
    vec.type=vtype
    if (size>=0): vec.resize(size)
    if type(fill) in [tuple,list]: fill=Vector(fill)
    if type(fill) in hAllArrayTypes: fill=fill.vec()
    if (not fill==None): 
        vec.fill(fill)
    return vec

#======================================================================
#  hArray Class and Vector Methods/Attributes
#======================================================================

def hArray(Type=float,dimensions=None,fill=None,name=None):
    """
    Python convenience constructor function for hArrays. If speed is
    of the essence, use the original vector constructors: BoolArray(),
    IntArray(), FloatArray(), ComplexArray(), StringArray()
    
    Usage:

    hArray(Type=float,dimensions=[n1,n2,n3...],fill=None) -> FloatArray

    Array(Type) -  will create an empty array of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Array([1,2,3,...]) or Array((1,2,3,...)) - if a list or a tuple is
    provided as first argument then an array is created of the type of
    the first element in the list or tuple (here an integer) and
    filled with the contents of the list or tuple.

    Array(vec) - will create an array of the type of a vector and use
    the vector as its underlying memory storage. To copy the value,
    use the fill parameter described below.

    Array(Type,dimension) - will create an array of type "Type",
    specifiying its dimensions. Input for dimensions can be a list or
    a another array (who's dimensions are coopied).
    
    Array(Type,dimension,fill) - same as above but fill the array with
    particular values. Input can be a single value, a list, a vector,
    or another array.

    Array() defaults to a float array.

    Note, that dimension and fill take precedence over the list and tuple
    input. Hence if you create a array with Array([1,2,3],dimension=[2]) it
    will contain only [1,2]. Array([1,2,3],dimension=[2],fill=4) will give
    [4,4].
    """
    if isVector(Type):  #Make a new array with refernece to the input vector
        ary=type2array(basetype(Type))
        ary.stored_vector=Type
        ary.setVector(ary.stored_vector)
    elif ishArray(Type):  # Just make a copy with reference to same vector
        ary=Type.newreference()
    else: # Create a new vector
        vec=Vector(Type=Type)
        ary=type2array(basetype(vec))
        ary.stored_vector=vec
        ary.setVector(ary.stored_vector)
    if (type(dimensions) in [list,tuple,IntVec]): ary.setDim(dimensions)
    if (type(dimensions) in hAllArrayTypes): ary.setDim(dimensions.getDim())
    if not (fill == None): 
        if type(fill) in hAllVectorTypes: ary.vec().fill(fill)
        if type(fill) in [tuple,list]: ary.vec().fill(Vector(fill))
        else: ary.fill(fill)
    if type(name)==str: ary.setKey("name",name);
    return ary

hArray.__doc__=Arraydoc

#------------------------------------------------------------------------
# cr DataReader Class
#------------------------------------------------------------------------

def crfile(filename):
    """
    file=crfile("FILENAME.h5") -> DataReader Object

    This is a simple class to interface with the LOFAR CRTOOLS
    datareader class. It deals with LOFAR and LOEPS data alike. You
    can read data vectors, read or set parameters and get summary of the contents.
    """
    file=hFileOpen(filename)
    file.filename=filename
    return file

DataReader.read=hFileRead
DataReader.__doc__=crfile.__doc__

#------------------------------------------------------------------------
# Pypeline Extension, Functions and Algorithms
#------------------------------------------------------------------------

def CheckParameterConformance(data,keys,limits):
    """
    Usage:

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    CheckParameterConformance([Antenna,mean,rms,npeaks,nonGaussianity],{"mean":1,"rms":2,"nonGaussianity":4},qualitycriteria)  ->  ["rms",...]

    Parameters:

    data -  is a list of quality values (i.e. numbers) to check

    keys - a dictionary of fieldnames to be checked and indices
           telling, where in data the field can be found

    limits - a dictionary of fieldnames and limits (lowerlimit,
             upperlimit)

    Checks whether a list of numbers is within a range of limits. The
    limits are provided as a dictionary of fieldnames and tuples, of
    the form FIELDNAME:(LOWERLIMT,UPPERLIMIT). A list of fieldnames is
    returned where the data does not fall within the specified range.

    """
    result=[]
    for k in keys:
        if (data[keys[k]]<limits[k][0]) | (data[keys[k]]>limits[k][1]): result.append(k)
    return result


def CRQualityCheck(limits,file=None,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True):
    """
    Usage:

    CRQualityCheck(qualitycriteria,file,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True) -> list of antennas failing the limits

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    Will step through all antennas of a file assess the data quality
    and return a list with antennas which have failed the quality
    check and their statistical properties.

    Parameters:


    qualitycriteria - a Python dict with keywords of parameters and limits thereof (lower, upper)

    file - Data Reader file object, if none, use values in dataarray and don't read in again

    array - an optional data storage array to read in the data

    maxblocksize - The algorithms takes by default the first and last
    quarter of a file but not more samples than given in this
    paramter.

    nsigma - determines for the peak counting algorithm the threshold
    for peak detection in standard deviations

    verbose - sets whether or not to print additional information
    """
#Initialize some parameters
    if not file==None:
        nAntennas=file.get("nofSelectedAntennas")
        selected_antennas=file.get("selectedAntennas")
        filesize=file.get("filesize")
        blocksize=min(filesize/4,maxblocksize)
        file.set("blocksize",blocksize)
        nBlocks=filesize/blocksize; 
        blocklist=range(nBlocks/4)+range(3*nBlocks/4,nBlocks)
        if dataarray==None: dataarray=hArray(float,[nAntennas,blocksize])
    else:
        nAntennas=dataarray.getDim()[0]
        blocksize=dataarray.getDim()[1]
        selected_antennas=range(nAntennas)
        blocklist=[0]
#Create the some scratch vectors
    qualityflaglist=[]
#Calculate probabilities to find certain peaks
    probability=funcGaussian(nsigma,1,0) # what is the probability of a 5 sigma peak
    npeaksexpected=probability*blocksize # what is the probability to see such a peak with the blocksize
    npeakserror=sqrt(npeaksexpected) # what is the statisitcal error on that expectation
#Start checking
    if verbose:
        if not file==None: print "Quality checking of file ",file.filename
        print "Considering",nAntennas," antennas and the Blocks:",blocklist
        print "Blocksize=",blocksize,", nsigma=",nsigma, ", number of peaks expected per block=",npeaksexpected
    for Block in blocklist:
        if verbose:
            print "\nBlock = ", Block
            print "-----------------------------------------------------------------------------------------"
        if not file==None: file.set("block",Block).read("Voltage",dataarray.vec())
        datamean = dataarray[...].mean()
        datarms = dataarray[...].stddev(datamean)
        datanpeaks = dataarray[...].countgreaterthanabs(datarms*nsigma)
        dataNonGaussianity = Vector(float,nAntennas)
        dataNonGaussianity.sub(datanpeaks,npeaksexpected)
        dataNonGaussianity /= npeakserror
        dataproperties=zip(selected_antennas,datamean,datarms,datanpeaks,dataNonGaussianity)
        noncompliancelist=[]
        for prop in iter(dataproperties): 
            noncompliancelist=CheckParameterConformance(prop,{"mean":1,"rms":2,"nonGaussianity":4},limits)
            if noncompliancelist: qualityflaglist.append([prop[0],Block,prop[1:],noncompliancelist])
            if verbose:
                print "Antenna {0:3d}: mean={1: 6.2f}, rms={2:6.1f}, npeaks={3:5d}, nonGaussianity={4: 7.2f}".format(*prop)," ",noncompliancelist
    return qualityflaglist


#qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}
#CRQualityCheck(file,qualitycriteria,maxblocksize=65536,nsigma=5,verbose=True)
