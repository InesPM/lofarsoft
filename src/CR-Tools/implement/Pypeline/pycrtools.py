# Import module

import pdb
#pdb.set_trace()
#debugon=False


from math import *
from hftools import *
from pydoc import help as pyhelp
import os,sys,re
import matplotlib.pyplot as plt
import time as time
import numpy as np

LOFARSOFT=os.environ["LOFARSOFT"]
pydocpyfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.py"
pydoctxtfilename=LOFARSOFT +"/build/cr/implement/Pypeline/hftools.doc.tex"

filename_lofar_onesecond=LOFARSOFT+"/data/lofar/RS307C-readfullsecond.h5"
filename_lofar_onesecond=LOFARSOFT+"/data/lofar/RS307C-readfullsecondtbb1.h5"
filename_lopes_test=LOFARSOFT+"/data/lopes/test.event"
filename_lofar=LOFARSOFT+"/data/lofar/rw_20080701_162002_0109.h5"
filename_lopes=LOFARSOFT+"/data/lopes/example.event"

DEFAULTDATAFILE=filename_lopes


#Read in the doc strings for the functions in hftools
execfile(pydocpyfilename)
f=open(pydoctxtfilename);pycralldocstring=f.read();f.close()

#======================================================================
#  Help Functions
#======================================================================

def all():
    pass

all.__doc__=pycralldocstring

def hhelpstring(func):
    """
    Returns the doc string of a function. Check if the docstring
    contains informations from the CRTOOLS. If so, return only that
    part.
    """
    doc=func.__doc__
    if doc==None: return ""
    match=re.search("^PYCRTOOLS .*",doc,re.MULTILINE)
    if (match):
        predoc=doc[match.start():match.end()]
        doc=re.sub("PYCRTOOLS .*","",doc[match.end():])
        doc = predoc + doc;
    return doc

#    Included to overwrite the pydoc help function.
def help():
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the uncerlying c++
    code (if the function was wrapped from c++).
    """
    help(help)


def help(func=help,brief=True):
    """
    This is the basic help function for the PyCRTools
    environment. This message is generated by help() or help(help).

    To get information on a specific function or method type
    help(func).

    For a listing of all available functions type help(all).

    Look at the file
    $LOFARSOFT/src/CR-Tools/implement/Pypeline/tutorial.py
    to get a more basic introduction to the pycrtools.

    With "help(func,brief=False)" or "help(func,False)" you get a more
    extensive listing which includeds references to the underlying c++
    code (if the function was wrapped from c++).
    """
    if func==None: func=help
    if (hasattr(func,"__class__")): print "Class: ", func.__class__
    if brief: print hhelpstring(func)
    else: print pyhelp(func)
    methods=dir(func)
    methods2=[]
    for m in methods:
        if not ((m.find("_")==0) | (m.find("func_")==0) | (m.find("im_")==0)): methods2.append(m)
    if len(methods2)>0:
        print "\nAvailable methods: ",
        for m in methods2[0:-1]:
            print m+", ",
        print methods2[-1]
        if (hasattr(func,"__name__")):
            print "\nType help("+func.__name__+".METHOD) to get more info on the individual methods."
        else:
            print "\nType help(func.METHOD) to get more info on the individual methods."


#======================================================================
#  Pretty Printing
#======================================================================

#Some definitons to make pretty (and short) output of vectors
def VecToString(self,maxlen=10):
    veclen=len(self)
    stringval=""
    if veclen>0:
        stringval+=str(self[0])
    for i in range(1,min(len(self),maxlen)):
        stringval+=","+str(self[i])
    if veclen>maxlen:
        stringval+=",..."
    return stringval


def VecToPrintString(self,maxlen=5):
    s=typename(basetype(self))+","
    return "Vec("+s+str(len(self))+")=[" +VecToString(self,maxlen)+"]"

def hArrayToPrintString(self,maxlen=5):
    s=typename(basetype(self))+", "
    loops=""
    if self.loopingMode(): loops="*"
    name=self.getKey("name");
    if name=="": name="hArray";
    return name+"("+s+str(self.getDim())+"="+str(len(self))+", ["+str(self.getBegin())+":"+str(self.getEnd())+"]"+loops+") -> [" +VecToString(self.getVector()[self.getBegin():self.getEnd()],maxlen)+"]"

def hArray_repr(self,maxlen=8,long=True):
    loops=""
    if self.loopingMode(): loops="*"
    name=self.getKey("name")
    if not name=="": name=', name="'+name+'"'
    s="hArray("+hTypeNamesDictionary[basetype(self)]
    if long:
        s+=","+str(list(self.getDim()))+name+") # len="+str(len(self))+", slice=["+str(self.getBegin())+":"+str(self.getEnd())+"]"+loops+", vec -> [" +VecToString(self.getVector()[self.getBegin():self.getEnd()],maxlen)+"]"
    else:
        s+=")"
    return s

#========================================================================
# Adding multi-dimensional array capabilities to vector class
#========================================================================

def multiply_list(l):
    """
    multiply_list([n1,n2,...]) -> n1*n2*n3 ....

    Multiplies all elements of a list with each other and returns the
    result.
    """
    return reduce(lambda x,y:x*y,l)

def hVector_list(self):
    """
    vec.list() -> [x1,x2,x3, ...]

    Retrieve the STL vector as a python list.
    """
    return list(self)

def hVector_val(self):
    """
    vec.val() -> a             : if length == 1
    vec.val() -> [a,b,c,...]   : if length > 1

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    if len(self)==1: return self[0]
    else: return list(self)

def hVector_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN])

    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list.
    """
    newsize=multiply_list(dimensions_list) # dim1*dim2*...*dimN
    if (not len(self)==newsize): self.resize(newsize)
    self.dimension=dimensions_list
    self.ndim=len(dimensions_list)
    return self

def hVector_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)

    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    if self.ndim>0: return self.dimension
    else: return len(self)

def hVector_elem(self,n):
    """
    self.elem(n) -> nth element of the first dimension of the array

    """
    if self.ndim>1: # this actually is a multi-dim array
        if type(n)==int: #select just one element
            size=multiply_list(self.dimension[1:])
            return self[n*size:(n+1)*size]
        else:
            print "elem: index unknown ..."
            return self
    else:
        return self[n]

def hVector_vec(self):
    """
     vector.vec() -> vector Convenience method that allows one to
    treat hArrays and hVectors in the same way, i.e. using the vec()
    method returns the intrinsic vector for both.
    """
    return self;

def extendflat(self,l):
    """
    vector.extendflat([[e1-1,e1-2,...],[e2-1,e2-2,...],..]) -> [e1-1,e1-2,...,e2-1,e2-2,...]

    Appending all elements in a list of lists to a one-dimensional
    vector with a flat dat structure (just 1D).
    """
    map(lambda x:self.extend(x),l)
    return self

def hArray_none(self):
    """
    array.none() -> None

    Simply retuens the None object. Can be used to suppress unwanted
    output, when an operation returns an array.
    """
    return None

def hArray_newreference(self):
    """
    array.newreference() -> copy of array referencing the same vector

    Will make an exact copy of the array, and reference the same
    vector. Hence the new array can be assigned a new slice, but will
    still access the same underlying vector in memory.
    """
    ary=self.shared_copy()
    ary.par=self.par
    return ary

def hArray_setDim(self,dimensions_list):
    """setDim([dim1,dim2,...,dimN]) -> hArray with new dimensions

    Sets the dimensions of a multidimensonal array, using a list of
    integers as input. Will resize the underlying vector, if necessary
    (i.e., if size has changed). Apart from the size, this does not
    change the underlying data structure, just keeps track on how the
    data is internally organized.

    Index ordering follows c(++) convention: the last index runs
    fastest (i.e. in analogy with normal numbers, where also the last
    digit implies the smallest increment).

    Use array.getDim() to retrieve the dimension list.
    """
    apply(self.setDimensions,dimensions_list)
    return self;

def hArray_getDim(self):
    """
    self.getDim() -> [dim1,dim2,...,dimN] or len(self)

    Retrieves the dimensions of a multidimensonal array as  a list of
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    return list(self.getDimensions())

def hArray_return_slice_start(val):
    """ Reduces a slice to its start value"""
    if val==Ellipsis:
        return 0
    elif type(val)==slice:
         if (val.start == None): return 0
         return val.start
    elif type(val) in hListAndArrayTypes:
        return Vector(val)
    else:
        return val

def hArray_return_slice_end(val):
    """ Reduces a slice to its end value"""
    if val==Ellipsis:
        return -1
    elif type(val)==slice:
        return hNone2Value(val.stop,-1)
    elif type(val) in hListAndArrayTypes:
        return Vector(val)
    else:
        return val+1

def hNone2Value(none,defval):
    """
    Returns a default value if the the first input is the None object,
    otherwise return the value of the first argument.
    """
    if none==None: return defval
    else: return none

def hSliceListElementToNormalValuesStart(s,dim):
    if s==None: return 0
    if s>=0: return s
    else: return s+dim

def hSliceListElementToNormalValuesEnd(s,dim):
    if s==None: return dim
    if s>=0: return s
    else: return s+dim

def hSliceToNormalValues(s,dim):
    """
    Returns a slice object where none and negative numbers are replaced by the appropriate integers, given a dimension (length) dim of the full slice.
    """
    if type(s)==int:
        if s<0: return s+dim
    if not type(s)==slice: return s
    s1=s.start;s2=s.stop;s3=s.step
    if type(s1) in hListAndArrayTypes:
        s1=Vector(map(lambda x:hSliceListElementToNormalValuesStart(x,dim),s1))
    elif s1==None: s1=0
    elif s1<0: s1+=dim
    elif s1>dim: s1=dim
    if type(s2) in hListAndArrayTypes:
        s2=Vector(map(lambda x:hSliceListElementToNormalValuesEnd(x,dim),s2))
    elif s2==None: s2=dim
    elif s2<0: s2+=dim
    elif s2>dim: s2=dim
    if s3==None: s3=1
    return slice(s1,s2,s3)


def hArray_vec(self):
    """
    array.vec() -> Vector([x1,x2,x3, ...])

    Retrieve the currently selected slice from the stored vector. If
    the entire vector is to be returned a reference to the internal
    data vector is returned. Otherwise, if a slice is active, a copy
    of that slice is returned. Use getVector() to ensure you always
    get only a reference.
    """
    beg=self.getBegin(); end=self.getEnd()
    if ((beg==0 )& (end==len(self))): return self.getVector()
    else: return self.getVector()[beg:end]

def hArray_list(self):
    """
    array.list() -> [x1,x2,x3, ...]

    Retrieve the currently selected slice from the stored vector as a
    python list.
    """
    return list(self.getVector()[self.getBegin():self.getEnd()])

def hArray_new(self):
    """
    ary.new() -> new_array

    Create a new array of the same type and dimensions
    """
    return hArray(basetype(self),self)

def hArray_val(self):
    """
    ary.val() -> a             : if length == 1
    ary.val() -> [a,b,c,...]   : if length > 1

    Retrieve the contents of the vector as python values: either as a
    single value, if the vector just contains a single value, or
    otherwise return a python list.
    """
    return self.vec().val()

def hArray_copy_resize(self,ary):
    """
    Retrieve the first element of the currently selected slice from the stored vector.
    """
    ary.resize(len(self))
    ary.copy(self)
    return ary

def hArray_getitem(self,indexlist):
    """
    self[n1,n2,n3]-> return Element with these indices

    Retrieves a copy of the array with the internal slices set to reflect ...
    integers.

    Use array.setDim([dim1,dim2,...,dimN]) to set the dimensions.
    """
    if type(indexlist)==tuple: indexlist=list(indexlist)
    else: indexlist=[indexlist]
    ary=hArray(self)
    ary.par=self.par
    dimensions=ary.getDim()
    subslice_start=0; subslice_end=-1;
#   Now check if there is an ellipsis in the index list, which indicates looping.
    ellipsiscount=indexlist.count(Ellipsis)
    if ellipsiscount==0:
        ellipsislocation=0
    elif ellipsiscount==1:
        ellipsislocation=indexlist.index(Ellipsis)
        if ellipsislocation==0:
            indexlist[0]=slice(0,None,None) # replace ellipsis with slice
        else:
            if type(indexlist[ellipsislocation-1]) in [slice,list]: # check if Ellipsis is preceded by a slice specification over which to loop.
                del indexlist[ellipsislocation] # delete ellipsis
                ellipsislocation -= 1; #looping is over preceding index
            else:
                indexlist[ellipsislocation]=slice(0,None,None) # replace ellipsis with slice
    else:
        print "Error: hArray_getitem - only one Ellipsis (...) allowed in index list"
        return ary
    nindices=len(indexlist)
    subslice_level=nindices-1
    for i in range(nindices):
        indexlist[i]=hSliceToNormalValues(indexlist[i],dimensions[i])
    indexliststarts=map(hArray_return_slice_start,indexlist)
    lastelement=indexlist[-1]
    if ellipsiscount:
        ellipsiselement=indexlist[ellipsislocation]
        if ellipsislocation<nindices-1: #The slice to return is itself not a slice over a full dimension, but just a part
            subslice_start=hArray_return_slice_start(lastelement);
            subslice_end=hArray_return_slice_end(lastelement)
            indexlist=indexlist[0:-1]; lastelement=indexlist[-1]
        else: #Take an entire dimension as a slice to return
            subslice_start=0
            subslice_end=1
        if type(ellipsiselement)==slice: #loop over a slice of a higher index
            ary.setSubSlice(subslice_start,subslice_end,subslice_level)
            ary.loop(Vector(int,ellipsislocation,fill=indexliststarts[0:ellipsislocation]),hNone2Value(ellipsiselement.start,0),hNone2Value(ellipsiselement.stop,-1),hNone2Value(ellipsiselement.step,1))
        elif type(lastelement)==list: # loop over a list of indices
            ary.setSubSlice(subslice_start,subslice_end,subslice_level)
            ary.loop(Vector(int,ellipsislocation,fill=indexliststarts[0:ellipsislocation]),Vector(indexlist[ellipsislocation]))
    elif type(lastelement)==slice: #Non-looping slice
        ary.setSubSlice(hArray_return_slice_start(lastelement),hArray_return_slice_end(lastelement),subslice_level)
        ary.setSliceVector(Vector(int,nindices-1,fill=indexliststarts[0:-1]))
    elif type(lastelement) in [list,IntVec,IntArray]: #make new vector 
        if len(dimensions)==nindices: ## only implemented for last slice.
            arycopy=hArray(Type=basetype(ary),dimensions=[len(lastelement)])
            if nindices>1: 
                ary.setSubSlice(subslice_start,subslice_end,subslice_level)
                ary.setSliceVector(Vector(int,nindices-1,fill=indexliststarts[0:-1]))
            arycopy.copy(ary,hArray(lastelement),-1)
            return arycopy
        else:
            print "Error: hArray_getitem - list of indices has to be at the position of the last index."
    else: # normal integer index
        ary.setSubSlice(lastelement,lastelement+1,subslice_level)
        ary.setSliceVector(Vector(int,nindices-1,fill=indexliststarts[0:-1]))
    return ary;

def hArray_setitem(self,dims,fill):
    """
    vec[n1,n2,..] = [0,1,2] -> set slice of array to input vector/value

    """
    if (type(fill)) in hAllListTypes: fill=hArray(fill)
    hFill(hArray_getitem(self,dims),fill)

def hArray_read(self,datafile,key):
    """
    array.read(file,"Time") -> read key Data Array "Time" from file into array.

    Will also set the attributes par.file and par.filename of the array and
    make a history entry.
    """
    self.par.filename=datafile.filename
    self.addHistory("read","Reading data from file "+self.par.filename)
    self.par.file=datafile.read(key,self)
    return self

def hArray_setPar(self,key,value):
    """
    array.setPar("keyword",value) -> array.par.keyword=value

    returns array.

    Provides a method to set a paramter associated with an array, e.g.,

    Example:

    fftdata=datafile["FFT"].setPar("xvalue",datafile["Frequency"])

    to set the default x-axis values.
    """
    setattr(self.par,key,value)
    return self

class hArray_par:
    """
    Parameter attribute. Used to hold and inherit arbitrary additional
    paramaters used by python methods (e.g. xvalues for the plotting
    command).
    """
    def __repr__(self):
        s=""
        for attr in dir(self)[2:]:
            if not (attr.find("_")==0):
                s+="par."+str(attr)+" = "+str(getattr(self,attr))+"\n"
        return s
    def __list__(self):
        l=[]
        for attr in dir(self)[2:]:
            if not (attr.find("_")==0):
                l.append((str(attr),getattr(self,attr)))
        return l


def hArray_setUnit(self,*arg):
    self.setUnit_(*arg)
    return self

#======================================================================
#  Define Plotting functions for vectors and arrays
#======================================================================

#    plt.subplot(1,2,1)
#%SKIP
#plt.title("Average Spectrum for Two Antennas")


def hPlot_plot(self,xvalues=None,xlabel=None,ylabel=None,title=None,clf=True,logplot=None,xlim=None,ylim=None,legend=None):
    """
    array[0].plot(self,xvalues=vec,xlabel="x",ylabel="y",title="Title",clf=True,logplot="xy") -> plot the array (loglog)

    Method of arrays. Plots the current slice. If the array is in
    looping mode, multiple curves are plotted in one windows.

    You can set the plotting parameters also as attributes to the .par
    class of the array, e.g., "array.par.xvalues=x_vector; array.plot()"

    Parameters:

    xvalues: an array with corresponding x values, if "None" numbers
    from 0 to length of the array are used

    xlabel: the x-axis label, if not specified, use the "name" keyword
    of the xvalues array - units will be added automatically

    ylabel: the y-axis label, if not specified, use the "name" keyword
    of the array - units will be added automatically

    xlim: tuple with minimum and maximum limits for the x-axis

    ylim: tuple with minimum and maximum limits for the y-axis

    legend: plots a legen taking a tuple of strings for each plotted
    line as input, e.g. legend=("A","B",...)

    title: a title for the plot

    clf: if True (default) clear the screen beforehand (use False to
    compose plots with multiple lines from different arrays.

    logplot: can be used to make loglog or semilog plots:
            "x" ->semilog in x
            "y" ->semilog in y
            "xy"->loglog plot
    """
    if xvalues==None:
        if hasattr(self.par,"xvalues"): xvalues=self.par.xvalues
        else: xvalues=hArray(range(len(self.vec())))
    xunit=xvalues.getUnit().replace("\\mu","$\\mu$")
    if not xunit=="": xunit=" ["+xunit+"]"
    yunit=self.getUnit().replace("\\mu","$\\mu$")
    if not yunit=="": yunit=" ["+yunit+"]"
    if xlabel==None: xlabel=xvalues.getKey("name")
    if ylabel==None: ylabel=self.getKey("name")
    var="clf"; dflt=True; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="xlabel"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="ylabel"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="xlim"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="ylim"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="legend"; dflt=None; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    var="title"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        elif hasattr(self.par,"filename"): exec(var+"=self.par.filename")
        else: exec("var=dflt")
    var="logplot"; dflt=""; val=eval(var);
    if val==None:
        if hasattr(self.par,var): exec(var+"=self.par."+var)
        else: exec("var=dflt")
    if clf: self.plt.clf()
    if logplot=="x": _plot=self.plt.semilogx
    elif logplot=="y": _plot=self.plt.semilogy
    elif (logplot=="xy") | (logplot=="yx"): _plot=self.plt.loglog
    else: _plot=self.plt.plot
    iterate=True;
    while (iterate):
        _plot(xvalues.vec(),self.vec())
        xvalues.next; iterate=self.next().doLoopAgain()
    self.plt.ylabel(ylabel+yunit)
    self.plt.xlabel(xlabel+xunit)
    if not xlim==None: self.plt.xlim(*xlim)
    if not ylim==None: self.plt.ylim(*ylim)
    if not legend==None: self.plt.legend(legend)
    if not ((title=="") | (title==None)): self.plt.title(title)

#======================================================================
#  Define Lists of hArray and Vector Types that we will use
#======================================================================

hBaseTypes=[int,float,complex,bool,str]
hBaseNames=["Int","Float","Complex","Bool","String"]
hBaseNamesPy=["int","float","complex","bool","str"]

hRealTypes=[int,float]
hComplexTypes=[complex]
hNumericalTypes=hRealTypes+hComplexTypes
hOtherTypes=[bool,str]

#------------------------------------------------------------

hVectorBaseTypeDictionary={}
hArrayBaseTypeDictionary={}
hArrayTypeDictionary={}
hVectorTypeDictionary={}
hTypeDictionary={}
hTypeNamesDictionary={}
hAllVectorTypes=[]
hAllArrayTypes=[]
for i in range(len(hBaseTypes)):
    btype=hBaseTypes[i]
    vtype=eval(hBaseNames[i]+"Vec")
    atype=eval(hBaseNames[i]+"Array")
    hAllVectorTypes.append(vtype)
    hAllArrayTypes.append(atype)
    hVectorBaseTypeDictionary[vtype]=btype
    hArrayBaseTypeDictionary[atype]=btype
    hVectorTypeDictionary[btype]=vtype
    hArrayTypeDictionary[btype]=atype
    hTypeDictionary[btype]=btype
    hTypeNamesDictionary[btype]=hBaseNamesPy[i]

hAllListTypes=hAllVectorTypes+[list,tuple]
hListAndArrayTypes=[list,tuple]+hAllVectorTypes+hAllArrayTypes



basetypedictionary=dict(zip(hVectorBaseTypeDictionary.keys()+hArrayBaseTypeDictionary.keys()+hTypeDictionary.keys(),hVectorBaseTypeDictionary.values()+hArrayBaseTypeDictionary.values()+hTypeDictionary.values()))

def type2vector(basetype):
    """type2vector(float) -> Vec(0)=[]

    Creates a vector with elements of type 'basetype'. Returns None if
    a vector of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hVectorTypeDictionary[basetype]()
    else: return None

def type2array(basetype):
    """type2array(float) -> Vec(0)=[]

    Creates an array with elements of type 'basetype'. Returns None if
    an array of the basetype does not exist.
    """
    if basetype in hBaseTypes:
        return hArrayTypeDictionary[basetype]()
    else: return None

def basetype(vec_or_array):
    """
    basetype(IntVec) -> <type 'int'>
    basetype(FloatArray) -> <type 'float'>
    basetype(complex) -> <type 'complex'>

    Returns the basic type contained in the vector or array. Input can be either a vector, an array, or a type thereof.
    """
    t=type(vec_or_array)
    if t==type: t=vec_or_array
    return basetypedictionary[t]

def typename(btype):
    """
    basetype(float) -> "float"
    basetype(str) -> "str"

    Returns the name of the base type as a short string.
    """
    t=type(btype)
    if t==type: t=btype
    return hTypeNamesDictionary[t]


def ishArray(ary):
    """
    ishArray(array) -> True or False

    Returns true if the argument is one of the hArray arrays, i.e. those listed in hAllVectorTypes.
    """
    return type(ary) in hAllArrayTypes

def isVector(vec):
    """
    isVector(vec) -> True or False

    Returns true if the argument is one of the standard c++ vectors i.e. those liste in hAllVectorTypes.
    """
    return type(vec) in hAllVectorTypes

hRealVectorTypes=map(lambda t:hVectorTypeDictionary[t],hRealTypes)
hComplexVectorTypes=map(lambda t:hVectorTypeDictionary[t],hComplexTypes)
hNumericalVectorTypes=map(lambda t:hVectorTypeDictionary[t],hNumericalTypes)
hOtherVectorTypes=map(lambda t:hVectorTypeDictionary[t],hOtherTypes)

hRealArrayTypes=map(lambda t:hArrayTypeDictionary[t],hRealTypes)
hComplexArrayTypes=map(lambda t:hArrayTypeDictionary[t],hComplexTypes)
hNumericalArrayTypes=map(lambda t:hArrayTypeDictionary[t],hNumericalTypes)
hOtherArrayTypes=map(lambda t:hArrayTypeDictionary[t],hOtherTypes)

hRealContainerTypes=hRealVectorTypes+hRealArrayTypes
hComplexContainerTypes=hComplexVectorTypes+hComplexArrayTypes
hNumericalContainerTypes=hNumericalVectorTypes+hNumericalArrayTypes
hOtherContainerTypes=hOtherVectorTypes+hOtherArrayTypes
hAllContainerTypes=hAllVectorTypes+hAllArrayTypes

#======================================================================
#  Vector Methods/Attributes
#======================================================================

"""
Here we add the functions defined in the hftools.cc as
methods/attributes to the (STL) vector classes in python.
"""

Vectordoc= """
A number of vector types are provided: bool, int, float, complex, and
str.

This vector is subscriptable and sliceable, using the
standard python syntax, e.g. v[1:3], or v[2]=0.

To creat a vector most efficently, use the original vector
constructors: BoolVec() - IntVec() - FloatVec() - ComplexVec() -
StringVec()

There is also a more convenient constructor function "Vector" that is
useful for interactive use:

Vector(Type) , where Type=float,int,complex,str, or bool
Vector(Type,size)
Vector(Type,size,fill)
Vector(list), Vector(tuple)
Vector() defaults to a float vector

Use the resize method to allocate more or less memory.

Some of the basic arithmetic is available in an intuitve way, e.g.,
vec+1, vec1+vec2, vec+=vec2).

See the tutorial (tutorial.py) for more details.
"""

Arraydoc= """

hArray(Type=int,dimensions=[n1,n2,n3...],fill=None) -> IntArray

hArray(Type=float,dimensions=[n1,n2,n3...],fill=None) -> FloatArray

....

While the basic underlying data structures are plain STL vectors, in
many cases, however, one has to deal with multi-dimensional data. For
this case we introduce a new wrapper class, named hArrays, that
mimicks a multi-dimensional array, but still operates on an underlying
vector with essentially a flat, horizontal data structure. Given that
a major concern is to minimize duplication of large data structures,
the array class will share memory with its associated vector and also
with arrays that are derived from it. Explicit copying will have to be
done in order to avoid this. Access to various dimensions (rows,
columns, etc...) is done via slices that need to be contiguous in
memory! Since the array is vector-based, all methods defined for
vectors are also inherited by hArrays and can be applied to slices or
even automatically loop over multiple slices (e.g., rows or columns).

An array is defined using the hArray function. This is a constructor
function and not a class of its own. It will return array classes of
different types, such as IntArray, FloatArray, ComplexArray,
StringArray, BoolArray, referring to the different data types they
contain. As for vectors, each array can only contain one type of data.

where Type can be a Python type, a Python list/tuple (where the first
element determines the type), an STL vector, or another hArray.

Dimensions are given as a list of the form [dim1,dim2,dim3, ...]. The
size of the underlying vector will automatically be resized to
dim1*dim2*dim3* ... to be able to contain all elements. Alternatively,
one can provide another array, who's dimensions will be copied.

The array can be filled with an initialization values that can be
either a single value, a list, a tuple, or an STL vector of the same
type.
"""

IntArray.__doc__="c++ hftools array of type 'int'\n"+Arraydoc
FloatArray.__doc__="c++ hftools array of type 'float'\n"+Arraydoc
StringArray.__doc__="c++ hftools array of type 'str'\n"+Arraydoc
BoolArray.__doc__="c++ hftools array of type 'bool'\n"+Arraydoc
ComplexArray.__doc__="c++ hftools array of type 'complex'\n"+Arraydoc

IntVec.__doc__="c++ standard template library (STL) vector of type 'int'\n"+Vectordoc
FloatVec.__doc__="c++ standard template library (STL) vector of type 'float'\n"+Vectordoc
StringVec.__doc__="c++ standard template library (STL) vector of type 'str'\n"+Vectordoc
BoolVec.__doc__="c++ standard template library (STL) vector of type 'bool'\n"+Vectordoc
ComplexVec.__doc__="c++ standard template library (STL) vector of type 'complex'\n"+Vectordoc

IntVec.__name__="IntVec"
FloatVec.__name__="FloatVec"
BoolVec.__name__="BoolVec"
ComplexVec.__name__="ComplexVec"
StringVec.__name__="StringVec"

#Operator Overloading - basic arithmetic

# Operator:  +=
def Vec_iadd(vec1,vec2):
    """
    Provides the += operator for adding two vectors in place.
    vec1+=vec2 will add all elements in vec2 to the corresponding
    elements in vec1 and store the result in vec1.
    """
    hAdd(vec1,vec2)
    return vec1

# Operator:  -=
def Vec_isub(vec1,vec2):
    "Provides the -= operator for addig two vectors in place. \
    vec1-=vec2 will subtract all elements in vec2 from the corresponding elements in vec1\
    and store the result in vec1."
    hSub(vec1,vec2)
    return vec1

# Operator:  /=
def Vec_idiv(vec1,vec2):
    "Provides the /= operator for addig two vectors in place. \
    vec1/=vec2 will divide all elements in vec1 by the corresponding elements in vec2\
    and store the result in vec1."
    hDiv(vec1,vec2)
    return vec1

# Operator:  *=
def Vec_imul(vec1,vec2):
    "Provides the *= operator for addig two vectors in place. \
    vec1=vec2 will multiply all elements in vec1 with the corresponding elements in vec2\
    and store the result in vec1."
    hMul(vec1,vec2)
    return vec1

# Operator:  +
def Vec_add(vec1,val):
    "Provides the + operator for adding two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hAdd(vecout,vec1,val)
    return vecout

# Operator:  -
def Vec_sub(vec1,val):
    "Provides the - operator for subtracting two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hSub(vecout,vec1,val)
    return vecout

# Operator:  *
def Vec_mul(vec1,val):
    "Provides the * operator for multiplying two vectors or a vector and a scalar. The result will be a new vector."
    vecout=vec1.new()
    hMul(vecout,vec1,val)
    return vecout

# Operator:  /
def Vec_div(vec1,val):
    "Provides the / operator for dividing two vectors or a vector by a scalar. The result will be a new vector."
    vecout=vec1.new()
    hDiv(vecout,vec1,val)
    return vecout


#Fourier Transforms
setattr(FloatVec,"fft",hFFTCasa)
setattr(FloatArray,"fft",hFFTCasa)

for v in hAllArrayTypes:
    setattr(v,"__repr__",hArray_repr)
    setattr(v,"setPar",hArray_setPar)
    setattr(v,"setDim",hArray_setDim)
    setattr(v,"getDim",hArray_getDim)
    setattr(v,"vec",hArray_vec)
    setattr(v,"val",hArray_val)
    setattr(v,"new",hArray_new)
    setattr(v,"none",hArray_none)
    setattr(v,"read",hArray_read)
    setattr(v,"list",hArray_list)
    setattr(v,"plt",plt)
    setattr(v,"plot",hPlot_plot)
    setattr(v,"copy_resize",hArray_copy_resize)
    setattr(v,"newreference",hArray_newreference)
    setattr(v,"__getitem__",hArray_getitem)
    setattr(v,"__setitem__",hArray_setitem)
    setattr(v,"setUnit",hArray_setUnit)

for v in hAllVectorTypes:
    setattr(v,"__repr__",VecToPrintString)
    setattr(v,"extendflat",extendflat)
    setattr(v,"setDim",hVector_setDim)
    setattr(v,"getDim",hVector_getDim)
    setattr(v,"elem",hVector_elem)
    setattr(v,"val",hVector_val)
    setattr(v,"vec",hVector_vec)
    setattr(v,"list",hVector_list)
    setattr(v,"dimension",[])
    setattr(v,"ndim",0)
    for s in ["hResize","hNew"]:
        setattr(v,s[1:].lower(),eval(s))


for v in hAllContainerTypes:
    for s in ["hFill","hSet","hCopy","hSort","hZipper","hReadDump","hWriteDump","hRedistribute","hPPrint","hPrettyString"]:
        if s in locals(): setattr(v,s[1:].lower(),eval(s))
        else: print "Warning: function ",s," is not defined. Likely due to a missing library in hftools.cc."

for v in hRealContainerTypes:
    for s in ["hMean","hStdDev","hMeanThreshold","hMeanInverse","hDownsample","hUpsample","hDownsampleSpikyData","hInterpolate2P","hInterpolate2PSubpiece","hNegate","hVectorLength","hNormalize","hArg","hImag","hNorm","hReal","hAcos","hAsin","hAtan","hCeil","hFloor","hMeanGreaterThanThreshold","hMeanGreaterEqualThreshold","hMeanLessThanThreshold","hMeanLessEqualThreshold","hFindGreaterThan","hFindGreaterEqual","hFindGreaterThanAbs","hFindGreaterEqualAbs","hFindLessThan","hFindLessEqual","hFindLessThanAbs","hFindLessEqualAbs","hCountGreaterThan","hCountGreaterEqual","hCountGreaterThanAbs","hCountGreaterEqualAbs","hCountLessThan","hCountLessEqual","hCountLessThanAbs","hCountLessEqualAbs","hFindBetween","hFindBetweenOrEqual","hFindOutside","hFindOutsideOrEqual","hRunningAverage","hDelayToPhase","hInvFFTCasa","hFFTw","hInvFFTw","hGetHanningFilter","hApplyHanningFilter","hGetHanningFilterHalf","hSpectralPower","hRFIDownsampling","hRFIBaselineFitting","hRFIFlagging","hLinearFitPolynomialX","hLinearFit","hBSplineFitXValues","hBSpline","hBSplineFit","hErrorsToWeights","hPolynomial"]:
        if s in locals(): setattr(v,s[1:].lower(),eval(s))
        else: print "Warning: function ",s," is not defined. Likely due to a missing library in hftools.cc."

for v in hComplexContainerTypes:
    for s in ["hConj","hCrossCorrelateComplex","hFFTCasa","hInvFFTw","hFFTw","hNyquistSwap","hPhaseToComplex","hAmplitudePhaseToComplex","hRFIDownsampling"]:
        if s in locals(): setattr(v,s[1:].lower(),eval(s))
        else: print "Warning: function ",s," is not defined. Likely due to a missing library in hftools.cc."

for v in hNumericalContainerTypes:
    setattr(v,"__add__",Vec_add)
    setattr(v,"__sub__",Vec_sub)
    setattr(v,"__div__",Vec_div)
    setattr(v,"__mul__",Vec_mul)
    setattr(v,"__iadd__",Vec_iadd)
    setattr(v,"__imul__",Vec_imul)
    setattr(v,"__idiv__",Vec_idiv)
    setattr(v,"__isub__",Vec_isub)
    for s in ["hFillRange","hAbs","hMax","hMin","hConvert","hConvertResize","hMul","hDiv","hSub","hAdd","hMulTo","hDivTo","hSubTo","hAddTo","hMulAdd","hDivAdd","hSubAdd","hAddAdd","hCos","hCosh","hExp","hLog","hLog10","hLogSave","hSin","hSinh","hSqrt","hSquare","hTan","hTanh","hSum","hMulSum","hRandom","hSortMedian","hMedian","hFindLowerBound"]:
        if s in locals(): setattr(v,s[1:].lower(),eval(s))
        else: print "Warning: function ",s," is not defined. Likely due to a missing library in hftools.cc."

#========================================================================
# Convenience Vector Constructor
#========================================================================

def Vector(Type=float,size=-1,fill=None):
    """
    The basic Boost Python STL vector constructor takes no arguments and
    hence is a litte cumbersome to use. Here we provide a wrapper function
    that is useful for interactive use. If speed is of the essence, use
    the original vector constructors: BoolVec(), IntVec(), FloatVec(),
    ComplexVec(), StringVec()

    Usage:

    Vector(Type) -  will create an empty vector of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Vector(Type,size) - will create an vector of type "Type", with length "size".

    Vector(Type,size,fill) - will create an vector of type "Type", with length
    "size" and initialized with the value "fill"

    Vector([1,2,3,...]) or Vector((1,2,3,...)) - if a list or a tuple is
    provided as first argument then a vector is created of the type of the
    first element in the list or tuple (here an integer) and filled with
    the contents of the list or tuple.

    Vector() defaults to a float vector.

    Note, that size and fill take precedence over the list and tuple
    input. Hence if you create a vector with Vector([1,2,3],size=2) it
    will contain only [1,2]. Vector([1,2,3],size=2,fill=4) will give
    [4,4].
    """
    vtype=Type
    if type(size) in hListAndArrayTypes: size=len(size)
    if (type(vtype) in hAllArrayTypes):  # hArrayClass
        vtype=basetype(Type)
        vec=Vector(Type.getVector())
    elif (type(vtype) in hAllListTypes):  #List or Vector
        vtype=type(Type[0])
        vec=type2vector(vtype)
        vec.extend(Type)
    else:
        vec=type2vector(vtype)
    vec.type=vtype
    if (size>=0): vec.resize(size)
    if type(fill) in [tuple,list]: 
        if len(fill)>0: fill=Vector(fill)
        else: fill=None
    if type(fill) in hAllArrayTypes: fill=fill.vec()
    if (not fill==None):
        vec.fill(fill)
    return vec

#======================================================================
#  hArray Class and Vector Methods/Attributes
#======================================================================

def hArray(
Type=None,dimensions=None,fill=None,name=None,copy=None,properties=None, xvalues=None,units=None,par=None):
    """
    Python convenience constructor function for hArrays. If speed is
    of the essence, use the original vector constructors: BoolArray(),
    IntArray(), FloatArray(), ComplexArray(), StringArray()

    Usage:

    hArray(Type=float,dimensions=[n1,n2,n3...],fill=array/scalar,name="String", copy=array, properties=array, xvalues=array,units=("prefix","unit"),par=(keyword,value)) -> FloatArray

    Array(Type) -  will create an empty array of type "Type", where Type is
    a basic Python type, i.e.  bool, int, float, complex, str.

    Array([1,2,3,...]) or Array((1,2,3,...)) - if a list or a tuple is
    provided as first argument then an array is created of the type of
    the first element in the list or tuple (here an integer) and
    filled with the contents of the list or tuple.

    Array(vec) - will create an array of the type of a vector and use
    the vector as its underlying memory storage. To copy the value,
    use the fill parameter described below.

    Array(Type,dimensions) - will create an array of type "Type",
    specifiying its dimensions. Input for dimensions can be a list or
    a another array (who's dimensions are coopied).

    Array(Type,dimensions,fill) - same as above but fill the array with
    particular values. Input can be a single value, a list, a vector,
    or another array.

    Array() defaults to a float array.

    Note, that dimensions and fill take precedence over the list and tuple
    input. Hence if you create a array with Array([1,2,3],dimension=[2]) it
    will contain only [1,2]. Array([1,2,3],dimension=[2],fill=4) will give
    [4,4].

    Parameters:
    ===========

    dimensions = list or array: set the dimension of the array
    specified as a list of integers, or an array from which to copy
    the dimensions.

    copy = array: make a copy of 'array' in terms of type, dimension,
    fill, and parameter object.

    properties = array: make a new object with the same properties of 'array' in terms of type, dimension,
    and parameter object, but NOT copying the data.

    xvalues = array: set the default x-axis values for plotting to array
    (simply sets self.par.xvalues to array)

    units = (prefixstring,unitname) - will set the initial units of the
    array accordingly, e.g. units=("M","Hz") states that the values
    are provided in units of MHz.

    par = tuple or list of tuples: set additional (arbitrary)
    parameter values that are stored in the .par attribute of the
    array, and are used, e.g., by the plot method to use certain
    defaults.

    """
    if type(copy) in hAllArrayTypes:
        if properties==None: properties=copy
        if fill==None: fill=copy
    if type(properties) in hAllArrayTypes:
        if Type==None: Type=basetype(properties)
        if name==None: name=properties.getKey("name")
        if dimensions==None: dimensions=properties.getDim()
        if units==None: units=(properties.getUnitPrefix(),properties.getUnitName())
        par=properties.par.__list__()
    if Type==None: Type=float
    if isVector(Type):  #Make a new array with reference to the input vector
        ary=type2array(basetype(Type))
        ary.stored_vector=Type
        ary.setVector(ary.stored_vector)
    elif ishArray(Type):  # Just make a copy with reference to same vector
        ary=Type.newreference()
    else: # Create a new vector
        vec=Vector(Type=Type)
        ary=type2array(basetype(vec))
        ary.stored_vector=vec
        ary.setVector(ary.stored_vector)
    if not hasattr(ary,"par"): setattr(ary,"par",hArray_par())
    if type(dimensions)==int: ary.setDim([dimensions])
    elif (type(dimensions) in [list,tuple,IntVec]): ary.setDim(dimensions)
    elif (type(dimensions) in hAllArrayTypes): ary.setDim(dimensions.getDim())
    if type(par) == tuple: setattr(ary.par,par[0],par[1])
    if type(par) == list: map(lambda elem:setattr(ary.par,elem[0],elem[1]),par)
    if not (xvalues == None): ary.par.xvalues=xvalues
    if not (units == None): 
        if type(units)==str: ary.setUnit("",units) 
        elif type(units)==tuple: ary.setUnit(*units)
        else: print "Error - hArray: Wrong format for units specified."
    if not (fill == None):
        if type(fill) in hAllVectorTypes: ary.vec().fill(fill)
        if type(fill) in [tuple,list]: 
            if len(fill)>0: ary.vec().fill(Vector(fill))
        else: ary.fill(fill)
    if type(name)==str: ary.setKey("name",name);
    return ary

#------------------------------------------------------------------------
# cr DataReader Class
#------------------------------------------------------------------------

def DataReader_repr(self):
    if hasattr(self,"filename"):
        return "crfile('"+self.filename+"')"
    else:
        return "Unknonw DataReaderObject"

def DataReader_getHeaderVariables(self):
    """
    Method to read out the header information from the DataReader and
    put it into attributes of the DataReader object.
    """
    self.keywords=map(lambda s:s[0].lower()+s[1:],set(self.get("keywords").split(", ")).difference(['keywords','help', 'positions','dDate', 'presync', 'TL', 'LTL', 'EventClass', 'SampleFreq', 'StartSample']))
    for v in self.keywords:
        setattr(self,v,self.get(v))

def DataReader_getitem(self,*keys):
    """
    datafile["key"] -> value
    datafile["key1","key2",...] -> [value1, value2,...]

    Method to obtain header information from the DataReader.
    """
    keys0=keys[0]
    if type(keys0)==tuple: return map(lambda k:hFileGetParameter(self,k),keys0)
    if not type(keys0)==str:
        print "Error - DataReader(Py): keyword",keys0,"must be a string!"
        return
    emptyarray=(keys0[0:5]=='empty')
    if emptyarray: keys0=keys0[5:]
    if keys0 in ["Time","Frequency","Fx","Voltage","FFT","CalFFT","TimeLag"]: #these are the data vectors
        if keys0=="Time": ary=hArray(float,dimensions=[self.blocksize],name="Time",units="s")
        if keys0=="Frequency": ary=hArray(float,dimensions=[self.fftLength],name="Frequency",units="Hz")
        if keys0=="Fx": ary=hArray(float,dimensions=[self.nofSelectedAntennas,self.blocksize],name="E-Field",units="ADC Counts")
        if keys0=="Voltage": ary=hArray(float,dimensions=[self.nofSelectedAntennas,self.blocksize],name="Voltage",units="V")
        if keys0=="FFT": ary=hArray(complex,dimensions=[self.nofSelectedAntennas,self.fftLength],name="FFT(E-Field)",units="ar.u.")
        if keys0=="CalFFT": ary=hArray(complex,dimensions=[self.nofSelectedAntennas,self.fftLength],name="CalFFT(E-Field)",units="ar.u.")
        if keys0=="TimeLag": ary=hArray(float,dimensions=[self.blocksize],name="Time Lag",units="s")
        if not emptyarray:
            if keys0=="TimeLag": ary.fillrange(-self.blocksize/2*self.sampleInterval,self.sampleInterval)
            else: ary.read(self,keys0)
        return ary
    else: return hFileGetParameter(self,keys0)

def DataReader_set(self,key,val):
    """
    datafile.set("key",value) -> set the appropriate header parameter

    Method to set header information in the DataReader and
    put it into attributes of the DataReader object.
    """
    ok=hFileSetParameter(self,key,val)
    self.getHeaderVariables()
    return self

def DataReader_setitem(self,*keyval):
    """
    datafile["key"]=value -> set the appropriate header parameter
    datafile[["key1","key2",...]]=[value1, value2,...] -> set multiple  header parameters

    Method to set header information in the DataReader and
    put it into attributes of the DataReader object.
    """
    if len(keyval)!=2:
        print "Wrong NUmber of Argument for DataReader['key']=value!"
        return
    key=keyval[0]
    val=keyval[1]
    if (type(key)==tuple):
        for k,v in zip(key,val):
            self.set(k,v)
    else: self.set(key,val)

def crfile(filename):
    """
    file=crfile("FILENAME.h5") -> DataReader Object

    This is a simple class to interface with the LOFAR CRTOOLS
    datareader class. It deals with LOFAR and LOEPS data alike. You
    can read data vectors, read or set parameters and get summary of the contents.
    """
    cfile=hFileOpen(filename)
    cfile.filename=filename
    cfile.getHeaderVariables()
    return cfile

#------------------------------------------------------------------------
# Getting Metadata like Antenna positions or instrumental delays
#------------------------------------------------------------------------

def hgetCalData(datafile,keyword):
    obsname=datafile["observatory"]
    if obsname=='LOPES':
        result=hCalTableVector(LOFARSOFT+"/data/lopes/LOPES-CalTable",keyword,datafile["date"],list(datafile["antennaIDs"]))
    else:
        print "ERROR: No caltables for non-LOPES files."
        return
    if keyword=="Position": return hArray(result,dimensions=[datafile["nofAntennas"],3])
    elif keyword=="Delay": return hArray(result,dimensions=[datafile["nofAntennas"]])
    else: return

DataReader.read=hFileRead
DataReader.set=DataReader_set
DataReader.__setitem__=DataReader_setitem
DataReader.__getitem__=DataReader_getitem
DataReader.getHeaderVariables=DataReader_getHeaderVariables
DataReader.__doc__=crfile.__doc__
DataReader.getCalData = hgetCalData
DataReader.__repr__=DataReader_repr
 
#The folowing should actually go into 
#
#FILE: pycranalysis.py
#

#------------------------------------------------------------------------
# Pypeline Extension, Functions and Algorithms
#------------------------------------------------------------------------
CRWorkSpaceList = []

class CRWorkSpace():
    """
    This class holds the arrays and vectors used by the various
    analysis tasks. Hence this is the basic workspace in the memory.
    """
    def __init__(self,parent=None,modulename=None,**keywords):
        self.modules=[]
        if modulename==None: 
            self.modulename=self.name
        else:
            self.modulename=modulename
#Set the parent workspace if it exists and add itself to the parent's "modules" list.
        if not parent==None: 
            self.parent=parent
            self.parent.modules.append(self.modulename)
            setattr(parent,self.modulename,self)
        l=len("default")+1
#Create a list of all the parameters with default values (and initialization functions)
        if not hasattr(self,"parameters"): self.parameters=[]
        self.parameters+=list(set(map(lambda s:s[l:],filter(lambda s:s.find("default_")==0,dir(self)))).difference(set(self.parameters)))
        for par in self.parameters:
            if hasattr(self,"default_"+par):
                if type(getattr(self,"default_"+par).__doc__)==str: #assign docstring, reusing the one from the initialization function
                    setattr(self,"__"+par+"__doc__",getattr(self,"default_"+par).__doc__)
        self.auxparameters=[]
        if not hasattr(self,"locals"): self.locals=set()
        self.setParameters(**keywords)
    def initParameters(self,**keywords):
        """
        This method will create all parameters that are not yet
        available as attributes or find higher up and assign the
        default value. Also do the same for all modules. You can
        explicitly set a parameter and override the default, if it is
        passed as a keyword=value pair in the argumentlist.
        """
        self.setParameters(**keywords)
        for par in self.parameters: self[par]
        for m in self.modules: #Now, also initialize the modules
            getattr(self,m).initParameters()
        return self
    def __setitem__(self,par,val):
        """Sets the value of a parameter and make it local."""
        if par not in self.parameters+self.auxparameters: self.auxparameters.append(par)
        if not self.isLocal(par): self.locals.add(par)
        setattr(self,par,val)
    def __getitem__(self,par):
        """
        Retrieve a parameter value from the workspace. If it does not
        exist locally, search the parent modules. If it is not
        available there execute the default function and assign the
        value locally. If no default value function exists, return
        None.
        """
        if self.isLocal(par):
            if hasattr(self,par): # return local copy
                return getattr(self,par) 
            else:
                return self.setParameterDefault(par) # no local copy exists, return default paramter and make local
        elif hasattr(self,"parent"): #Is global, hence recursively retrieve it from the higher level (parent)
            val=self.parent[par]
            if not val==None: 
                setattr(self,par,val) # Make a local copy, but don't mark as local
                return val
        #else: Does not exist localy or globaly, so create local default 
        return self.setParameterDefault(par) 
    def isLocal(self,par):
        return (par in self.locals)
    def markLocal(self,par):
        if not self.isLocal(par): self.locals.add(par) # Make parameter local
    def markGlobal(self,par):
        if self.isLocal():
            self.locals.discard(par)
            self["par"]
    def setParameterDefault(self,par):
        """Assign a parameter its default value and make it local."""
        if hasattr(self,"default_"+par):
            val=getattr(self,"default_"+par)()
            setattr(self,par,val)
            self.markLocal(par) # Make parameter local
        else: #no Defaults defined!
            val=None
        return val
    def setParameters(self,**keywords):
        """
        This method will set the parameters listed as arguments in the
        function call, i.e. modify the workspace attributes accordingly.
        """
        for k in keywords.keys(): self[k]=keywords[k]
        return self
    def __repr__(self,parentname=""):
        """
        Returns a readable summary of all parameters in the workspace.
        """
        s="#WorkSpace("+self.name+"):\n"
        myname=parentname+self.modulename
        for par in self.parameters+self.auxparameters:
            s+=myname+'["'+par+'"] = '+str(self[par])
            if self.isLocal(par): s+=" # (local)\n"
            else: s+=" # (parent)\n"
        for m in self.modules:
            s+=getattr(self,m).__repr__(parentname=myname+".")+"\n"
        return s
    def doc_parameters(self):
        s=""
        for par in self.parameters:
            val=self[par]
            s+="    "+par
            if ishArray(val): s+=" = "+val.__repr__(long=False)
            elif not val==None: s+=" = "+str(val)
            if hasattr(self,"__"+par+"__doc__"):
                s+=" - "+getattr(self,"__"+par+"__doc__")
            s+="\n"
        return s
    def help(self):
        print self.__doc__
        print "\nAvailable parameters:"
        print self.doc_parameters()
    def getModule(self,name):
        if self.name==name: return self
        for m in self.modules:
            val=getattr(self,m).getModule(name)
            if not val==None: return val
        return None

class CRAverageSpectrumWorkSpace(CRWorkSpace):
    """Workspace for hCRAverageSpectrum. See also CRMainWorkSpace and CRWorkSpace."""
    def __init__(self,parent=None,modulename=None,**keywords):
        self.parameters=["datafile","max_nblocks","nblocks"] # Create those parameters first and in this order
        CRWorkSpace.__init__(self,parent=parent,modulename=modulename,**keywords)
    def default_datafile(self): 
        """DataReader object to read the data from."""
        return crfile(DEFAULTDATAFILE)
    def default_nblocks(self): 
        """Number of blocks to average, take all blocks by default."""
        return min(self["datafile"].filesize/self["datafile"].blocksize,self["max_nblocks"])
    def default_max_nblocks(self): 
        """Absolute maximum number of blocks to average, irrespective of filesize."""
        return 100000
    def default_blocks(self): 
        """List of blocks to process."""
        return range(self["nblocks"])
    def default_fx(self):
        """Array to hold the x-values of the raw time series data. (work vector)"""
        return self["datafile"]["emptyFx"]
    def default_fft(self): 
        """Array to hold the FFTed x-values (i.e. complex spectrum) of the raw time series data. (work vector)"""
        return self["datafile"]["emptyFFT"]

#Now add the new workspsace to the overall workspace list
CRWorkSpaceList.append(CRAverageSpectrumWorkSpace)
#And tell it its name ...
CRWorkSpaceList[-1].name="AverageSpectrum"

class CRFitBaselineWorkSpace(CRWorkSpace):
    """Workspace for hCRFitBaseline. See also CRMainWorkSpace and CRWorkSpace."""
    def __init__(self,parent=None,modulename=None,**keywords):
        self.parameters=["nbins","ncoeffs","polyorder","nofAntennas","freqs","spectrum"]
        self.locals=set(["nbins","polyorder","freqs","spectrum","rms","ratio","selected_bins"])
        CRWorkSpace.__init__(self,parent=parent,modulename=modulename,**keywords)
    def default_nbins(self): 
        """The number of bins in the downsampled spectrum used to fit the baseline."""
        return 2**8
    def default_polyorder(self): 
        """Order of the plyonomial to fit.  (output only)"""
        return self["ncoeffs"]-1
    def default_rmsfactor(self): 
        """Factor above and below the RMS in each bin at which a bin is no longer considered."""
        return 2.0
    def default_logfit(self): 
        """Actually fit the polynomial to the log of the (downsampled) data. (Hence you need to .exp the baseline afterwards)."""
        return True
    def default_nofAntennas(self): 
        """Number of antennas held in memory."""
        return 1
    def default_ncoeffs(self): 
        """Number of coefficients for the polynomial."""
        return 18
    def default_numin(self):
        """Minimum frequency of useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numax(self):
        """Maximum frequency of useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numin_i(self):
        """Channel number in spectrum of the minimum frequency of the useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numax_i(self):
        """Channel number in spectrum of the maximum frequency of the useable bandwidth. Negative if to be ignored."""
        return -1
    def default_extendfit(self):
        """Extend the fit by this factor at both ends beyond numax and numin. The factor is relative to the unsued bandwidth."""
        return 0.1
    def default_freqs(self):
        """Array of frequency values of the downsampled spectrum. (work vector)"""
        return hArray(float,dimensions=[1,self["nbins"]],name="Frequency",units=("M","Hz"))
    def default_spectrum(self):
        """Array of power values holding the downsampled spectrum. (work vector)"""
        return hArray(float,[self["nofAntennas"],self["nbins"]],name="Binned Spectrum",units="a.u.",xvalues=self["freqs"],par=("logplot","y"))
    def default_rms(self):
        """Array of RMS values of the downsampled spectrum. (work vector)"""
        return hArray(properties=self["spectrum"], name="RMS of Spectrum")
    def default_weights(self):
        """Array of weight values for the fit. (work vector)"""
        return hArray(properties=self["spectrum"], name="Fit Weights")
    def default_ratio(self):
        """Array holding the ratio between RMS and power of the downsampled spectrum. (work vector)"""
        return hArray(properties=self["spectrum"],name="RMS/Amplitude",par=("logplot",False))
    def default_powers(self):
        """Array of integers, containing the powers to fit in the polynomial. (work vector)"""
        return hArray(int,[self["nofAntennas"],self["ncoeffs"]],range(self["ncoeffs"]))
    def default_xpowers(self):
        """Array holding the x-values and their powers for the fit. (work vector)"""
        return hArray(float,[self["nofAntennas"],self["nbins"],self["ncoeffs"]],name="Powers of Frequency")
    def default_covariance(self):
        """Array containign the covariance matrix of the fit. (outpur only)"""
        return hArray(float,[self["nofAntennas"],self["ncoeffs"],self["ncoeffs"]])
    def default_bwipointer(self):
        """Pointer to the internal BSpline workspace as integer. Don't change! """
        return 0
    def default_clean_bins_x(self):
        """Array holding the frequencies of the clean bins. (work vector)"""
        return self["freqs"] #hArray(properties=self["freqs"],name="Clean Frequencies")
    def default_clean_bins_y(self):
        """Array holding the powers of the clean bins. (work vector)"""
        return self["spectrum"] #hArray(properties=self["spectrum"],xvalues=self["clean"]_bins_x)
    def default_nselected_bins(self):
        """Number of clean bins after RFI removal. (output only)"""
        return 0
    def default_selected_bins(self):
        """Array of indices pointing to clean bins, i.e. with low RFI. (work vector)"""
        return hArray(int,self["spectrum"],name="Selected bins")
    def default_coeffs(self): 
        """Polynomial coeffieients of the baseline fit. (output vector)"""
        return hArray(float,[self["nofAntennas"],self["ncoeffs"]])
    def default_meanrms(self): 
        """Estimate the mean rms in the spectrum per antenna. (output vector)"""
        return 0

#Now add the new workspsace to the overall workspace list
CRWorkSpaceList.append(CRFitBaselineWorkSpace)
#And tell it its name ...
CRWorkSpaceList[-1].name="FitBaseline"

class CRMainWorkSpace(CRWorkSpace):
    """
    ws=CRMainWorkSpace()

    WorkSpace for global parameters.

    This is a class to hold the variable, vectors, and arrays of all
    parameters used in the analysis. 

    You can access the parameters using ws["parametername"] and set
    them using ws["parametername"]=val.

    Every known parameter has an associated function of the format
    '.global_parameter' to return a default value. The defaults will
    be set when calling the function ws.initParameters() or the first
    time when you access a parameter. A local copy will be made in an
    attribute of the class. So, you can access it also with
    
    ws.parametername

    Workspaces can be stacked hierarchically in a tree structure, by
    providing a parent workspace as an argument during creation, e.g. 

    child_ws=CRFitBaselineWorkSpace(ws)

    Parameter can than be local or global. If a parameter is not yet
    set locally, it will be searched in the parent works space. If it
    is not found in either workspace, the default value will be
    calculated and assigned locally. 

    You can assign your own value with ws["parname"]=value before
    initialization to avoid execution of the defaulting mechanism.

    E.g. to set the blocksize to 1024, simply set ws["blocksize"]=1024
    prior to calling initParameters.
    
    Note that the local copy of a value is only made once
    initParameters is called or the parameter explicitly with
    ws["..."]. So, if a global value changes, the change will not be
    immediately reflected in the ws.parname value - hence use that with
    care.

    ws.initParameters() - set all parameters (i.e. attributes) that do
    not exist yet, and assign a default value.

    ws.help() - get a list of all parameters and their values.

    """
    def __init__(self,modulename=None,**keywords):
# Here list the parameters which have to be initialized in a
# particular order at the beginning (e.g., if the depend on each
# other). The attribute will be extended automatically.
        self.parameters=["filename","blocksize","datafile","nofAntennas","fftLength","frequency"]
        CRWorkSpace.__init__(self,modulename=modulename,parent=None,**keywords)
    def default_filename(self): 
        """Name of the data file to process."""
        return LOFARSOFT+"/data/lofar/rw_20080701_162002_0109.h5"
    def default_datafile(self): 
        """Datafile object. Will be created from the filename and set to the right blocksize, if it does not exist yet."""
        return crfile(self["filename"]).set("blocksize",self["blocksize"])
    def default_blocksize(self):
        """Size (number of values) of each block to be read in."""
        return 2**16
    def default_nofAntennas(self):
        """Number of antennas in the datafile (output only)"""
        return self["datafile"]["nofAntennas"]
    def default_fftLength(self):
        """Size of the FFT or spectrum derived from the datareader object."""
        return self["datafile"]["fftLength"]
    def default_numin(self):
        """Minimum frequency of useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numax(self):
        """Maximum frequency of useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numin_i(self):
        """Channel number in spectrum of the minimum frequency of the useable bandwidth. Negative if to be ignored."""
        return -1
    def default_numax_i(self):
        """Channel number in spectrum of the maximum frequency of the useable bandwidth. Negative if to be ignored."""
        return -1
    def default_frequency(self):
        """Frequency values (x-axis) corresponding to FFT and spectrum"""
        return self["datafile"]["Frequency"].setUnit("M","")
    def default_spectrum(self):
        """Power as a function of frequency."""
        return hArray(float,[self["nofAntennas"],self["datafile"].fftLength],fill=0,name="Spectrum",units="a.u.",xvalues=self["frequency"],par=[("logplot","y")])
    def default_cleanspec(self):
        """Copy of the spectrum with the gain curve and the spiky channels taken out."""
        return hArray(properties=self["spectrum"])
    def default_bad_channels(self):
        """Indexlist of bad channels containing RFI. (output only)"""
        return hArray(int,self["spectrum"],name="Bad Channels")
    def default_nbad_channels(self):
        """Number of bad channels (output only)"""
        return 0
    def default_rfi_nsigma(self):
        """Threshold for identifying a spike in Frequency as an RFI line to flag, in units of standard deviations of the noise."""
        return 5
    def default_fx(self): 
        """Raw time series antenna data."""
        return self["datafile"]["emptyFx"]
    def default_fft(self): 
        """FFT of the Raw time series antenna data."""
        return self["datafile"]["emptyFFT"]
    def default_ncoeffs(self): 
        """Number of coefficients to describe the baseline."""
        return 18
    def default_baseline(self):
        """Array with a baseline fit to the spectrum."""
        return hArray(properties=self["spectrum"],xvalues=self["frequency"],name="Baseline")
    def default_baseline_x(self):
        """Array holding the x-values and their powers for calculating the baseline fit."""
        return hArray(float,[self["fftLength"],self["ncoeffs"]],name="Powers of Frequency")

def CRWorkSpace_default_doplot(self):
    """Make plots during processing to inspect data."""
    return False
def CRWorkSpace_default_t0(self):
    """The cpu starting time of the processingin seconds, used for benchmarking."""
    return time.clock()
def CRWorkSpace_default_verbose(self):
    """Print progress information during processing."""
    return False


#Now add the new workspsace to the overall workspace list, the main workspace should be the first entry in the list
CRWorkSpaceList=[CRMainWorkSpace]+CRWorkSpaceList
#And tell it its name ...
CRWorkSpaceList[0].name="Main"

#Automatically add certain workspace methods
for ws in CRWorkSpaceList:
#Add creation methods to main WorkSpace
    setattr(CRMainWorkSpace,"make"+ws.name,ws)
#Add some of generic control methods and parameters to all workspaces
    for m in ["doplot","verbose","t0"]:
        setattr(ws,"default_"+m,eval("CRWorkSpace_default_"+m))


def CRsetWorkSpace(ws,modulename,**keywords):
    """
    Sets the workspace in a function if not defined already and
    initialize parameters. One can provide a global workspace and the
    functions will pick the module corresponding to modulename.

    ws - the workspace, if ws==None then create new one using function func

    modulename - name of the (sub)module to use, will call the
    initialization function (naming convention:
    "CR"+modulename+"WorkSpace") if workspace does not exist.

    keywords - local parameters to overwrite
    
    """
    func=eval("CR"+modulename+"WorkSpace")
    if ws==None: ws=func(**keywords)
    ws=ws.getModule(modulename)
    if ws==None: ws=func(**keywords)
    ws.initParameters(**keywords)
    return ws


def hCRFitBaseline(coeffs, frequency, spectrum, ws=None, **keywords):
    """
    hCRFitBaseline(coeffs, frequency, spectrum, ws=None, **keywords)

    Function to fit a baseline using a polynomial function to a
    spectrum while ignoring spikes in the fit (e.g., those coming from
    RFI = Radio Frequency Interference). The functions returns an
    array of coefficients of the polynomial. 

    Use baseline.polynomial(frequency,coeffs,powers) to caluclate the
    baseline from the coefficients.

    Parameters can be provided as additional keywords

    e.g., baseline.polynomial(frequency,coeffs,powers, parameter1=value1, parameter2=value2)

    or in a WorkSpace. 

    e.g., baseline.polynomial(frequency,coeffs,powers, ws=WorkSpace),

    or in a mix of the two. Otherwise default values are used.

    A full list of parameters can be obtained with with:

    CRFitBaselineWorkSpace().help()
    """
#Defining the workspace, setting up the arrays, if not existing
    keywords["nofAntennas"]=spectrum.getDim()[0]
    ws=CRsetWorkSpace(ws,"FitBaseline",**keywords)
#
    if ws.verbose:
        if hasattr(ws,"t0"): ws.t0=time.clock()
        print ws.t0,"s: Starting FitBaseline - Downsampling spectrum to ",ws.nbins,"bins."
#Donwsample spectrum
    if ws["numin"]>0: ws["numin_i"]=frequency.findlowerbound(ws.numin).val()
    else: ws["numin_i"]=1
    if ws["numax"]>0: ws["numax_i"]=frequency.findlowerbound(ws.numax).val()
    else: ws["numax_i"]=len(frequency)
    
    ws["numax_i"]=min(ws["numax_i"]+int((len(frequency)-ws["numax_i"])*ws["extendfit"]),len(frequency))
    ws["numin_i"]=max(ws["numin_i"]-int(ws["numin_i"]*ws["extendfit"]),0)

    ws.freqs.downsample(frequency[ws["numin_i"]:ws["numax_i"]])
    ws.spectrum[...].downsamplespikydata(ws.rms[...],spectrum[...,ws["numin_i"]:ws["numax_i"]],1.0)
    l=ws["numax_i"]-ws["numin_i"]
#Plotting
    if ws.doplot:
        spectrum[0].plot(title="RFI Downsampling")
        ws.spectrum[0,0:l].plot(clf=False)
        raw_input("Plotted downsampled spectrum - press Enter to continue...")
#Calculate RMS/amplitude for each bin
    ws.ratio[...,0:l].div(ws.rms[...,0:l],ws.spectrum[...,0:l])
    ws.ratio[...,0:l].square()
    mratio=ws.ratio[...,0:l].meaninverse()
#Now select bins where the ratio between RMS and amplitude is within a factor 2 of the mean value
    ws["nselected_bins"]=ws.selected_bins[...].findbetween(ws.ratio[...,0:l],mratio/ws.rmsfactor,mratio*ws.rmsfactor)
#Now copy only those bins with average RMS, i.e. likely with little RFI and take the log
    ws.clean_bins_x[...].copy(ws.freqs,ws.selected_bins[...],ws.nselected_bins)
    ws.clean_bins_y[...].copy(ws.spectrum,ws.selected_bins[...],ws.nselected_bins)
    ws.weights.copy(ws.clean_bins_y)
    if ws.logfit: 
        ws.clean_bins_y[...,[0]:ws.nselected_bins].log()
#
    if ws.verbose: print time.clock()-ws.t0,"s: Fitting baseline."
#Create the nth powers of the x value, i.e. the frequency, for the fitting
#    ws.xpowers[...,[0]:ws.nselected_bins].bsplinefitxv<alues(ws.ncoeffs)
#Fit an nth order polynomial to the log data
    ws["bwipointer"]=coeffs[...].bsplinefit(ws.covariance[...],ws.xpowers[...,[0]:ws.nselected_bins],ws.clean_bins_x[...,[0]:ws.nselected_bins],ws.clean_bins_y[...,[0]:ws.nselected_bins])
#Calculate an estimate of the average RMS of the clean spectrum after baseline division
    ws.ratio[...].copy(ws.ratio,ws.selected_bins[...],ws.nselected_bins)
    meanrms=ws.ratio[...,[0]:ws.nselected_bins].meaninverse()
    meanrms.sqrt()
    if ws.doplot:
        ws.clean_bins_y[0,[0]:ws.nselected_bins].plot(xvalues=ws.clean_bins_x[0,[0]:ws.nselected_bins],logplot=False)
        ws.clean_bins_y.fill(0.0)
        ws.clean_bins_y[...,[0]:ws.nselected_bins].bspline(ws.xpowers[...,[0]:ws.nselected_bins],coeffs[...])
        ws.clean_bins_y[0,[0]:ws.nselected_bins].plot(xvalues=ws.clean_bins_x[0,[0]:ws.nselected_bins],clf=False,logplot=False)
        raw_input("Plotted downsampled spectrum - press Enter to continue...")
    return meanrms

def hCRFitBaseline2(coeffs, frequency, spectrum, ws=None, **keywords):
    """
    hCRFitBaseline(coeffs, frequency, spectrum, ws=None, **keywords)

    Function to fit a baseline using a polynomial function to a
    spectrum while ignoring spikes in the fit (e.g., those coming from
    RFI = Radio Frequency Interference). The functions returns an
    array of coefficients of the polynomial. 

    Use baseline.polynomial(frequency,coeffs,powers) to caluclate the
    baseline from the coefficients.

    Parameters can be provided as additional keywords

    e.g., baseline.polynomial(frequency,coeffs,powers, parameter1=value1, parameter2=value2)

    or in a WorkSpace. 

    e.g., baseline.polynomial(frequency,coeffs,powers, ws=WorkSpace),

    or in a mix of the two. Otherwise default values are used.

    A full list of parameters can be obtained with with:

    CRFitBaselineWorkSpace().help()
    """
#Defining the workspace, setting up the arrays, if not existing
    keywords["nofAntennas"]=spectrum.getDim()[0]
    ws=CRsetWorkSpace(ws,"FitBaseline",**keywords)
#
    if ws.verbose:
        if hasattr(ws,"t0"): ws.t0=time.clock()
        print ws.t0,"s: Starting FitBaseline - Downsampling spectrum to ",ws.nbins,"bins."
#Donwsample spectrum
    if ws["numin"]>0: ws["numin_i"]=frequency.findlowerbound(ws.numin).val()
    else: ws["numin_i"]=1
    if ws["numax"]>0: ws["numax_i"]=frequency.findlowerbound(ws.numax).val()
    else: ws["numax_i"]=len(frequency)
    
    ws["numax_i"]=min(ws["numax_i"]+int((len(frequency)-ws["numax_i"])*ws["extendfit"]),len(frequency))
    ws["numin_i"]=max(ws["numin_i"]-int(ws["numin_i"]*ws["extendfit"]),0)

    ws.freqs.downsample(frequency[ws["numin_i"]:ws["numax_i"]])
    ws.spectrum[...].downsamplespikydata(ws.rms[...],spectrum[...,ws["numin_i"]:ws["numax_i"]],1.0)
    l=ws["numax_i"]-ws["numin_i"]
#Plotting
    if ws.doplot:
        spectrum[0].plot(title="RFI Downsampling")
        ws.spectrum[0,0:l].plot(clf=False)
        raw_input("Plotted downsampled spectrum - press Enter to continue...")
#Calculate RMS/amplitude for each bin
    ws.ratio[...,0:l].div(ws.rms[...,0:l],ws.spectrum[...,0:l])
    ws.ratio[...,0:l].square()
    mratio=ws.ratio[...,0:l].meaninverse()
#Now select bins where the ratio between RMS and amplitude is within a factor 2 of the mean value
    ws["nselected_bins"]=ws.selected_bins[...].findbetween(ws.ratio[...,0:l],mratio/ws.rmsfactor,mratio*ws.rmsfactor)
#Now copy only those bins with average RMS, i.e. likely with little RFI and take the log
    ws.clean_bins_x[...].copy(ws.freqs,ws.selected_bins[...],ws.nselected_bins)
    ws.clean_bins_y[...].copy(ws.spectrum,ws.selected_bins[...],ws.nselected_bins)
    ws.weights.copy(ws.clean_bins_y)
    if ws.logfit: 
        ws.clean_bins_y[...,[0]:ws.nselected_bins].log()
#
    if ws.verbose: print time.clock()-ws.t0,"s: Fitting baseline."
#Create the nth powers of the x value, i.e. the frequency, for the fitting
    ws.xpowers[...,[0]:ws.nselected_bins].linearfitpolynomialx(ws.clean_bins_x[...,[0]:ws.nselected_bins],ws.powers[...])
#Fit an nth order polynomial to the log data
    coeffs[...].linearfit(ws.covariance[...],ws.xpowers[...],ws.clean_bins_y[...],ws.weights[...],ws.nselected_bins)
#Calculate an estimate of the average RMS of the clean spectrum after baseline division
    ws.ratio[...].copy(ws.ratio,ws.selected_bins[...],ws.nselected_bins)
    meanrms=ws.ratio[...,[0]:ws.nselected_bins].meaninverse()
    meanrms.sqrt()
    if ws.doplot:
        ws.clean_bins_y[0,[0]:ws.nselected_bins].plot(xvalues=ws.clean_bins_x[0,[0]:ws.nselected_bins],logplot=False)
        ws.clean_bins_y.fill(0.0)
        ws.clean_bins_y[...,[0]:ws.nselected_bins].polynomial(ws.clean_bins_x[...,[0]:ws.nselected_bins],coeffs[...],ws.powers[...])
        ws.clean_bins_y[0,[0]:ws.nselected_bins].plot(xvalues=ws.clean_bins_x[0,[0]:ws.nselected_bins],clf=False,logplot=False)
        raw_input("Plotted downsampled spectrum - press Enter to continue...")
    return meanrms

def hCRAverageSpectrum(spectrum,datafile,ws=None,**keywords): #blocks=None,fx=None,fft=None, verbose=False)
    """
    Usage: CRAverageSpectrum(spectrum,datafile,blocks=None,fx=None,fft=None)

    Reads several blocks in a CR data file, does an FFT and then
    averages the powers to calculuate an average spectrum. The
    parameters are:

    spectrum - a float array of dimensions [nofAntennas,fftLength],
    containing the average spectrum.
    
    datafile - a datareader object where the block size has been set
    appropriately.

    blocks - a list of blocknumbers to read
    (e.g. range(number_of_blocks)). Default is to read all blocks.

    fx - a work Array of dimensions
    [datafile.nofAntennas,datafile.blocksize] which is used to read in
    the raw antenna data. Will be created if not provided.

    fft - a work Array of dimensions
    [datafile.nofAntennas,datafile.fftLength] which is used to
    calculate the FFT from the raw antenna data. Will be created if
    not provided.

    verbose - Provide progress messages

    """
    ws=CRsetWorkSpace(ws,"AverageSpectrum",**keywords)
    if ws.verbose:
        count=0; 
        maxcount=len(ws.blocks)
        lastprogress=-1
        ws["t0"]=time.clock()
        print ws.t0,"s: Calculating",maxcount,"blocks of size",datafile.blocksize
    for block in ws.blocks:
        ws.datafile["block"]=block
        ws.fx.read(datafile,"Fx")
        ws.fft[...].fftw(ws.fx[...])
        spectrum[...].spectralpower(ws.fft[...])
        if ws.verbose:
            count +=1
            progress=count*10/maxcount
            if not lastprogress == progress:
                t=time.clock()-ws.t0
                print progress*10,"% -",t,"s (Remaining:",t/count*maxcount-t,"s) - Calculated block #",block
                lastprogress=progress
    spectrum /= len(ws.blocks)


def CheckParameterConformance(data,keys,limits):
    """
    Usage:

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    CheckParameterConformance([Antenna,mean,rms,npeaks,nonGaussianity],{"mean":1,"rms":2,"nonGaussianity":4},qualitycriteria)  ->  ["rms",...]

    Parameters:

    data -  is a list of quality values (i.e. numbers) to check

    keys - a dictionary of fieldnames to be checked and indices
           telling, where in data the field can be found

    limits - a dictionary of fieldnames and limits (lowerlimit,
             upperlimit)

    Checks whether a list of numbers is within a range of limits. The
    limits are provided as a dictionary of fieldnames and tuples, of
    the form FIELDNAME:(LOWERLIMT,UPPERLIMIT). A list of fieldnames is
    returned where the data does not fall within the specified range.

    """
    result=[]
    for k in keys:
        if (data[keys[k]]<limits[k][0]) | (data[keys[k]]>limits[k][1]): result.append(k)
    return result


def CRQualityCheck(limits,datafile=None,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True):
    """
    Usage:

    CRQualityCheck(qualitycriteria,datafile,dataarray=None,maxblocksize=65536,nsigma=5,verbose=True) -> list of antennas failing the limits

    qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}

    Will step through all antennas of a file assess the data quality
    and return a list with antennas which have failed the quality
    check and their statistical properties.

    Parameters:


    qualitycriteria - a Python dict with keywords of parameters and limits thereof (lower, upper)

    datafile - Data Reader file object, if none, use values in dataarray and don't read in again

    array - an optional data storage array to read in the data

    maxblocksize - The algorithms takes by default the first and last
    quarter of a file but not more samples than given in this
    paramter.

    nsigma - determines for the peak counting algorithm the threshold
    for peak detection in standard deviations

    verbose - sets whether or not to print additional information
    """
#Initialize some parameters
    if not datafile==None:
        nAntennas=datafile.get("nofSelectedAntennas")
        selected_antennas=datafile.get("selectedAntennas")
        filesize=datafile.get("filesize")
        blocksize=min(filesize/4,maxblocksize)
        datafile.set("blocksize",blocksize)
        nBlocks=filesize/blocksize;
        blocklist=range(nBlocks/4)+range(3*nBlocks/4,nBlocks)
        if dataarray==None: dataarray=hArray(float,[nAntennas,blocksize])
    else:
        nAntennas=dataarray.getDim()[0]
        blocksize=dataarray.getDim()[1]
        selected_antennas=range(nAntennas)
        blocklist=[0]
#Create the some scratch vectors
    qualityflaglist=[]
#Calculate probabilities to find certain peaks
    probability=funcGaussian(nsigma,1,0) # what is the probability of a 5 sigma peak
    npeaksexpected=probability*blocksize # what is the probability to see such a peak with the blocksize
    npeakserror=sqrt(npeaksexpected) # what is the statisitcal error on that expectation
#Start checking
    if verbose:
        if not datafile==None: print "Quality checking of file ",datafile.filename
        print "Considering",nAntennas," antennas and the Blocks:",blocklist
        print "Blocksize=",blocksize,", nsigma=",nsigma, ", number of peaks expected per block=",npeaksexpected
    for Block in blocklist:
        if verbose:
            print "\nBlock = ", Block
            print "-----------------------------------------------------------------------------------------"
        if not datafile==None: datafile.set("block",Block).read("Voltage",dataarray.vec())
        datamean = dataarray[...].mean()
        datarms = dataarray[...].stddev(datamean)
        datanpeaks = dataarray[...].countgreaterthanabs(datarms*nsigma)
        dataNonGaussianity = Vector(float,nAntennas)
        dataNonGaussianity.sub(datanpeaks,npeaksexpected)
        dataNonGaussianity /= npeakserror
        dataproperties=zip(selected_antennas,datamean,datarms,datanpeaks,dataNonGaussianity)
        noncompliancelist=[]
        for prop in iter(dataproperties):
            noncompliancelist=CheckParameterConformance(prop,{"mean":1,"rms":2,"nonGaussianity":4},limits)
            if noncompliancelist: qualityflaglist.append([prop[0],Block,prop[1:],noncompliancelist])
            if verbose:
                print "Antenna {0:3d}: mean={1: 6.2f}, rms={2:6.1f}, npeaks={3:5d}, nonGaussianity={4: 7.2f}".format(*prop)," ",noncompliancelist
    return qualityflaglist

#qualitycriteria={"mean":(-15,15),"rms":(5,15),"nonGaussianity":(-3,3)}
#CRQualityCheck(datafile,qualitycriteria,maxblocksize=65536,nsigma=5,verbose=True)

for v in hRealContainerTypes:
    for s in ["hCRAverageSpectrum","hCRFitBaseline"]:
        setattr(v,s[1:].lower(),eval(s))

