//HFDOCSTART: Marks begin of file hftools.doc.cc which is being read by doxygen--------------
//HFDOCSTART: Marks begin of file hftools.doc.cc which is being read by doxygen--------------
/*!
 HFTOOLS Version 0.2 - Basic algorithms for the CR pipeline with
  automatic wrapper generation for python.  Includes various tools to
  manipulate stl vectors in python and wrapper function for CR Tool classes.

========================================================================
Here is a list of the available functions:
========================================================================


SECTION: Administrative Vector Functions
------------------------------
hFill(vec, fill_value)              - Fills a vector with a constant value.
hNew(vec)                           - Make and return a new vector of the same size and type as the input vector
hConvert(vec1, vec2)                - Copies and converts a vector to a vector of another type.
hCopy(vec, outvec)                  - Copies a vector to another one.

SECTION: Math Functions
------------------------------
square(val)                         - Returns the squared value of the parameter
hPhase(frequency, time)             - Returns the interferometer phase in radians for a given frequency and time
funcGaussian(x, sigma, mu)          - Implementation of the Gauss function
hiSub(vec1, vec2)                   - Performs a Sub between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiSub(vec1, val)                    - Performs a Sub between the vector and a scalar (applied to each element), which is returned in the first vector.
hSub(vec1, vec2, vec3)              - Performs a Sub between the two vectors, which is returned in the third vector.
hSubAdd(vec1, vec2, vec3)           - Performs a Sub between the two vectors, and adds the result to the output (third) vector.
hSubAddConv(vec1, vec2, vec3)       - Performs a Sub between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hSub(vec1, val, vec2)               - Performs a Sub between the vector and a scalar, where the result is returned in the second vector.
hiMul(vec1, vec2)                   - Performs a Mul between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiMul(vec1, val)                    - Performs a Mul between the vector and a scalar (applied to each element), which is returned in the first vector.
hMul(vec1, vec2, vec3)              - Performs a Mul between the two vectors, which is returned in the third vector.
hMulAdd(vec1, vec2, vec3)           - Performs a Mul between the two vectors, and adds the result to the output (third) vector.
hMulAddConv(vec1, vec2, vec3)       - Performs a Mul between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hMul(vec1, val, vec2)               - Performs a Mul between the vector and a scalar, where the result is returned in the second vector.
hiAdd(vec1, vec2)                   - Performs a Add between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiAdd(vec1, val)                    - Performs a Add between the vector and a scalar (applied to each element), which is returned in the first vector.
hAdd(vec1, vec2, vec3)              - Performs a Add between the two vectors, which is returned in the third vector.
hAddAdd(vec1, vec2, vec3)           - Performs a Add between the two vectors, and adds the result to the output (third) vector.
hAddAddConv(vec1, vec2, vec3)       - Performs a Add between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hAdd(vec1, val, vec2)               - Performs a Add between the vector and a scalar, where the result is returned in the second vector.
hiDiv(vec1, vec2)                   - Performs a Div between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiDiv(vec1, val)                    - Performs a Div between the vector and a scalar (applied to each element), which is returned in the first vector.
hDiv(vec1, vec2, vec3)              - Performs a Div between the two vectors, which is returned in the third vector.
hDivAdd(vec1, vec2, vec3)           - Performs a Div between the two vectors, and adds the result to the output (third) vector.
hDivAddConv(vec1, vec2, vec3)       - Performs a Div between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hDiv(vec1, val, vec2)               - Performs a Div between the vector and a scalar, where the result is returned in the second vector.
hNegate(vec)                        - Multiplies each element in the vector with -1 in place, i.e. the input vector is also the output vector.
hSum(vec)                           - Performs a sum over the values in a vector and returns the value
hNorm(vec)                          - Returns the lengths or norm of a vector (i.e. Sqrt(Sum_i(xi*+2)))
hNormalize(vec)                     - Normalizes a vector to length unity
hMean(vec)                          - Returns the mean value of all elements in a vector
hSort(vec)                          - Sorts a vector in place
hSortMedian(vec)                    - Sorts a vector in place and returns the median value of the elements
hMedian(vec)                        - Returns the median value of the elements
hStdDev(vec, mean)                  - Calculates the standard deviation around a mean value.
hStdDev(vec)                        - Calculates the standard deviation of a vector of values
hFindLessEqual(vec, threshold, vecout) - Find the samples that are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessEqualAbs(vec, threshold, vecout) - Find the samples whose absolute values are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterThan(vec, threshold, vecout) - Find the samples that are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterThanAbs(vec, threshold, vecout) - Find the samples whose absolute values are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterEqual(vec, threshold, vecout) - Find the samples that are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterEqualAbs(vec, threshold, vecout) - Find the samples whose absolute values are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessThan(vec, threshold, vecout) - Find the samples that are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessThanAbs(vec, threshold, vecout) - Find the samples whose absolute values are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hDownsample(vec1, vec2)             - Downsample the input vector to a smaller output vector.
hDownsample(vec, downsample_factor) - Downsample the input vector by a cetain factor and return a new vector
hFindLowerBound(vec, value)         - Finds the location (i.e., returns integer) in a monotonically increasing vector, where the input search value is just above or equal to the value in the vector.
hFlatWeights(wlen)                  - Returns vector of weights of length len with constant weights normalized to give a sum of unity. Can be used by hRunningAverageT.
hLinearWeights(wlen)                - Returns vector of weights of length wlen with linearly rising and decreasing weights centered at len/2.
hGaussianWeights(wlen)              - Returns vector of weights of length wlen with Gaussian distribution centered at len/2 and sigma=len/4 (i.e. the Gaussian extends over 2 sigma in both directions).
hWeights(wlen, wtype)               - Create a normalized weight vector.
hRunningAverage(idata, odata, weights) - Calculate the running average of an input vector using a weight vector.
hRunningAverage(idata, odata, wlen, wtype) - Overloaded function to automatically calculate weights.

SECTION: RF (Radio Frequency) Functions
------------------------------
hGeometricDelayFarField(antPosition, skyDirection, length) - Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located in a certain direction in farfield (based on L. Bahren)
hGeometricDelayNearField(antPosition, skyPosition, distance) - Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located at a certain 3D space coordinate in nearfield (based on L. Bahren)
hGeometricDelays(antPositions, skyPositions, delays, farfield) - Calculates the time delay in seconds for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field
hGeometricPhases(frequencies, antPositions, skyPositions, phases, farfield) - Calculates the phase gradients for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.
hGeometricWeights(frequencies, antPositions, skyPositions, weights, farfield) - Calculates the phase gradients as complex weights for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.
hSpectralPower(vec, outvec)         - Calculates the power of a complex spectrum and add it to an output vector.

SECTION: I/O Functions (DataReader)
------------------------------
hFileClose(iptr)                    - Function to close a file with a datareader object providing the pointer to the object as an integer.
hFileOpen(Filename)                 - Function to open a file based on a filename and returning a pointer to a datareader object as an integer
hFileGetParameter(iptr, keyword)    - Return information from a data file as a Python object
hFileSetParameter(iptr, keyword, pyob) - Set parameters in a data file with a Python object as input
hFileRead(iptr, Datatype, vec)      - Read data from a Datareader object (pointer in iptr) into a vector, where the size should be pre-allocated.
hCalTable(filename, keyword, date, pyob) - Return a list of antenna positions from the CalTables - this is a test

SECTION: Coordinate Conversion (VectorConversion.cc)
------------------------------
hCoordinateConvert(source, sourceCoordinate, target, targetCoordinate, anglesInDegrees) - Converts a 3D spatial vector into a different Coordinate type (e.g. Spherical to Cartesian)
hReadFileOld(vec, iptr, Datatype, Antenna, Blocksize, Block, Stride, Shift) - Read data from a Datareader object (pointer in iptr) into a vector.



========================================================================
Here is an alphabetic list of some of the functions that are available.
========================================================================

funcGaussian(x, sigma, mu)          - Implementation of the Gauss function
hAdd(vec1, val, vec2)               - Performs a Add between the vector and a scalar, where the result is returned in the second vector.
hAdd(vec1, vec2, vec3)              - Performs a Add between the two vectors, which is returned in the third vector.
hAddAdd(vec1, vec2, vec3)           - Performs a Add between the two vectors, and adds the result to the output (third) vector.
hAddAddConv(vec1, vec2, vec3)       - Performs a Add between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hCalTable(filename, keyword, date, pyob) - Return a list of antenna positions from the CalTables - this is a test
hConvert(vec1, vec2)                - Copies and converts a vector to a vector of another type.
hCopy(vec, outvec)                  - Copies a vector to another one.
hDiv(vec1, val, vec2)               - Performs a Div between the vector and a scalar, where the result is returned in the second vector.
hDiv(vec1, vec2, vec3)              - Performs a Div between the two vectors, which is returned in the third vector.
hDivAdd(vec1, vec2, vec3)           - Performs a Div between the two vectors, and adds the result to the output (third) vector.
hDivAddConv(vec1, vec2, vec3)       - Performs a Div between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hDownsample(vec, downsample_factor) - Downsample the input vector by a cetain factor and return a new vector
hDownsample(vec1, vec2)             - Downsample the input vector to a smaller output vector.
hFileClose(iptr)                    - Function to close a file with a datareader object providing the pointer to the object as an integer.
hFileGetParameter(iptr, keyword)    - Return information from a data file as a Python object
hFileOpen(Filename)                 - Function to open a file based on a filename and returning a pointer to a datareader object as an integer
hFileRead(iptr, Datatype, vec)      - Read data from a Datareader object (pointer in iptr) into a vector, where the size should be pre-allocated.
hFileSetParameter(iptr, keyword, pyob) - Set parameters in a data file with a Python object as input
hFill(vec, fill_value)              - Fills a vector with a constant value.
hFindGreaterEqual(vec, threshold, vecout) - Find the samples that are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterEqualAbs(vec, threshold, vecout) - Find the samples whose absolute values are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterThan(vec, threshold, vecout) - Find the samples that are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindGreaterThanAbs(vec, threshold, vecout) - Find the samples whose absolute values are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessEqual(vec, threshold, vecout) - Find the samples that are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessEqualAbs(vec, threshold, vecout) - Find the samples whose absolute values are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessThan(vec, threshold, vecout) - Find the samples that are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLessThanAbs(vec, threshold, vecout) - Find the samples whose absolute values are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector
hFindLowerBound(vec, value)         - Finds the location (i.e., returns integer) in a monotonically increasing vector, where the input search value is just above or equal to the value in the vector.
hFlatWeights(wlen)                  - Returns vector of weights of length len with constant weights normalized to give a sum of unity. Can be used by hRunningAverageT.
hGaussianWeights(wlen)              - Returns vector of weights of length wlen with Gaussian distribution centered at len/2 and sigma=len/4 (i.e. the Gaussian extends over 2 sigma in both directions).
hGeometricDelayFarField(antPosition, skyDirection, length) - Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located in a certain direction in farfield (based on L. Bahren)
hGeometricDelayNearField(antPosition, skyPosition, distance) - Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located at a certain 3D space coordinate in nearfield (based on L. Bahren)
hGeometricDelays(antPositions, skyPositions, delays, farfield) - Calculates the time delay in seconds for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field
hGeometricPhases(frequencies, antPositions, skyPositions, phases, farfield) - Calculates the phase gradients for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.
hGeometricWeights(frequencies, antPositions, skyPositions, weights, farfield) - Calculates the phase gradients as complex weights for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.
hLinearWeights(wlen)                - Returns vector of weights of length wlen with linearly rising and decreasing weights centered at len/2.
hMean(vec)                          - Returns the mean value of all elements in a vector
hMedian(vec)                        - Returns the median value of the elements
hMul(vec1, val, vec2)               - Performs a Mul between the vector and a scalar, where the result is returned in the second vector.
hMul(vec1, vec2, vec3)              - Performs a Mul between the two vectors, which is returned in the third vector.
hMulAdd(vec1, vec2, vec3)           - Performs a Mul between the two vectors, and adds the result to the output (third) vector.
hMulAddConv(vec1, vec2, vec3)       - Performs a Mul between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hNegate(vec)                        - Multiplies each element in the vector with -1 in place, i.e. the input vector is also the output vector.
hNew(vec)                           - Make and return a new vector of the same size and type as the input vector
hNorm(vec)                          - Returns the lengths or norm of a vector (i.e. Sqrt(Sum_i(xi*+2)))
hNormalize(vec)                     - Normalizes a vector to length unity
hPhase(frequency, time)             - Returns the interferometer phase in radians for a given frequency and time
hReadFileOld(vec, iptr, Datatype, Antenna, Blocksize, Block, Stride, Shift) - Read data from a Datareader object (pointer in iptr) into a vector.
hRunningAverage(idata, odata, weights) - Calculate the running average of an input vector using a weight vector.
hRunningAverage(idata, odata, wlen, wtype) - Overloaded function to automatically calculate weights.
hSort(vec)                          - Sorts a vector in place
hSortMedian(vec)                    - Sorts a vector in place and returns the median value of the elements
hSpectralPower(vec, outvec)         - Calculates the power of a complex spectrum and add it to an output vector.
hStdDev(vec)                        - Calculates the standard deviation of a vector of values
hStdDev(vec, mean)                  - Calculates the standard deviation around a mean value.
hSub(vec1, val, vec2)               - Performs a Sub between the vector and a scalar, where the result is returned in the second vector.
hSub(vec1, vec2, vec3)              - Performs a Sub between the two vectors, which is returned in the third vector.
hSubAdd(vec1, vec2, vec3)           - Performs a Sub between the two vectors, and adds the result to the output (third) vector.
hSubAddConv(vec1, vec2, vec3)       - Performs a Sub between the two vectors, and adds the result to the output (third) vector - automatic casting is done.
hSum(vec)                           - Performs a sum over the values in a vector and returns the value
hWeights(wlen, wtype)               - Create a normalized weight vector.
hiAdd(vec1, val)                    - Performs a Add between the vector and a scalar (applied to each element), which is returned in the first vector.
hiAdd(vec1, vec2)                   - Performs a Add between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiDiv(vec1, val)                    - Performs a Div between the vector and a scalar (applied to each element), which is returned in the first vector.
hiDiv(vec1, vec2)                   - Performs a Div between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiMul(vec1, val)                    - Performs a Mul between the vector and a scalar (applied to each element), which is returned in the first vector.
hiMul(vec1, vec2)                   - Performs a Mul between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
hiSub(vec1, val)                    - Performs a Sub between the vector and a scalar (applied to each element), which is returned in the first vector.
hiSub(vec1, vec2)                   - Performs a Sub between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.
square(val)                         - Returns the squared value of the parameter

*/
//========================================================================
//                 Casting & Conversion Functions
//========================================================================
template<class T> T hfnull(){};
template<> inline HString hfnull<HString>(){HString null=""; return null;}
template<> inline HPointer hfnull<HPointer>(){return __null;}
template<> inline HInteger hfnull<HInteger>(){return 0;}
template<> inline HNumber hfnull<HNumber>(){return 0.0;}
template<> inline HComplex hfnull<HComplex>(){return 0.0;}
//Identity
template<class T> inline T hfcast(/*const*/ T v){return v;}
//Convert to arbitrary class T if not specified otherwise
template<class T> inline T hfcast(uint v){return static_cast<T>(v);}
template<class T> inline T hfcast(HInteger v){return static_cast<T>(v);}
template<class T> inline T hfcast(HNumber v){return static_cast<T>(v);}
template<class T> inline T hfcast(HComplex v){return static_cast<T>(v);}
//Convert Numbers to Numbers and loose information (round float, absolute of complex)
template<> inline HInteger hfcast<HInteger>(HNumber v){return static_cast<HInteger>(floor(v+0.5));}
template<> inline HInteger hfcast<HInteger>(HComplex v){return static_cast<HInteger>(floor(real(v)+0.5));}
template<> inline HNumber hfcast<HNumber>(HComplex v){return real(v);}
inline HInteger ptr2int(HPointer v){return reinterpret_cast<HInteger>(v);}
inline HPointer int2ptr(HInteger v){return reinterpret_cast<HPointer>(v);}
inline HComplex operator*(HInteger i, HComplex c) {return hfcast<HComplex>(i)*c;}
inline HComplex operator*(HComplex c, HInteger i) {return hfcast<HComplex>(i)*c;}
inline HComplex operator+(HInteger i, HComplex c) {return hfcast<HComplex>(i)+c;}
inline HComplex operator+(HComplex c, HInteger i) {return hfcast<HComplex>(i)+c;}
inline HComplex operator-(HInteger i, HComplex c) {return hfcast<HComplex>(i)-c;}
inline HComplex operator-(HComplex c, HInteger i) {return c-hfcast<HComplex>(i);}
inline HComplex operator/(HInteger i, HComplex c) {return hfcast<HComplex>(i)/c;}
inline HComplex operator/(HComplex c, HInteger i) {return c/hfcast<HComplex>(i);}
template <class T>
casa::Vector<T> stl2casa(std::vector<T>& stlvec)
{
  T * storage = &(stlvec[0]);
  casa::IPosition shape(1,stlvec.size()); //tell casa the size of the vector
  casa::Vector<T> casavec(shape,storage,casa::SHARE);
  return casavec;
}
vector<HNumber> PyList2STLFloatVec(PyObject* pyob){
  std::vector<HNumber> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyFloat_AsDouble(PyList_GetItem(pyob,i)));
  }
  return vec;
}
vector<HInteger> PyList2STLIntVec(PyObject* pyob){
  std::vector<HInteger> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyInt_AsLong(PyList_GetItem(pyob,i)));
  }
  return vec;
}
vector<uint> PyList2STLuIntVec(PyObject* pyob){
  std::vector<uint> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyInt_AsLong(PyList_GetItem(pyob,i)));
  }
  return vec;
}
template <class S, class T>
void aipscol2stlvec(casa::Matrix<S> &data, std::vector<T>& stlvec, const HInteger col){
    HInteger i,nrow,ncol;
    nrow=data.nrow();
    ncol=data.ncolumn();
    //    if (ncol>1) {MSG("aipscol2stlvec: ncol="<<ncol <<" (nrow="<<nrow<<")");};
    if (col>=ncol) {
 ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 320 << ": " << "aipscol2stlvec: column number col=" << col << " is larger than total number of columns (" << ncol << ") in matrix." << endl );
 stlvec.clear();
 return;
    }
    stlvec.resize(nrow);
    casa::Vector<S> CASAVec = data.column(col);
//    p=stlvec.begin();
    for (i=0;i<nrow;i++) {
//	*p=hfcast<T>(CASAVec[i]);
 stlvec[i]=hfcast<T>(CASAVec[i]);
//	p++;
    };
}
/*!
  \brief The function converts an aips++ vector to an stl vector
 */
template <class S, class T>
void aipsvec2stlvec(casa::Vector<S>& data, std::vector<T>& stlvec){
    HInteger i,n;
//    std::vector<R>::iterator p;
    n=data.size();
    stlvec.resize(n);
//    p=stlvec.begin();
    for (i=0;i<n;i++) {
//	*p=hfcast<T>(data[i]);
 stlvec[i]=hfcast<T>(data[i]);
//	++p;
    };
}
//This function is copied from hfget.cc since I don't know a better
//way to do a proper instantiation of a templated function across two
//cpp files ..
template <class T, class S>
void copycast_vec(std::vector<T> &vi, std::vector<S> & vo) {
  typedef typename std::vector<T>::iterator Tit;
  typedef typename std::vector<S>::iterator Sit;
  Tit it1=vi.begin();
  Tit end=vi.end();
  if (it1==end) {vo.clear();}
  else {
    vo.assign(vi.size(),hfnull<S>()); //make the new vector equal in size and initialize with proper Null values
    Sit it2=vo.begin();
    while (it1!=end) {
      *it2=hfcast<S>(*it1);
      it1++; it2++;
    };
  };
}
//========================================================================
//                             Array Class 
//========================================================================
//! Testing a rudimentary Array class, that allows contiguous slicing
template <class T> void hArray<T>::init(){
  vec_p=__null;
  number_of_dimensions=0;
  dimensions_p = new std::vector<HInteger>();
  doiterate=false;
}
template <class T> hArray<T>::hArray(std::vector<T> & vec){
  init();
  setVector(vec);
}
template <class T> hArray<T>::hArray(){
  init();
  std::vector<T>* internal_vector=new std::vector<T>();
  setVector(*internal_vector);
  vector_is_internal=true;
}
template <class T> void hArray<T>::delVector(){
  if ((vec_p != __null) && vector_is_internal) delete vec_p;
  vec_p=__null;
}
template <class T> hArray<T>::~hArray(){
  delVector();
  if (dimensions_p != __null) delete dimensions_p;
}
/*!
\brief Set the vector to be stored (as reference, hence no copy is made). Creation and destruction of this vector has to be done outside this class!!
 */
template <class T> hArray<T>& hArray<T>::setVector(std::vector<T> & vec){
  delVector();
  vec_p=&vec;
  vector_size=vec.size();
  setDimensions1(vector_size);
  setSlice(0,vector_size);
  vector_is_internal=false;
  return *this;
}
/*!
\brief Retrieve the stored vector (returned as reference, hence no copy is made).
 */
template <class T> std::vector<T> & hArray<T>::Vector(){
  return *vec_p;
}
/*!
\brief Retrieve the stored vector (returned as reference, hence no copy is made).
 */
template <class T> std::vector<HInteger> hArray<T>::getDimensions(){
  return *dimensions_p;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> hArray<T>& hArray<T>::setDimensions1(HInteger dim0){
  number_of_dimensions=1;
  if (dimensions_p->size()!=(uint)number_of_dimensions) dimensions_p->resize(number_of_dimensions);
  (*dimensions_p)[0]=dim0;
  vector_size=hProduct<HInteger>(*dimensions_p);
  if (vec_p->size() != (uint)vector_size) vec_p->resize(vector_size);
  return *this;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> hArray<T>& hArray<T>::setDimensions2(HInteger dim0, HInteger dim1){
  number_of_dimensions=2;
  if (dimensions_p->size()!=(uint)number_of_dimensions) dimensions_p->resize(number_of_dimensions);
  (*dimensions_p)[0]=dim0;
  (*dimensions_p)[1]=dim1;
  vector_size=hProduct<HInteger>(*dimensions_p);
  if ((uint)vector_size != vec_p->size()) vec_p->resize(vector_size);
  return *this;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> hArray<T>& hArray<T>::setDimensions3(HInteger dim0, HInteger dim1, HInteger dim2){
  number_of_dimensions=3;
  if (dimensions_p->size()!=(uint)number_of_dimensions) dimensions_p->resize(number_of_dimensions);
  (*dimensions_p)[0]=dim0;
  (*dimensions_p)[1]=dim1;
  (*dimensions_p)[2]=dim2;
  vector_size=hProduct<HInteger>(*dimensions_p);
  if ((uint)vector_size != vec_p->size()) vec_p->resize(vector_size);
  return *this;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> hArray<T>& hArray<T>::setDimensions4(HInteger dim0, HInteger dim1, HInteger dim2, HInteger dim3){
  number_of_dimensions=4;
  if (dimensions_p->size()!=(uint)number_of_dimensions) dimensions_p->resize(number_of_dimensions);
  (*dimensions_p)[0]=dim0;
  (*dimensions_p)[1]=dim1;
  (*dimensions_p)[2]=dim2;
  (*dimensions_p)[3]=dim3;
  vector_size=hProduct<HInteger>(*dimensions_p);
  if ((uint)vector_size != vec_p->size()) vec_p->resize(vector_size);
  return *this;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> hArray<T>& hArray<T>::setDimensions5(HInteger dim0, HInteger dim1, HInteger dim2, HInteger dim3, HInteger dim4){
  number_of_dimensions=5;
  if (dimensions_p->size()!=(uint)number_of_dimensions) dimensions_p->resize(number_of_dimensions);
  (*dimensions_p)[0]=dim0;
  (*dimensions_p)[1]=dim1;
  (*dimensions_p)[2]=dim2;
  (*dimensions_p)[3]=dim3;
  (*dimensions_p)[4]=dim4;
  vector_size=hProduct<HInteger>(*dimensions_p);
  if ((uint)vector_size != vec_p->size()) vec_p->resize(vector_size);
  return *this;
}
/*!
\brief Sets begin and end the currently active slice using integer offsets from the begin of the stored vector. Use (0,size(vector)) to get the full vector
 */
template <class T> hArray<T>& hArray<T>::setSlice(HInteger beg, HInteger end){
  slice_begin=max(beg,0);
  if (end>=0) slice_end=min(end,vector_size);
  else slice_end=vector_size;
  slice_it_begin=vec_p->begin()+slice_begin;
  slice_it_end=vec_p->begin()+slice_end;
  return *this;
}
/*!
\brief Returns the number of dimensions that have been associated with the current array
 */
template <class T> HInteger hArray<T>::getNumberOfDimensions(){return number_of_dimensions;}
/*!
\brief Returns the begin iterator of the current slice in the stored vector plus an integer offset (to get a slice from a slice)
 */
template <class T> typename std::vector<T>::iterator hArray<T>::begin(HInteger offset){return slice_it_begin+offset;}
/*!
\brief Returns the begin iterator of the current slice in the stored vector plus an integer offset (to get a slice from a slice) but not larger than the end iterator of the current slice.
 */
template <class T> typename std::vector<T>::iterator hArray<T>::end(HInteger offset){return min(slice_it_begin+offset,slice_it_end);}
/*!
\brief Returns the begin iterator of the current slice in the stored vector
 */
template <class T> typename std::vector<T>::iterator hArray<T>::begin(){return slice_it_begin;}
/*!
\brief Returns the end iterator of the current slice in the stored vector
 */
template <class T> typename std::vector<T>::iterator hArray<T>::end(){return slice_it_end;}
/*!
\brief Returns the offset of the current slice from the begin iterator of the stored vector
 */
template <class T> HInteger hArray<T>::getBegin(){return slice_begin;}
/*!
\brief Returns the offset of the end of the current slice from the begin iterator of the stored vector
 */
template <class T> HInteger hArray<T>::getEnd(){return slice_end;}
/*!
\brief Returns the size (length) of the current slice
 */
template <class T> HInteger hArray<T>::getSize(){return slice_size;}
/*!
\brief Returns the length of the underlying vector
 */
template <class T> HInteger hArray<T>::length(){return vec_p->size();}
/*!
\brief Returns the size (length) of the current slice
 */
template <class T> hArray<T>& hArray<T>::setSize(HInteger size){slice_size=size; return *this;}
/*!
\brief Returns whether or not to iterate over all slices in the vector
 */
template <class T> bool hArray<T>::iterate(){return doiterate;}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector)
 */
template <class T> hArray<T>& hArray<T>::loop(){doiterate=true; return *this;}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector)
 */
template <class T> hArray<T>& hArray<T>::noloop(){doiterate=false; return *this;}
/*!
\brief Reset the slice iterators to the first slice
*/
template <class T> hArray<T>& hArray<T>::reset(){ return *this;
  setSlice(0,getSize());
}
/*!
\brief Increase the current slice by one, if array is in looping mode. 

If the end of the vector is reached, switch looping mode off and reset array to first slice.
 */
template <class T> hArray<T>& hArray<T>::next(){
  if (slice_end>=length()) { // the end has been reached
    reset();
    noloop();
  } else {
    setSlice(slice_begin+slice_size,slice_end+slice_size);
  };
  return *this;
}
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return the offset of the current slice from the begin pointer

    \param pyob: Python hArray Object


Example:
antennaIDs=hFileGetParameter(file,"AntennaIDs")
x=hCalTable("~/LOFAR/usg/data/lopes/LOPES-CalTable",obsdate,list(antennaIDs))

*/
HInteger hArray_intBegin(HPyObjectPtr pyobj) {
//   if (!PyObject_HasAttrString(pyob, "ArrayType")) {
//     HPyObjectPtr objrepr=PyObject_Repr(pyobj);
//     char * objrepr_str= PyString_AsString(objrepr);
//     ERROR(BOOST_PP_STRINGIZE(HFPP_FUNC_NAME) << ": Object is not of hArray type;");
//     return 0;
//   }
//   HPyObjectPtr list=PyList_New(0),tuple;
//   if (CTRead != NULL && PyList_Check(pyob)) {  //Check if CalTable was opened ... and Python object is a list
//     size=PyList_Size(pyob);
//     for (i=0;i<size;++i){  //loop over all antennas
//       ant=PyInt_AsLong(PyList_GetItem(pyob,i));  //Get the ith element of the list, i.e. the antenna ID
//       CTRead->GetData((uint)date, ant, keyword, &tmpvec);
//       tuple=PyTuple_Pack(3,PyFloat_FromDouble(tmpvec[0]),PyFloat_FromDouble(tmpvec[1]),PyFloat_FromDouble(tmpvec[2]));
//       PyList_Append(list,tuple);
//     };
//   };
//   return list;
  return 0;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HInteger (*fptr_hArray_intBegin_STL_HInteger_HPyObjectPtr_)( HPyObjectPtr pyob) = &hArray_intBegin;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//                        Helper Functions
//========================================================================
/*!
\brief Determine the filetype based on the extension of the filename
 */
HString hgetFiletype(HString filename){
  HString ext=hgetFileExtension(filename);
  HString typ="";
  if (ext=="event") typ="LOPESEvent";
  else if (ext=="h5") typ="LOFAR_TBB";
  return typ;
}
/*!
\brief Get the extension of the filename, i.e. the text after the last dot.
 */
HString hgetFileExtension(HString filename){
  HInteger size=filename.size();
  HInteger pos=filename.rfind('.',size);
  pos++;
  if (pos>=size) {return "";}
  else {return filename.substr(pos,size-pos);};
}
//========================================================================
//$SECTION:           Administrative Vector Function
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Fills a vector with a constant value.

    \param vec: Numeric input vector

    \param fill_value: Fill value

*/
template <class Iter>
void hFill(const Iter vec,const Iter vec_end, const typename Iter::value_type fill_value)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=fill_value;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hFill( std::vector<T> & vec , T fill_value) {
hFill ( vec.begin(),vec.end() , fill_value);
}

template < class T > inline void hFill( hArray<T> & vec , T fill_value) {
bool iterate=true;
while(iterate) {
hFill ( vec.begin(),vec.end() , fill_value);
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hFill( casa::Vector<T> & vec , T fill_value) {
hFill ( vec.cbegin(),vec.cend() , fill_value);
}


void (*fptr_hFill_STL_HString_11_STDIT)( std::vector<HString> & vec , HString fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HString_11_STDIT)( hArray<HString> & vec , HString fill_value) = &hFill;
void (*fptr_hFill_STL_HBool_11_STDIT)( std::vector<HBool> & vec , HBool fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HBool_11_STDIT)( hArray<HBool> & vec , HBool fill_value) = &hFill;
void (*fptr_hFill_STL_HComplex_11_STDIT)( std::vector<HComplex> & vec , HComplex fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HComplex_11_STDIT)( hArray<HComplex> & vec , HComplex fill_value) = &hFill;
void (*fptr_hFill_STL_HNumber_11_STDIT)( std::vector<HNumber> & vec , HNumber fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HNumber_11_STDIT)( hArray<HNumber> & vec , HNumber fill_value) = &hFill;
void (*fptr_hFill_STL_HInteger_11_STDIT)( std::vector<HInteger> & vec , HInteger fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HInteger_11_STDIT)( hArray<HInteger> & vec , HInteger fill_value) = &hFill;

template < class T > inline void hFill_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T fill_value ) {
hFill ( vec.begin() + vecslice1,vec.begin() + vecslice2 , fill_value);
}

template < class T > inline void hFill_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T fill_value ) {
hFill ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , fill_value);
}


void (*fptr_hFill_hSLICED_STL_HString_11_STDIT)( std::vector<HString> & vec , HInteger vecslice1 , HInteger vecslice2 , HString fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HBool_11_STDIT)( std::vector<HBool> & vec , HInteger vecslice1 , HInteger vecslice2 , HBool fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HComplex_11_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HComplex fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HNumber_11_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HInteger_11_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger fill_value ) = &hFill_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Make and return a new vector of the same size and type as the input vector.

    \param vec: Input vector

*/
template <class T>
std::vector<T> hNew(std::vector<T> & vec)
{
  std::vector<T> vnew(vec.size());
  return vnew;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HString> (*fptr_hNew_STL_HString_1_STL)( std::vector<HString> & vec) = &hNew;
std::vector<HBool> (*fptr_hNew_STL_HBool_1_STL)( std::vector<HBool> & vec) = &hNew;
std::vector<HComplex> (*fptr_hNew_STL_HComplex_1_STL)( std::vector<HComplex> & vec) = &hNew;
std::vector<HNumber> (*fptr_hNew_STL_HNumber_1_STL)( std::vector<HNumber> & vec) = &hNew;
std::vector<HInteger> (*fptr_hNew_STL_HInteger_1_STL)( std::vector<HInteger> & vec) = &hNew;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a vector to a new length.

    \param vec: Input vector

    \param newsize: New size of vector

 */
template <class T>
void hResize(std::vector<T> & vec, HInteger newsize)
{
  vec.resize(newsize);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HString_1HInteger_STL)( std::vector<HString> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HBool_1HInteger_STL)( std::vector<HBool> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HComplex_1HInteger_STL)( std::vector<HComplex> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HNumber_1HInteger_STL)( std::vector<HNumber> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HInteger_1HInteger_STL)( std::vector<HInteger> & vec , HInteger newsize) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a vector to a new length and fill new elements in vector with a specific value.

    \param vec: Input vector

    \param newsize: New size

    \param fill: Value to fill new vector elements with

*/
template <class T>
void hResize(std::vector<T> & vec, HInteger newsize, T fill)
{
  vec.resize(newsize,fill);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HString_1HInteger1_STL)( std::vector<HString> & vec , HInteger newsize , HString fill) = &hResize;
void (*fptr_hResize_STL_HBool_1HInteger1_STL)( std::vector<HBool> & vec , HInteger newsize , HBool fill) = &hResize;
void (*fptr_hResize_STL_HComplex_1HInteger1_STL)( std::vector<HComplex> & vec , HInteger newsize , HComplex fill) = &hResize;
void (*fptr_hResize_STL_HNumber_1HInteger1_STL)( std::vector<HNumber> & vec , HInteger newsize , HNumber fill) = &hResize;
void (*fptr_hResize_STL_HInteger_1HInteger1_STL)( std::vector<HInteger> & vec , HInteger newsize , HInteger fill) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize an STL vector to the same length as a second vector.

    \param vec1: Input vector to be resized

    \param vec2: Reference vector

*/
template <class T, class S>
void hResize(std::vector<T> & vec1,std::vector<S> & vec2)
{
  vec1.resize(vec2.size());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HStringHString_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHBool_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHComplex_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHNumber_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHInteger_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHString_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHBool_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHComplex_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHNumber_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHInteger_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHString_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHBool_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHComplex_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHNumber_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHInteger_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHString_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHBool_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHComplex_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHNumber_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHInteger_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHString_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHBool_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHComplex_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHNumber_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHInteger_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a casa vector to the same length as a second vector.

    \param vec1: Input vector to be resized

    \param vec2: Reference vector

*/
template <class T, class S>
void hResize(casa::Vector<T> & vec1,casa::Vector<S> & vec2)
{
  vec1.resize(*(vec2.shape().begin()));
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HStringHString_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHBool_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHComplex_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHNumber_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHInteger_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHString_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHBool_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHComplex_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHNumber_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHInteger_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHString_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHBool_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHComplex_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHNumber_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHInteger_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHString_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHBool_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHComplex_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHNumber_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHInteger_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHString_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHBool_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHComplex_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHNumber_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHInteger_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Copies and converts a vector to a vector of another type.

    \param vec1: Numeric input vector

    \param vec2: Vector containing a copy of the input values converted to a new type

*/
template <class Iterin, class Iter>
void hConvert(const Iterin vec1,const Iterin vec1_end, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin it=vec1;
  Iter itout=vec2;
  while ((it!=vec1_end) && (itout !=vec2_end)) {
    *itout=hfcast<T>(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hConvert( std::vector<T> & vec1 , std::vector<S> & vec2) {
hResize(vec2,vec1); hConvert ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}


void (*fptr_hConvert_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hConvert;

template < class T , class S > inline void hConvert_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hResize(vec2,vec1); hConvert ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hConvert_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hResize(vec2,vec1); hConvert ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hConvert_hSLICED_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Copies a vector to another one.

    \param vec: Input vector

    \param outvec: Vector containing a copy of the input values

*/
template <class Iterin, class Iter>
void hCopy(const Iterin vec,const Iterin vec_end, const Iter out,const Iter out_end)
{
  typedef typename Iter::value_type T;
  Iterin it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=*it;
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCopy( std::vector<T> & vec , std::vector<T> & outvec) {
hCopy ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
}

template < class T > inline void hCopy( hArray<T> & vec , hArray<T> & outvec) {
bool iterate=true;
while(iterate) {
hCopy ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
vec.next();
outvec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCopy( casa::Vector<T> & vec , casa::Vector<T> & outvec) {
hCopy ( vec.cbegin(),vec.cend() , outvec.cbegin(),outvec.cend());
}


void (*fptr_hCopy_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & outvec) = &hCopy;
void (*fptr_hCopy_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & outvec) = &hCopy;
void (*fptr_hCopy_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & outvec) = &hCopy;

template < class T > inline void hCopy_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hCopy ( vec.begin() + vecslice1,vec.begin() + vecslice2 , outvec.begin() + outvecslice1,outvec.begin() + outvecslice2);
}

template < class T > inline void hCopy_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hCopy ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , outvec.cbegin() + outvecslice1,outvec.cbegin() + outvecslice2);
}


void (*fptr_hCopy_hSLICED_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;
void (*fptr_hCopy_hSLICED_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;
void (*fptr_hCopy_hSLICED_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$SECTION:                 Math Function
//========================================================================
//------------------------------------------------------------------------
/*!
 \brief Returns the squared value of the parameter.

    \param val: Value to be squared

*/
template <class T>
inline T square(T val)
{
  return val*val;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HComplex (*fptr_square_STL_HComplex_1_)( HComplex val) = &square;
HNumber (*fptr_square_STL_HNumber_1_)( HNumber val) = &square;
HInteger (*fptr_square_STL_HInteger_1_)( HInteger val) = &square;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Returns the interferometer phase in radians for a given frequency and time.

    \param frequency: Frequency in Hz

    \param time: Time in seconds

*/
inline HNumber hPhase(HNumber frequency, HNumber time)
{
  return CR::_2pi*frequency*time;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_hPhase_STL_HInteger_HNumberHNumber_)( HNumber frequency , HNumber time) = &hPhase;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Implementation of the Gauss function.

    \param x: Position at which the Gaussian is evaluated

    \param sigma: Width of the Gaussian

    \param mu: Mean value of the Gaussian

*/
inline HNumber funcGaussian (HNumber x,
        HNumber sigma,
        HNumber mu)
{
  return exp(-(x-mu)*(x-mu)/(2*sigma*sigma))/(sigma*sqrt(2*casa::C::pi));
};
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_funcGaussian_STL_HInteger_HNumberHNumberHNumber_)( HNumber x , HNumber sigma , HNumber mu) = &funcGaussian;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$ITERATE MFUNC abs,cos,cosh,exp,log,log10,sin,sinh,sqrt,square,tan,tanh
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the exp of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hExp1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=exp(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hExp( std::vector<T> & vec) {
hExp1 ( vec.begin(),vec.end());
}

template < class T > inline void hExp( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hExp1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hExp( casa::Vector<T> & vec) {
hExp1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hExp1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hExp;
void (*fptr_hExp1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hExp;
void (*fptr_hExp1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hExp;

template < class T > inline void hExp_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hExp1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hExp_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hExp1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hExp_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the exp of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hExp2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=exp(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hExp( std::vector<T> & vec , std::vector<T> & vecout) {
hExp2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hExp( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hExp2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hExp( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hExp2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hExp2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hExp;
void (*fptr_hExp2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hExp;
void (*fptr_hExp2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hExp;

template < class T > inline void hExp_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hExp2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hExp_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hExp2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hExp_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the log of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hLog1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=log(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog( std::vector<T> & vec) {
hLog1 ( vec.begin(),vec.end());
}

template < class T > inline void hLog( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hLog1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hLog( casa::Vector<T> & vec) {
hLog1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hLog1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hLog;
void (*fptr_hLog1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hLog;
void (*fptr_hLog1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hLog;

template < class T > inline void hLog_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hLog_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hLog_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the log of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hLog2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=log(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog( std::vector<T> & vec , std::vector<T> & vecout) {
hLog2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hLog( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hLog2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hLog( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hLog2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hLog2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hLog;
void (*fptr_hLog2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hLog;
void (*fptr_hLog2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hLog;

template < class T > inline void hLog_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hLog_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hLog_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the log10 of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hLog101(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=log10(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog10( std::vector<T> & vec) {
hLog101 ( vec.begin(),vec.end());
}

template < class T > inline void hLog10( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hLog101 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hLog10( casa::Vector<T> & vec) {
hLog101 ( vec.cbegin(),vec.cend());
}


void (*fptr_hLog101_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hLog10;
void (*fptr_hLog101_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hLog10;
void (*fptr_hLog101_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hLog10;

template < class T > inline void hLog10_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog101 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hLog10_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog101 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hLog10_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the log10 of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hLog102(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=log10(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog10( std::vector<T> & vec , std::vector<T> & vecout) {
hLog102 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hLog10( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hLog102 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hLog10( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hLog102 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hLog102_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hLog10;
void (*fptr_hLog102_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hLog10;
void (*fptr_hLog102_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hLog10;

template < class T > inline void hLog10_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog102 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hLog10_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog102 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hLog10_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sin of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSin1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sin(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSin( std::vector<T> & vec) {
hSin1 ( vec.begin(),vec.end());
}

template < class T > inline void hSin( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSin1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSin( casa::Vector<T> & vec) {
hSin1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hSin1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSin;
void (*fptr_hSin1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSin;
void (*fptr_hSin1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSin;

template < class T > inline void hSin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSin1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSin1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSin_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sin of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSin2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sin(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSin( std::vector<T> & vec , std::vector<T> & vecout) {
hSin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSin( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSin( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSin2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hSin2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSin;
void (*fptr_hSin2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSin;
void (*fptr_hSin2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSin;

template < class T > inline void hSin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSin2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSin2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSin_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sinh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSinh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sinh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSinh( std::vector<T> & vec) {
hSinh1 ( vec.begin(),vec.end());
}

template < class T > inline void hSinh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSinh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSinh( casa::Vector<T> & vec) {
hSinh1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hSinh1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSinh;
void (*fptr_hSinh1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSinh;
void (*fptr_hSinh1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSinh;

template < class T > inline void hSinh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSinh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSinh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSinh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSinh_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sinh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSinh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sinh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSinh( std::vector<T> & vec , std::vector<T> & vecout) {
hSinh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSinh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSinh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSinh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSinh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hSinh2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSinh;
void (*fptr_hSinh2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSinh;
void (*fptr_hSinh2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSinh;

template < class T > inline void hSinh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSinh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSinh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSinh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSinh_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sqrt of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSqrt1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sqrt(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSqrt( std::vector<T> & vec) {
hSqrt1 ( vec.begin(),vec.end());
}

template < class T > inline void hSqrt( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSqrt1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSqrt( casa::Vector<T> & vec) {
hSqrt1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hSqrt1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSqrt;
void (*fptr_hSqrt1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSqrt;
void (*fptr_hSqrt1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSqrt;

template < class T > inline void hSqrt_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSqrt1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSqrt_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSqrt1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSqrt_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sqrt of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSqrt2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sqrt(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSqrt( std::vector<T> & vec , std::vector<T> & vecout) {
hSqrt2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSqrt( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSqrt2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSqrt( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSqrt2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hSqrt2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSqrt;
void (*fptr_hSqrt2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSqrt;
void (*fptr_hSqrt2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSqrt;

template < class T > inline void hSqrt_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSqrt2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSqrt_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSqrt2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSqrt_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the square of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSquare1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=square(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSquare( std::vector<T> & vec) {
hSquare1 ( vec.begin(),vec.end());
}

template < class T > inline void hSquare( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSquare1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSquare( casa::Vector<T> & vec) {
hSquare1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hSquare1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSquare;
void (*fptr_hSquare1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSquare;
void (*fptr_hSquare1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSquare;

template < class T > inline void hSquare_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSquare1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSquare_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSquare1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSquare_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the square of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSquare2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=square(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSquare( std::vector<T> & vec , std::vector<T> & vecout) {
hSquare2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSquare( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSquare2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSquare( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSquare2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hSquare2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSquare;
void (*fptr_hSquare2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSquare;
void (*fptr_hSquare2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSquare;

template < class T > inline void hSquare_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSquare2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSquare_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSquare2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSquare_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the tan of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hTan1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=tan(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTan( std::vector<T> & vec) {
hTan1 ( vec.begin(),vec.end());
}

template < class T > inline void hTan( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hTan1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hTan( casa::Vector<T> & vec) {
hTan1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hTan1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hTan;
void (*fptr_hTan1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hTan;
void (*fptr_hTan1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hTan;

template < class T > inline void hTan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTan1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hTan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTan1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hTan_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the tan of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hTan2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=tan(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTan( std::vector<T> & vec , std::vector<T> & vecout) {
hTan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hTan( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hTan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hTan( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hTan2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hTan2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hTan;
void (*fptr_hTan2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hTan;
void (*fptr_hTan2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hTan;

template < class T > inline void hTan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTan2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hTan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTan2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hTan_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the tanh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hTanh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=tanh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTanh( std::vector<T> & vec) {
hTanh1 ( vec.begin(),vec.end());
}

template < class T > inline void hTanh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hTanh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hTanh( casa::Vector<T> & vec) {
hTanh1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hTanh1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hTanh;
void (*fptr_hTanh1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hTanh;
void (*fptr_hTanh1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hTanh;

template < class T > inline void hTanh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTanh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hTanh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTanh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hTanh_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the tanh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hTanh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=tanh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTanh( std::vector<T> & vec , std::vector<T> & vecout) {
hTanh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hTanh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hTanh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hTanh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hTanh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hTanh2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hTanh;
void (*fptr_hTanh2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hTanh;
void (*fptr_hTanh2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hTanh;

template < class T > inline void hTanh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTanh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hTanh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTanh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hTanh_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the abs of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAbs1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=abs(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAbs( std::vector<T> & vec) {
hAbs1 ( vec.begin(),vec.end());
}

template < class T > inline void hAbs( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAbs1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hAbs( casa::Vector<T> & vec) {
hAbs1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hAbs1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hAbs;
void (*fptr_hAbs1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hAbs;
void (*fptr_hAbs1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hAbs;

template < class T > inline void hAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAbs1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAbs1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAbs_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the abs of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hAbs2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=abs(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAbs( std::vector<T> & vec , std::vector<T> & vecout) {
hAbs2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hAbs( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hAbs2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hAbs( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hAbs2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hAbs2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hAbs;
void (*fptr_hAbs2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAbs;
void (*fptr_hAbs2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAbs;

template < class T > inline void hAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAbs2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAbs2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAbs_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the cos of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCos1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=cos(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCos( std::vector<T> & vec) {
hCos1 ( vec.begin(),vec.end());
}

template < class T > inline void hCos( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCos1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCos( casa::Vector<T> & vec) {
hCos1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hCos1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hCos;
void (*fptr_hCos1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hCos;
void (*fptr_hCos1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hCos;

template < class T > inline void hCos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCos1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCos1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCos_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the cos of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hCos2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=cos(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCos( std::vector<T> & vec , std::vector<T> & vecout) {
hCos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hCos( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hCos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCos( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hCos2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hCos2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hCos;
void (*fptr_hCos2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCos;
void (*fptr_hCos2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCos;

template < class T > inline void hCos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCos2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hCos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCos2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCos_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the cosh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCosh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=cosh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCosh( std::vector<T> & vec) {
hCosh1 ( vec.begin(),vec.end());
}

template < class T > inline void hCosh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCosh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCosh( casa::Vector<T> & vec) {
hCosh1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hCosh1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hCosh;
void (*fptr_hCosh1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hCosh;
void (*fptr_hCosh1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hCosh;

template < class T > inline void hCosh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCosh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCosh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCosh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCosh_hSLICED1_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the cosh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hCosh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=cosh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCosh( std::vector<T> & vec , std::vector<T> & vecout) {
hCosh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hCosh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hCosh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCosh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hCosh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hCosh2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hCosh;
void (*fptr_hCosh2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCosh;
void (*fptr_hCosh2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCosh;

template < class T > inline void hCosh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCosh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hCosh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCosh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCosh_hSLICED2_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED2_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED2_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//========================================================================
//$ITERATE MFUNC acos,asin,atan,ceil,floor
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the ceil of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCeil1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=ceil(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCeil( std::vector<T> & vec) {
hCeil1 ( vec.begin(),vec.end());
}

template < class T > inline void hCeil( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCeil1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hCeil( casa::Vector<T> & vec) {
hCeil1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hCeil1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hCeil;
void (*fptr_hCeil1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hCeil;
void (*fptr_hCeil1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hCeil;
void (*fptr_hCeil1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hCeil;

template < class T > inline void hCeil_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCeil1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCeil_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCeil1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCeil_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCeil_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the ceil of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hCeil2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=ceil(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hCeil( std::vector<T> & vec , std::vector<S> & vecout) {
hCeil2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hCeil( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hCeil2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T , class S > inline void hCeil( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hCeil2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hCeil2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCeil;

template < class T , class S > inline void hCeil_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCeil2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hCeil_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCeil2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCeil_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the floor of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hFloor1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=floor(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hFloor( std::vector<T> & vec) {
hFloor1 ( vec.begin(),vec.end());
}

template < class T > inline void hFloor( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hFloor1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hFloor( casa::Vector<T> & vec) {
hFloor1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hFloor1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hFloor;
void (*fptr_hFloor1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hFloor;
void (*fptr_hFloor1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hFloor;
void (*fptr_hFloor1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hFloor;

template < class T > inline void hFloor_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hFloor1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hFloor_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hFloor1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hFloor_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hFloor_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the floor of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hFloor2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=floor(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hFloor( std::vector<T> & vec , std::vector<S> & vecout) {
hFloor2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hFloor( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hFloor2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T , class S > inline void hFloor( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hFloor2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hFloor2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hFloor;

template < class T , class S > inline void hFloor_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hFloor2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hFloor_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hFloor2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hFloor_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the acos of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAcos1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=acos(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAcos( std::vector<T> & vec) {
hAcos1 ( vec.begin(),vec.end());
}

template < class T > inline void hAcos( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAcos1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hAcos( casa::Vector<T> & vec) {
hAcos1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hAcos1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hAcos;
void (*fptr_hAcos1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hAcos;
void (*fptr_hAcos1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hAcos;
void (*fptr_hAcos1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hAcos;

template < class T > inline void hAcos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAcos1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAcos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAcos1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAcos_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAcos_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the acos of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAcos2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=acos(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAcos( std::vector<T> & vec , std::vector<S> & vecout) {
hAcos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAcos( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAcos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T , class S > inline void hAcos( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAcos2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hAcos2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAcos;

template < class T , class S > inline void hAcos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAcos2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAcos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAcos2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAcos_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the asin of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAsin1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=asin(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAsin( std::vector<T> & vec) {
hAsin1 ( vec.begin(),vec.end());
}

template < class T > inline void hAsin( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAsin1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hAsin( casa::Vector<T> & vec) {
hAsin1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hAsin1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hAsin;
void (*fptr_hAsin1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hAsin;
void (*fptr_hAsin1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hAsin;
void (*fptr_hAsin1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hAsin;

template < class T > inline void hAsin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAsin1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAsin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAsin1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAsin_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAsin_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the asin of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAsin2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=asin(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAsin( std::vector<T> & vec , std::vector<S> & vecout) {
hAsin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAsin( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAsin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T , class S > inline void hAsin( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAsin2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hAsin2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAsin;

template < class T , class S > inline void hAsin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAsin2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAsin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAsin2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAsin_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the atan of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAtan1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=atan(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAtan( std::vector<T> & vec) {
hAtan1 ( vec.begin(),vec.end());
}

template < class T > inline void hAtan( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAtan1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hAtan( casa::Vector<T> & vec) {
hAtan1 ( vec.cbegin(),vec.cend());
}


void (*fptr_hAtan1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hAtan;
void (*fptr_hAtan1_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hAtan;
void (*fptr_hAtan1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hAtan;
void (*fptr_hAtan1_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hAtan;

template < class T > inline void hAtan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAtan1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAtan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAtan1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAtan_hSLICED1_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED1_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAtan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the atan of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAtan2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=atan(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAtan( std::vector<T> & vec , std::vector<S> & vecout) {
hAtan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAtan( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAtan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

template < class T , class S > inline void hAtan( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAtan2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hAtan2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAtan;

template < class T , class S > inline void hAtan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAtan2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAtan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAtan2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAtan_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//========================================================================
//$ITERATE MFUNC Mul,Add,Div,Sub
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hiSub(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 -= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiSub( std::vector<T> & vec1 , std::vector<S> & vec2) {
hiSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hiSub( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hiSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiSub( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hiSub ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hiSub_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HComplexHComplex_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HComplexHNumber_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HComplexHInteger_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HNumberHComplex_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HIntegerHComplex_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hiSub;
void (*fptr_hiSub_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hiSub;
void (*fptr_hiSub_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hiSub;

template < class T , class S > inline void hiSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiSub ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hiSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiSub ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hiSub_hSLICED_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiSub_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hiSub2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it -= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiSub( std::vector<T> & vec1 , S val) {
hiSub2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hiSub( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hiSub2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiSub( casa::Vector<T> & vec1 , S val) {
hiSub2 ( vec1.cbegin(),vec1.cend() , val);
}


void (*fptr_hiSub2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HComplexHComplex_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HComplexHNumber_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HComplexHInteger_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hiSub;
void (*fptr_hiSub2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HNumberHComplex_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HNumberHNumber_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HNumberHInteger_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hiSub;
void (*fptr_hiSub2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HIntegerHComplex_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hiSub;
void (*fptr_hiSub2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HIntegerHNumber_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hiSub;
void (*fptr_hiSub2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hiSub;
void (*fptr_hiSub2_hARRAY_HIntegerHInteger_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hiSub;

template < class T , class S > inline void hiSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiSub2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hiSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiSub2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hiSub_hSLICED2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiSub_hSLICED;
void (*fptr_hiSub_hSLICED2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiSub_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hSub(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) - (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSub( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hSub( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hSub( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hSub ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hSub_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;

template < class T , class S , class U > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSub ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSub ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSub_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hSubAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) - (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSubAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hSubAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hSubAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hSubAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T > inline void hSubAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hSubAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hSubAdd_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HComplex_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HNumber_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HInteger_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAdd;

template < class T > inline void hSubAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hSubAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSubAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;
void (*fptr_hSubAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;
void (*fptr_hSubAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hSubAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) - (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSubAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hSubAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hSubAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hSubAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hSubAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hSubAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hSubAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;

template < class T , class S , class U > inline void hSubAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hSubAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hSub2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) - val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSub( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hSub2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hSub( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hSub2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hSub( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hSub2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}


void (*fptr_hSub2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;

template < class T , class S , class U > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hiMul(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 *= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiMul( std::vector<T> & vec1 , std::vector<S> & vec2) {
hiMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hiMul( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hiMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiMul( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hiMul ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hiMul_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HComplexHComplex_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HComplexHNumber_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HComplexHInteger_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HNumberHComplex_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HIntegerHComplex_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hiMul;
void (*fptr_hiMul_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hiMul;
void (*fptr_hiMul_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hiMul;

template < class T , class S > inline void hiMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiMul ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hiMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiMul ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hiMul_hSLICED_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiMul_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hiMul2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it *= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiMul( std::vector<T> & vec1 , S val) {
hiMul2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hiMul( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hiMul2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiMul( casa::Vector<T> & vec1 , S val) {
hiMul2 ( vec1.cbegin(),vec1.cend() , val);
}


void (*fptr_hiMul2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HComplexHComplex_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HComplexHNumber_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HComplexHInteger_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hiMul;
void (*fptr_hiMul2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HNumberHComplex_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HNumberHNumber_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HNumberHInteger_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hiMul;
void (*fptr_hiMul2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HIntegerHComplex_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hiMul;
void (*fptr_hiMul2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HIntegerHNumber_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hiMul;
void (*fptr_hiMul2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hiMul;
void (*fptr_hiMul2_hARRAY_HIntegerHInteger_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hiMul;

template < class T , class S > inline void hiMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiMul2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hiMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiMul2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hiMul_hSLICED2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiMul_hSLICED;
void (*fptr_hiMul_hSLICED2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiMul_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hMul(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) * (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMul( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hMul( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hMul( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hMul ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hMul_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;

template < class T , class S , class U > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMul ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMul ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMul_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hMulAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) * (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hMulAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hMulAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hMulAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hMulAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T > inline void hMulAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hMulAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hMulAdd_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HComplex_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HNumber_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HInteger_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAdd;

template < class T > inline void hMulAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hMulAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMulAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;
void (*fptr_hMulAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;
void (*fptr_hMulAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hMulAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) * (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMulAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hMulAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hMulAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hMulAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hMulAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hMulAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hMulAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;

template < class T , class S , class U > inline void hMulAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hMulAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hMul2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) * val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMul( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hMul2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hMul( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hMul2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hMul( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hMul2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}


void (*fptr_hMul2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;

template < class T , class S , class U > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hiAdd(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 += hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiAdd( std::vector<T> & vec1 , std::vector<S> & vec2) {
hiAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hiAdd( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hiAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiAdd( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hiAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hiAdd_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HComplexHComplex_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HComplexHNumber_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HComplexHInteger_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HNumberHComplex_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HIntegerHComplex_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hiAdd;
void (*fptr_hiAdd_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hiAdd;
void (*fptr_hiAdd_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hiAdd;

template < class T , class S > inline void hiAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hiAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hiAdd_hSLICED_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hiAdd2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it += val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiAdd( std::vector<T> & vec1 , S val) {
hiAdd2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hiAdd( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hiAdd2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiAdd( casa::Vector<T> & vec1 , S val) {
hiAdd2 ( vec1.cbegin(),vec1.cend() , val);
}


void (*fptr_hiAdd2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HComplexHComplex_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HComplexHNumber_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HComplexHInteger_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hiAdd;
void (*fptr_hiAdd2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HNumberHComplex_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HNumberHNumber_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HNumberHInteger_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hiAdd;
void (*fptr_hiAdd2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HIntegerHComplex_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hiAdd;
void (*fptr_hiAdd2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HIntegerHNumber_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hiAdd;
void (*fptr_hiAdd2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hiAdd;
void (*fptr_hiAdd2_hARRAY_HIntegerHInteger_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hiAdd;

template < class T , class S > inline void hiAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiAdd2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hiAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiAdd2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hiAdd_hSLICED2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiAdd_hSLICED;
void (*fptr_hiAdd_hSLICED2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hAdd(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) + (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAdd( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hAdd( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hAdd( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hAdd_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;

template < class T , class S , class U > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hAddAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) + (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAddAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hAddAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hAddAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hAddAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T > inline void hAddAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hAddAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hAddAdd_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HComplex_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HNumber_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HInteger_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAdd;

template < class T > inline void hAddAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hAddAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAddAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;
void (*fptr_hAddAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;
void (*fptr_hAddAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hAddAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) + (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAddAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hAddAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hAddAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hAddAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hAddAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hAddAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hAddAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;

template < class T , class S , class U > inline void hAddAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hAddAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hAdd2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) + val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAdd( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hAdd2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hAdd( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hAdd2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hAdd( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hAdd2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}


void (*fptr_hAdd2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;

template < class T , class S , class U > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hiDiv(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 /= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiDiv( std::vector<T> & vec1 , std::vector<S> & vec2) {
hiDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hiDiv( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hiDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiDiv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hiDiv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hiDiv_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HComplexHComplex_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HComplexHNumber_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HComplexHInteger_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HNumberHComplex_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HNumberHNumber_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HNumberHInteger_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HIntegerHComplex_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HIntegerHNumber_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hiDiv;
void (*fptr_hiDiv_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hiDiv;
void (*fptr_hiDiv_hARRAY_HIntegerHInteger_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hiDiv;

template < class T , class S > inline void hiDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiDiv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hiDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hiDiv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hiDiv_hSLICED_STL_HComplexHComplex_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HComplexHNumber_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HComplexHInteger_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HNumberHComplex_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HNumberHNumber_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HNumberHInteger_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hiDiv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hiDiv2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it /= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hiDiv( std::vector<T> & vec1 , S val) {
hiDiv2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hiDiv( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hiDiv2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.iterate(); };
}

template < class T , class S > inline void hiDiv( casa::Vector<T> & vec1 , S val) {
hiDiv2 ( vec1.cbegin(),vec1.cend() , val);
}


void (*fptr_hiDiv2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HComplexHComplex_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HComplexHNumber_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HComplexHInteger_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hiDiv;
void (*fptr_hiDiv2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HNumberHComplex_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HNumberHNumber_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HNumberHInteger_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hiDiv;
void (*fptr_hiDiv2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HIntegerHComplex_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hiDiv;
void (*fptr_hiDiv2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HIntegerHNumber_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hiDiv;
void (*fptr_hiDiv2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hiDiv;
void (*fptr_hiDiv2_hARRAY_HIntegerHInteger_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hiDiv;

template < class T , class S > inline void hiDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiDiv2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hiDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hiDiv2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hiDiv_hSLICED2_STL_HComplexHComplex_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HComplexHNumber_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HComplexHInteger_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HNumberHComplex_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HNumberHNumber_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HNumberHInteger_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HIntegerHComplex_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HIntegerHNumber_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hiDiv_hSLICED;
void (*fptr_hiDiv_hSLICED2_STL_HIntegerHInteger_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hiDiv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hDiv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) / (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDiv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hDiv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hDiv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hDiv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hDiv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;

template < class T , class S , class U > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDiv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDiv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hDivAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) / (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hDivAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hDivAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hDivAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hDivAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T > inline void hDivAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hDivAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hDivAdd_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HComplex_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HNumber_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HInteger_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAdd;

template < class T > inline void hDivAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hDivAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDivAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;
void (*fptr_hDivAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;
void (*fptr_hDivAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hDivAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) / (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDivAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hDivAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hDivAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hDivAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hDivAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hDivAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}


void (*fptr_hDivAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;

template < class T , class S , class U > inline void hDivAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hDivAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hDiv2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) / val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDiv( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hDiv2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hDiv( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hDiv2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T , class S , class U > inline void hDiv( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hDiv2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}


void (*fptr_hDiv2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;

template < class T , class S , class U > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
////////////////////
//COMPLEX FUNCTIONS
///////////////////
//-----------------------------------------------------------------------
/*!
  \brief Calculate the complex conjugate of all elements in the complex vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hConj(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=conj(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hConj( std::vector<HComplex> & vec) {
hConj ( vec.begin(),vec.end());
}

inline void hConj( hArray<HComplex> & vec) {
bool iterate=true;
while(iterate) {
hConj ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

inline void hConj( casa::Vector<HComplex> & vec) {
hConj ( vec.cbegin(),vec.cend());
}


void (*fptr_hConj_STL_HInteger_HComplex_STDIT)( std::vector<HComplex> & vec) = &hConj;
void (*fptr_hConj_hARRAY_HInteger_HComplex_STDIT)( hArray<HComplex> & vec) = &hConj;

 inline void hConj_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) {
hConj ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

inline void hConj_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) {
hConj ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hConj_hSLICED_STL_HInteger_HComplex_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hConj_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Multiplies the elements of the first vector with the complex conjugate of the elements in the second and returns the results in the first.

    \param vec1: Complex input and output vector

    \param vec2: Second complex vector


 If the second vector is shorter than the first one, the second vector
 will simply wrap around and begin from the start until the end of the
 first vector is reached. If the first vector is shorter, then the
 calculation will simply stop.

 Relation to Cross Correlation:
 ------------------------------
 If the complex input vectors are the Fourier transformed data of two
 (real) vector f1 & f2, then vec1*conj(vec2) will be the Fourier
 transform of the crosscorrelation between f1 and f2.

 Hence, in order to calculate a cross correlation between f1 & f2, first do
 f1.fft(vec1) and f2.fft(vec2), then vec1.crosscorrelatecomplex(vec2)
 and FFT back through vec1.invfft(floatvec).
*/
template <class Iter>
void hCrossCorrelateComplex(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end)
{
  Iter it1=vec1;
  Iter it2=vec2;
  while (it1!=vec1_end) {
    *it1 *= conj(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hCrossCorrelateComplex( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) {
hCrossCorrelateComplex ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

inline void hCrossCorrelateComplex( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) {
bool iterate=true;
while(iterate) {
hCrossCorrelateComplex ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

inline void hCrossCorrelateComplex( casa::Vector<HComplex> & vec1 , casa::Vector<HComplex> & vec2) {
hCrossCorrelateComplex ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hCrossCorrelateComplex_STL_HInteger_HComplexHComplex_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hCrossCorrelateComplex;
void (*fptr_hCrossCorrelateComplex_hARRAY_HInteger_HComplexHComplex_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hCrossCorrelateComplex;

 inline void hCrossCorrelateComplex_hSLICED ( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hCrossCorrelateComplex ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

inline void hCrossCorrelateComplex_hSLICED ( casa::Vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hCrossCorrelateComplex ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hCrossCorrelateComplex_hSLICED_STL_HInteger_HComplexHComplex_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hCrossCorrelateComplex_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$ITERATE MFUNC arg,imag,norm,real
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the real of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hReal(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=real(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hReal( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hReal ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hReal( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hReal ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

inline void hReal( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hReal ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hReal_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hReal;
void (*fptr_hReal_hARRAY_HInteger_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hReal;

 inline void hReal_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hReal ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hReal_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hReal ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hReal_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hReal_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the arg of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hArg(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=arg(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hArg( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hArg ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hArg( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hArg ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

inline void hArg( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hArg ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hArg_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hArg;
void (*fptr_hArg_hARRAY_HInteger_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hArg;

 inline void hArg_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hArg ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hArg_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hArg ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hArg_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hArg_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the imag of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hImag(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=imag(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hImag( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hImag ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hImag( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hImag ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

inline void hImag( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hImag ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hImag_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hImag;
void (*fptr_hImag_hARRAY_HInteger_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hImag;

 inline void hImag_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hImag ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hImag_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hImag ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hImag_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hImag_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the norm of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hNorm(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=norm(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hNorm( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hNorm ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hNorm( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hNorm ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); };
}

inline void hNorm( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hNorm ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}


void (*fptr_hNorm_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hNorm;
void (*fptr_hNorm_hARRAY_HInteger_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hNorm;

 inline void hNorm_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hNorm ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hNorm_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hNorm ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hNorm_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hNorm_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//-----------------------------------------------------------------------
/*!
  \brief Multiplies each element in the vector with -1 in place, i.e. the input vector is also the output vector.

    \param vec: Numeric input vector

*/
template <class Iter>
void hNegate(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  typename Iter::value_type fac = -1;
  while (it!=vec_end) {
    *it=(*it) * fac;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hNegate( std::vector<T> & vec) {
hNegate ( vec.begin(),vec.end());
}

template < class T > inline void hNegate( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hNegate ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hNegate( casa::Vector<T> & vec) {
hNegate ( vec.cbegin(),vec.cend());
}


void (*fptr_hNegate_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hNegate;
void (*fptr_hNegate_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hNegate;
void (*fptr_hNegate_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hNegate;

template < class T > inline void hNegate_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNegate ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hNegate_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNegate ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hNegate_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;
void (*fptr_hNegate_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;
void (*fptr_hNegate_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a sum over the values in a vector and returns the value.

    \param vec: Numeric input vector

*/
template <class Iter>
typename Iter::value_type hSum (const Iter vec,const Iter vec_end)
{
  typedef typename Iter::value_type T;
  T sum=hfnull<T>();
  Iter it=vec;
  while (it!=vec_end) {sum+=*it; ++it;};
  return sum;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hSum( std::vector<T> & vec) {
return hSum ( vec.begin(),vec.end());
}

template < class T > inline vector<T> hSum( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hSum ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline T hSum( casa::Vector<T> & vec) {
return hSum ( vec.cbegin(),vec.cend());
}


HComplex (*fptr_hSum_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSum;
vector<HComplex > (*fptr_hSum_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSum;
HNumber (*fptr_hSum_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSum;
vector<HNumber > (*fptr_hSum_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSum;
HInteger (*fptr_hSum_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSum;
vector<HInteger > (*fptr_hSum_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSum;

template < class T > inline T hSum_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSum ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hSum_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSum ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HComplex (*fptr_hSum_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;
HNumber (*fptr_hSum_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;
HInteger (*fptr_hSum_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Multiplies all elements in the vector with each other and return the result

    \param vec: Numeric input vector

 
 hProduct(vec) -> vec[0]*vec[1]*vec[2]* ... * vec[N]

*/
template <class Iter>
typename Iter::value_type hProduct (const Iter vec,const Iter vec_end)
{
  typedef typename Iter::value_type T;
  T prod=1.0;
  Iter it=vec;
  while (it!=vec_end) {prod *= *it; ++it;};
  return prod;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hProduct( std::vector<T> & vec) {
return hProduct ( vec.begin(),vec.end());
}

template < class T > inline vector<T> hProduct( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hProduct ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline T hProduct( casa::Vector<T> & vec) {
return hProduct ( vec.cbegin(),vec.cend());
}


HComplex (*fptr_hProduct_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hProduct;
vector<HComplex > (*fptr_hProduct_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hProduct;
HNumber (*fptr_hProduct_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hProduct;
vector<HNumber > (*fptr_hProduct_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hProduct;
HInteger (*fptr_hProduct_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hProduct;
vector<HInteger > (*fptr_hProduct_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hProduct;

template < class T > inline T hProduct_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hProduct ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hProduct_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hProduct ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HComplex (*fptr_hProduct_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;
HNumber (*fptr_hProduct_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;
HInteger (*fptr_hProduct_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the lengths or norm of a vector (i.e. Sqrt(Sum_i(xi*+2))).

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hNorm (const Iter vec,const Iter vec_end)
{
  HNumber sum=0;
  Iter it=vec;
  while (it!=vec_end) {sum += (*it) * (*it); ++it;};
  return sqrt(sum);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hNorm( std::vector<T> & vec) {
return hNorm ( vec.begin(),vec.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hNorm( hArray<T> & vec) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hNorm ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HNumber hNorm( casa::Vector<T> & vec) {
return hNorm ( vec.cbegin(),vec.cend());
}


HNumber (*fptr_hNorm_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hNorm;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hNorm_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hNorm;
HNumber (*fptr_hNorm_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hNorm;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hNorm_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hNorm;

template < class T > inline HNumber hNorm_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hNorm ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hNorm_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hNorm ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hNorm_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNorm_hSLICED;
HNumber (*fptr_hNorm_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNorm_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Normalizes a vector to length unity.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hNormalize (const Iter vec,const Iter vec_end)
{
  HNumber norm=hNorm(vec,vec_end);
  Iter it=vec;
  while (it!=vec_end) {*it=(*it)/norm; ++it;};
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hNormalize( std::vector<T> & vec) {
hNormalize ( vec.begin(),vec.end());
}

template < class T > inline void hNormalize( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hNormalize ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hNormalize( casa::Vector<T> & vec) {
hNormalize ( vec.cbegin(),vec.cend());
}


void (*fptr_hNormalize_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hNormalize;
void (*fptr_hNormalize_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hNormalize;
void (*fptr_hNormalize_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hNormalize;
void (*fptr_hNormalize_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hNormalize;

template < class T > inline void hNormalize_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNormalize ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hNormalize_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNormalize ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hNormalize_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNormalize_hSLICED;
void (*fptr_hNormalize_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNormalize_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the mean value of all elements in a vector.

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hMean (const Iter vec,const Iter vec_end)
{
  HNumber mean=hSum(vec,vec_end);
  if (vec_end>vec) mean/=(vec_end-vec);
  return mean;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hMean( std::vector<T> & vec) {
return hMean ( vec.begin(),vec.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hMean( hArray<T> & vec) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hMean ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HNumber hMean( casa::Vector<T> & vec) {
return hMean ( vec.cbegin(),vec.cend());
}


HNumber (*fptr_hMean_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hMean;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hMean_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hMean;
HNumber (*fptr_hMean_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hMean;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hMean_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hMean;

template < class T > inline HNumber hMean_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hMean ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hMean_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hMean ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hMean_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hMean_hSLICED;
HNumber (*fptr_hMean_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hMean_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Sorts a vector in place.

    \param vec: Numeric input vector


  Attention!!! The vector will be sorted in place. Hence, if you want to
  keep the data in its original order, you need to copy the data first
  to a scratch vector and then call this function with the scratch vector!
*/
template <class Iter>
void hSort(const Iter vec, const Iter vec_end)
{
  sort(vec,vec_end);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSort( std::vector<T> & vec) {
hSort ( vec.begin(),vec.end());
}

template < class T > inline void hSort( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSort ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hSort( casa::Vector<T> & vec) {
hSort ( vec.cbegin(),vec.cend());
}


void (*fptr_hSort_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hSort;
void (*fptr_hSort_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSort;
void (*fptr_hSort_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSort;

template < class T > inline void hSort_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSort ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSort_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSort ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSort_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;
void (*fptr_hSort_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;
void (*fptr_hSort_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Sorts a vector in place and returns the median value of the elements.

    \param vec: Numeric input vector


  Attention!!! The vector will be sorted first. Hence, if you want to
  keep the data in its original order, you need to copy the data first
  to a scratch vector and then call this function with the scratch vector!
*/
template <class Iter>
typename Iter::value_type hSortMedian(const Iter vec, const Iter vec_end)
{
  sort(vec,vec_end);
  if (vec_end!=vec) return *(vec+(vec_end-vec)/2);
  else return hfnull<typename Iter::value_type>();
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hSortMedian( std::vector<T> & vec) {
return hSortMedian ( vec.begin(),vec.end());
}

template < class T > inline vector<T> hSortMedian( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hSortMedian ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline T hSortMedian( casa::Vector<T> & vec) {
return hSortMedian ( vec.cbegin(),vec.cend());
}


HNumber (*fptr_hSortMedian_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hSortMedian;
vector<HNumber > (*fptr_hSortMedian_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hSortMedian;
HInteger (*fptr_hSortMedian_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hSortMedian;
vector<HInteger > (*fptr_hSortMedian_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hSortMedian;

template < class T > inline T hSortMedian_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSortMedian ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hSortMedian_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSortMedian ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hSortMedian_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSortMedian_hSLICED;
HInteger (*fptr_hSortMedian_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSortMedian_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the median value of the elements.

    \param vec: Numeric input vector

*/
template <class T>
T hMedian(std::vector<T> & vec)
{
  std::vector<T> scratch(vec);
  return hSortMedian(scratch);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_hMedian_STL_HNumber_1_STL)( std::vector<HNumber> & vec) = &hMedian;
HInteger (*fptr_hMedian_STL_HInteger_1_STL)( std::vector<HInteger> & vec) = &hMedian;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the standard deviation around a mean value.

    \param vec: Numeric input vector

    \param mean: The mean value of the vector caluclated beforehand

*/
template <class Iter>
HNumber hStdDev (const Iter vec,const Iter vec_end, const typename Iter::value_type mean)
{
  typedef typename Iter::value_type T;
  HNumber scrt,sum=0.0;
  HInteger len=vec_end-vec;
  Iter it=vec;
  while (it<vec_end) {
    scrt = *it - mean;
    sum += scrt * scrt;
    ++it;
  };
  if (len>1) return sqrt(sum / (len-1));
  else return sqrt(sum);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hStdDev( std::vector<T> & vec , HNumber mean) {
return hStdDev ( vec.begin(),vec.end() , mean);
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hStdDev( hArray<T> & vec , HNumber mean) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hStdDev ( vec.begin(),vec.end() , mean);
vec.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HNumber hStdDev( casa::Vector<T> & vec , HNumber mean) {
return hStdDev ( vec.cbegin(),vec.cend() , mean);
}


HNumber (*fptr_hStdDev_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber mean) = &hStdDev;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hStdDev_hARRAY_HNumber_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber mean) = &hStdDev;
HNumber (*fptr_hStdDev_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber mean) = &hStdDev;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hStdDev_hARRAY_HInteger_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber mean) = &hStdDev;

template < class T > inline HNumber hStdDev_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) {
return hStdDev ( vec.begin() + vecslice1,vec.begin() + vecslice2 , mean);
}

template < class T > inline HNumber hStdDev_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) {
return hStdDev ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , mean);
}


HNumber (*fptr_hStdDev_hSLICED_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) = &hStdDev_hSLICED;
HNumber (*fptr_hStdDev_hSLICED_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) = &hStdDev_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the standard deviation of a vector of values.

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hStdDev (const Iter vec,const Iter vec_end)
{
  return hStdDev(vec,vec_end,hMean(vec,vec_end));
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hStdDev( std::vector<T> & vec) {
return hStdDev ( vec.begin(),vec.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hStdDev( hArray<T> & vec) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hStdDev ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HNumber hStdDev( casa::Vector<T> & vec) {
return hStdDev ( vec.cbegin(),vec.cend());
}


HNumber (*fptr_hStdDev_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hStdDev;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hStdDev_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hStdDev;
HNumber (*fptr_hStdDev_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hStdDev;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hStdDev_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hStdDev;

template < class T > inline HNumber hStdDev_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hStdDev ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hStdDev_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hStdDev ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hStdDev_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hStdDev_hSLICED;
HNumber (*fptr_hStdDev_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hStdDev_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$ITERATE MFUNC GreaterThan,GreaterEqual,LessThan,LessEqual
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessEqual (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it <= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessEqual( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindLessEqual( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindLessEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindLessEqual( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessEqual ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindLessEqual_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessEqual;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessEqual_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessEqual;
HInteger (*fptr_hFindLessEqual_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessEqual;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessEqual_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessEqual;

template < class T > inline HInteger hFindLessEqual_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqual ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessEqual_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqual ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessEqual_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqual_hSLICED;
HInteger (*fptr_hFindLessEqual_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqual_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessEqualAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) <= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessEqualAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindLessEqualAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindLessEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindLessEqualAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessEqualAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindLessEqualAbs_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessEqualAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessEqualAbs_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;
HInteger (*fptr_hFindLessEqualAbs_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessEqualAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessEqualAbs_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;

template < class T > inline HInteger hFindLessEqualAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqualAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessEqualAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqualAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessEqualAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqualAbs_hSLICED;
HInteger (*fptr_hFindLessEqualAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqualAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterThan (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it > threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterThan( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindGreaterThan( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindGreaterThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindGreaterThan( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterThan ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindGreaterThan_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterThan;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterThan_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;
HInteger (*fptr_hFindGreaterThan_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterThan;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterThan_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;

template < class T > inline HInteger hFindGreaterThan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThan ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterThan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThan ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterThan_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThan_hSLICED;
HInteger (*fptr_hFindGreaterThan_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterThanAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) > threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterThanAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindGreaterThanAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindGreaterThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindGreaterThanAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterThanAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindGreaterThanAbs_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterThanAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterThanAbs_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;
HInteger (*fptr_hFindGreaterThanAbs_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterThanAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterThanAbs_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;

template < class T > inline HInteger hFindGreaterThanAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThanAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterThanAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThanAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterThanAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThanAbs_hSLICED;
HInteger (*fptr_hFindGreaterThanAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThanAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterEqual (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it >= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterEqual( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindGreaterEqual( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindGreaterEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindGreaterEqual( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterEqual ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindGreaterEqual_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqual;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterEqual_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;
HInteger (*fptr_hFindGreaterEqual_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqual;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterEqual_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;

template < class T > inline HInteger hFindGreaterEqual_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqual ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterEqual_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqual ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterEqual_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqual_hSLICED;
HInteger (*fptr_hFindGreaterEqual_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqual_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterEqualAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) >= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterEqualAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindGreaterEqualAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindGreaterEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindGreaterEqualAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterEqualAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindGreaterEqualAbs_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqualAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterEqualAbs_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;
HInteger (*fptr_hFindGreaterEqualAbs_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqualAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindGreaterEqualAbs_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;

template < class T > inline HInteger hFindGreaterEqualAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqualAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterEqualAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqualAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterEqualAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqualAbs_hSLICED;
HInteger (*fptr_hFindGreaterEqualAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqualAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessThan (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it < threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessThan( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindLessThan( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindLessThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindLessThan( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessThan ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindLessThan_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessThan;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessThan_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessThan;
HInteger (*fptr_hFindLessThan_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessThan;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessThan_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessThan;

template < class T > inline HInteger hFindLessThan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThan ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessThan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThan ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessThan_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThan_hSLICED;
HInteger (*fptr_hFindLessThan_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThan_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessThanAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) < threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessThanAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindLessThanAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindLessThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindLessThanAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessThanAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}


HInteger (*fptr_hFindLessThanAbs_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessThanAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessThanAbs_hARRAY_HNumber_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;
HInteger (*fptr_hFindLessThanAbs_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessThanAbs;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLessThanAbs_hARRAY_HInteger_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;

template < class T > inline HInteger hFindLessThanAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThanAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessThanAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThanAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessThanAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThanAbs_hSLICED;
HInteger (*fptr_hFindLessThanAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThanAbs_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//-----------------------------------------------------------------------
/*!
  \brief Downsample the input vector to a smaller output vector.

    \param vec1: Numeric input vector

    \param vec2: Numeric output vector


 Downsample the input vector to a smaller output vector, by replacing
     subsequent blocks of values by their mean value. The block size
     is automatically chosen such that the input vector fits exactly
     into the output vector. All blocks have the same length with a
     possible exception of the last block.
*/
template <class Iter>
void hDownsample (const Iter vec1,
    const Iter vec1_end,
    const Iter vec2,
    const Iter vec2_end)
{
  if (vec2>=vec2_end) return; //If size 0 do nothing
  if (vec1>=vec1_end) return; //If size 0 do nothing
  HInteger ilen=(vec1_end-vec1);
  HInteger olen=(vec2_end-vec2);
  HInteger blen=max(ilen/(olen-1),1);
  //use max to avoid infinite loops if output vector is too large
  Iter it2,it1=vec1;
  Iter ito=vec2,ito_end=vec2_end-1;
  //only produce the first N-1 blocks in the output vector
  while ((it1<vec1_end) && (ito<ito_end)) {
    it2=min(it1+blen,vec1_end);
    *ito=hMean(it1,it2);
    it1=it2;
    ++ito;
    }
  *ito=hMean(it2,vec1_end);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hDownsample( std::vector<T> & vec1 , std::vector<T> & vec2) {
hDownsample ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T > inline void hDownsample( hArray<T> & vec1 , hArray<T> & vec2) {
bool iterate=true;
while(iterate) {
hDownsample ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.iterate(); };
}

template < class T > inline void hDownsample( casa::Vector<T> & vec1 , casa::Vector<T> & vec2) {
hDownsample ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}


void (*fptr_hDownsample_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hDownsample;
void (*fptr_hDownsample_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hDownsample;
void (*fptr_hDownsample_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hDownsample;
void (*fptr_hDownsample_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hDownsample;

template < class T > inline void hDownsample_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDownsample ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T > inline void hDownsample_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDownsample ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hDownsample_hSLICED_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDownsample_hSLICED;
void (*fptr_hDownsample_hSLICED_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDownsample_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Downsample the input vector by a cetain factor and return a new vector.

    \param vec: Numeric input vector

    \param downsample_factor: Factor by which to reduce original size


 Downsample the input vector to a new smaller output vector, by replacing
     subsequent blocks of values by their mean value. The block size
     is automatically chosen such that the input vector fits exactly
     into the output vector. All blocks have the same length with a
     possible exception of the last block.
*/
template <class T>
std::vector<T> hDownsample (
    std::vector<T> & vec,
    HNumber downsample_factor
    )
{
  std::vector<T> newvec(floor(vec.size()/downsample_factor+0.5));
  hDownsample(vec,newvec);
  return newvec;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hDownsample_STL_HNumber_1HNumber_STL)( std::vector<HNumber> & vec , HNumber downsample_factor) = &hDownsample;
std::vector<HInteger> (*fptr_hDownsample_STL_HInteger_1HNumber_STL)( std::vector<HInteger> & vec , HNumber downsample_factor) = &hDownsample;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!

  \brief Finds the location (i.e., returns integer) in a monotonically increasing vector, where the input search value is just above or equal to the value in the vector.

    \param vec: Sorted numeric input vector

    \param value: value to search for


Finds -- through a binary search and interpolation -- the location in
  a monotonically increasing vector, where the search value is just
  above or equal to the value in the vector.

This requires random access iterators, in order to have an optimal search result.

*/
template <class Iter>
HInteger hFindLowerBound (const Iter vec,
    const Iter vec_end,
    const typename Iter::value_type value)
//iterator_traits<Iter>::value_type value)
{
  HNumber value_n=hfcast<HNumber>(value); //This also works for Complex then
  HInteger niter=0;
  if (vec==vec_end) return 0;
  HInteger maxpos=vec_end-vec-1,posguess;
  Iter it1=vec,it2=vec_end-1,it0;
  if (value_n<=hfcast<HNumber>(*it1)) return 0;
  if (value_n>=hfcast<HNumber>(*it2)) return maxpos;
  posguess=(value_n-hfcast<HNumber>(*it1))/(hfcast<HNumber>(*it2)-hfcast<HNumber>(*it1))*maxpos;
  it0=vec+posguess;
  if (it0<it1) return hfcast<HInteger>(it1-vec); //Error, Non monotonic
  if (it0>=it2) return hfcast<HInteger>(it2-vec); //Error, Non monotonic
  //  cout << "hFindLowerBound(" << value_n << "): niter=" << niter << ", posguess=" << posguess << ", val=" << *it0 << " vals=(" << hfcast<HNumber>(*(it0)) << ", " << hfcast<HNumber>(*(it0+1)) << "), bracket=(" << it1-vec << ", " << it2-vec <<")" <<endl;
  while (!((value_n < hfcast<HNumber>(*(it0+1))) && (value_n >= hfcast<HNumber>(*it0)))) {
    if (value_n > hfcast<HNumber>(*it0)) {
      it1=it0;
    } else {
      it2=it0;
    };
    it0=it1+(it2-it1)/2;
    if (*it0>value_n) it2=it0; //Binary search step
    else it1=it0;
    posguess=(value_n-hfcast<HNumber>(*it1))/(hfcast<HNumber>(*it2)-hfcast<HNumber>(*it1))*(it2-it1)+(it1-vec);
    it0=vec+posguess;
    ++niter;
    //cout << "hFindLowerBound(" << value_n << "): niter=" << niter << ", posguess=" << posguess << ", val=" << *it0 << " vals=(" << hfcast<HNumber>(*(it0)) << ", " << hfcast<HNumber>(*(it0+1)) << "), bracket=(" << it1-vec << ", " << it2-vec <<")" <<endl;
    if (it0<it1) return it1-vec; //Error, Non monotonic
    if (it0>it2) return it2-vec; //Error, Non monotonic
  };
  return posguess;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLowerBound( std::vector<T> & vec , T value) {
return hFindLowerBound ( vec.begin(),vec.end() , value);
}

template < class T > inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger>) hFindLowerBound( hArray<T> & vec , T value) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HInteger> returnvector;
HInteger returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hFindLowerBound ( vec.begin(),vec.end() , value);
vec.next();
iterate = vec.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

template < class T > inline HInteger hFindLowerBound( casa::Vector<T> & vec , T value) {
return hFindLowerBound ( vec.cbegin(),vec.cend() , value);
}


HInteger (*fptr_hFindLowerBound_STL_HComplex_11_STDIT)( std::vector<HComplex> & vec , HComplex value) = &hFindLowerBound;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLowerBound_hARRAY_HComplex_11_STDIT)( hArray<HComplex> & vec , HComplex value) = &hFindLowerBound;
HInteger (*fptr_hFindLowerBound_STL_HNumber_11_STDIT)( std::vector<HNumber> & vec , HNumber value) = &hFindLowerBound;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLowerBound_hARRAY_HNumber_11_STDIT)( hArray<HNumber> & vec , HNumber value) = &hFindLowerBound;
HInteger (*fptr_hFindLowerBound_STL_HInteger_11_STDIT)( std::vector<HInteger> & vec , HInteger value) = &hFindLowerBound;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HInteger, vector<HInteger >) (*fptr_hFindLowerBound_hARRAY_HInteger_11_STDIT)( hArray<HInteger> & vec , HInteger value) = &hFindLowerBound;

template < class T > inline HInteger hFindLowerBound_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T value ) {
return hFindLowerBound ( vec.begin() + vecslice1,vec.begin() + vecslice2 , value);
}

template < class T > inline HInteger hFindLowerBound_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T value ) {
return hFindLowerBound ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , value);
}


HInteger (*fptr_hFindLowerBound_hSLICED_STL_HComplex_11_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HComplex value ) = &hFindLowerBound_hSLICED;
HInteger (*fptr_hFindLowerBound_hSLICED_STL_HNumber_11_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber value ) = &hFindLowerBound_hSLICED;
HInteger (*fptr_hFindLowerBound_hSLICED_STL_HInteger_11_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger value ) = &hFindLowerBound_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*
//Wrapper for c-style arrays
HInteger hFindLowerBound(const HNumber* vec,
			 const HInteger len,
			 const HNumber value)
{
  return hFindLowerBound(vec,vec+len,value);
}
*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length len with constant weights normalized to give a sum of unity. Can be used by hRunningAverageT.

    \param wlen: Lengths of weights vector

*/
 //template <class T>
std::vector<HNumber> hFlatWeights (HInteger wlen) {
  std::vector<HNumber> weights(wlen,1.0/wlen);
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hFlatWeights_STL_HInteger_HInteger_)( HInteger wlen) = &hFlatWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length wlen with linearly rising and decreasing weights centered at len/2.

    \param wlen: Lengths of weights vector


The vector is normalized to give a sum of unity. Can be used by
hRunningAverage.
*/
 //template <class T>
std::vector<HNumber> hLinearWeights (HInteger wlen) {
  std::vector<HNumber> weights(wlen,0.0);
  HInteger i,middle=wlen/2;
  HNumber f,sum=0.0;
  for (i=0; i<wlen; i++) {
    f=1.0-abs(middle-i)/(middle+1.0);
    weights[i]=f;
    sum+=f;
  };
  //Normalize to unity
  for (i=0; i<wlen; i++) weights[i]=weights[i]/sum;
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hLinearWeights_STL_HInteger_HInteger_)( HInteger wlen) = &hLinearWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length wlen with Gaussian distribution centered at len/2 and sigma=len/4 (i.e. the Gaussian extends over 2 sigma in both directions).

    \param wlen: Lengths of weights vector

*/
 //template <class T>
std::vector<HNumber> hGaussianWeights (HInteger wlen) {
  vector<HNumber> weights(wlen,0.0);
  HInteger i,middle=wlen/2;
  HNumber f,sum=0.0;
  for (i=0; i<wlen; i++) {
    f=funcGaussian(i,max(wlen/4.0,1.0),middle);
    weights[i]=f;
    sum+=f;
  };
  //Normalize to unity
  for (i=0; i<wlen; i++) weights[i]=weights[i]/sum;
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hGaussianWeights_STL_HInteger_HInteger_)( HInteger wlen) = &hGaussianWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a normalized weight vector.

    \param wlen: Length of weight vector

    \param wtype: Type of weight vector

*/
vector<HNumber> hWeights(HInteger wlen, hWEIGHTS wtype){
  vector<HNumber> weights;
  if (wlen<1) wlen=1;
  switch (wtype) {
  case WEIGHTS_LINEAR:
    weights=hLinearWeights(wlen);
    break;
  case WEIGHTS_GAUSSIAN:
    weights=hGaussianWeights(wlen);
    break;
  default: //  WEIGHTS_FLAT:
    weights=hFlatWeights(wlen);
  };
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hWeights_STL_HInteger_HIntegerhWEIGHTS_)( HInteger wlen , hWEIGHTS wtype) = &hWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Calculate the running average of an input vector using a weight vector.

    \param idata: Input vector

    \param odata: Output vector

    \param weights: Weight vector

*/
template <class DataIter, class NumVecIter>
void hRunningAverage (const DataIter idata,
       const DataIter idata_end,
       const DataIter odata,
       const DataIter odata_end,
       const NumVecIter weights,
       const NumVecIter weights_end)
{
  HInteger l=(weights_end-weights);
  /* Index of the central element of the weights vector (i.e., where it
     typically would peak) */
  HInteger middle=l/2;
  /* To avoid too many rounding errors with Integers */
  //  typename DataIter::value_type fac = l*10;
  HNumber temp;
  DataIter dit;
  DataIter dit2;
  DataIter din(idata);
  DataIter dout(odata);
  NumVecIter wit;
  while (din<idata_end && dout<odata_end) {
    dit=din-middle; //data iterator set to the first element to be taken into account (left from current element)
    wit=weights; // weight iterators set to beginning of weights
    temp=0.0;
    while (wit<weights_end) {
      if (dit<idata) dit2=idata;
      else if (dit>=idata_end) dit2=idata_end-1;
      else dit2=dit;
      temp=temp+(*dit2)*(*wit);
      ++dit; ++wit;
    };
    *dout=temp;
    ++dout; ++din; //point to the next element in data input and output vector
  };
  return;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hRunningAverage( std::vector<HNumber> & idata , std::vector<HNumber> & odata , std::vector<HNumber> & weights) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , weights.begin(),weights.end());
}

inline void hRunningAverage( hArray<HNumber> & idata , hArray<HNumber> & odata , hArray<HNumber> & weights) {
bool iterate=true;
while(iterate) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , weights.begin(),weights.end());
idata.next();
odata.next();
weights.next();
iterate = idata.iterate(); };
}

inline void hRunningAverage( casa::Vector<HNumber> & idata , casa::Vector<HNumber> & odata , casa::Vector<HNumber> & weights) {
hRunningAverage ( idata.cbegin(),idata.cend() , odata.cbegin(),odata.cend() , weights.cbegin(),weights.cend());
}


void (*fptr_hRunningAverage_STL_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT)( std::vector<HNumber> & idata , std::vector<HNumber> & odata , std::vector<HNumber> & weights) = &hRunningAverage;
void (*fptr_hRunningAverage_hARRAY_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT)( hArray<HNumber> & idata , hArray<HNumber> & odata , hArray<HNumber> & weights) = &hRunningAverage;

 inline void hRunningAverage_hSLICED ( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , std::vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) {
hRunningAverage ( idata.begin() + idataslice1,idata.begin() + idataslice2 , odata.begin() + odataslice1,odata.begin() + odataslice2 , weights.begin() + weightsslice1,weights.begin() + weightsslice2);
}

inline void hRunningAverage_hSLICED ( casa::Vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , casa::Vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , casa::Vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) {
hRunningAverage ( idata.cbegin() + idataslice1,idata.cbegin() + idataslice2 , odata.cbegin() + odataslice1,odata.cbegin() + odataslice2 , weights.cbegin() + weightsslice1,weights.cbegin() + weightsslice2);
}


void (*fptr_hRunningAverage_hSLICED_STL_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT)( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , std::vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) = &hRunningAverage_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Overloaded function to automatically calculate weights.

    \param idata: Input vector

    \param odata: Output vector

    \param wlen: Length of weight vector

    \param wtype: Type of weight vector

*/
template <class DataIter>
void hRunningAverage (const DataIter idata,
       const DataIter idata_end,
       const DataIter odata,
       const DataIter odata_end,
       HInteger wlen,
       hWEIGHTS wtype)
{
  vector<HNumber> weights = hWeights(wlen, wtype);
  hRunningAverage<DataIter, vector<HNumber>::iterator> (idata,
       idata_end,
       odata,
       odata_end,
       weights.begin(),
       weights.end());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hRunningAverage( std::vector<HNumber> & idata , std::vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , wlen , wtype);
}

inline void hRunningAverage( hArray<HNumber> & idata , hArray<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
bool iterate=true;
while(iterate) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , wlen , wtype);
idata.next();
odata.next();
iterate = idata.iterate(); };
}

inline void hRunningAverage( casa::Vector<HNumber> & idata , casa::Vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
hRunningAverage ( idata.cbegin(),idata.cend() , odata.cbegin(),odata.cend() , wlen , wtype);
}


void (*fptr_hRunningAverage_STL_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( std::vector<HNumber> & idata , std::vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) = &hRunningAverage;
void (*fptr_hRunningAverage_hARRAY_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( hArray<HNumber> & idata , hArray<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) = &hRunningAverage;

 inline void hRunningAverage_hSLICED ( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) {
hRunningAverage ( idata.begin() + idataslice1,idata.begin() + idataslice2 , odata.begin() + odataslice1,odata.begin() + odataslice2 , wlen , wtype);
}

inline void hRunningAverage_hSLICED ( casa::Vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , casa::Vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) {
hRunningAverage ( idata.cbegin() + idataslice1,idata.cbegin() + idataslice2 , odata.cbegin() + odataslice1,odata.cbegin() + odataslice2 , wlen , wtype);
}


void (*fptr_hRunningAverage_hSLICED_STL_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) = &hRunningAverage_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:           RF (Radio Frequency) Function
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located in a certain direction in farfield (based on L. Bahren).

    \param antPosition: Cartesian antenna positions 

    \param skyDirection: Vector in Cartesian coordinates pointing towards a sky position from the antenna - vector of length 3

    \param length: Length of the skyDirection vector, used for normalization - provided to speed up calculation

*/
template <class Iter>
HNumber hGeometricDelayFarField (
   const Iter antPosition,
   const Iter skyDirection,
   HNumber length
   )
{
  return - (*skyDirection * *antPosition
     + *(skyDirection+1) * *(antPosition+1)
     + *(skyDirection+2) * *(antPosition+2))/length/CR::lightspeed;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline HNumber hGeometricDelayFarField( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyDirection , HNumber length) {
return hGeometricDelayFarField ( antPosition.begin() , skyDirection.begin() , length);
}

inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hGeometricDelayFarField( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , HNumber length) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hGeometricDelayFarField ( antPosition.begin() , skyDirection.begin() , length);
antPosition.next();
skyDirection.next();
iterate = antPosition.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

inline HNumber hGeometricDelayFarField( casa::Vector<HNumber> & antPosition , casa::Vector<HNumber> & skyDirection , HNumber length) {
return hGeometricDelayFarField ( antPosition.cbegin() , skyDirection.cbegin() , length);
}


HNumber (*fptr_hGeometricDelayFarField_STL_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyDirection , HNumber length) = &hGeometricDelayFarField;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hGeometricDelayFarField_hARRAY_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , HNumber length) = &hGeometricDelayFarField;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located at a certain 3D space coordinate in nearfield (based on L. Bahren).

    \param antPosition: Cartesian antenna positions 

    \param skyPosition: Vector in Cartesian coordinates 

    \param distance: Distance of source, i.e. the length of skyPosition - provided to speed up calculation

*/
template <class Iter>
HNumber hGeometricDelayNearField (
   const Iter antPosition,
   const Iter skyPosition,
   const HNumber distance)
{
  return (
   sqrt(
        square(*skyPosition - *antPosition)
        +square(*(skyPosition+1) - *(antPosition+1))
        +square(*(skyPosition+2) - *(antPosition+2))
        ) - distance
   )/CR::lightspeed;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline HNumber hGeometricDelayNearField( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyPosition , HNumber distance) {
return hGeometricDelayNearField ( antPosition.begin() , skyPosition.begin() , distance);
}

inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber>) hGeometricDelayNearField( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , HNumber distance) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<HNumber> returnvector;
HNumber returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hGeometricDelayNearField ( antPosition.begin() , skyPosition.begin() , distance);
antPosition.next();
skyPosition.next();
iterate = antPosition.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

inline HNumber hGeometricDelayNearField( casa::Vector<HNumber> & antPosition , casa::Vector<HNumber> & skyPosition , HNumber distance) {
return hGeometricDelayNearField ( antPosition.cbegin() , skyPosition.cbegin() , distance);
}


HNumber (*fptr_hGeometricDelayNearField_STL_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyPosition , HNumber distance) = &hGeometricDelayNearField;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(HNumber, vector<HNumber >) (*fptr_hGeometricDelayNearField_hARRAY_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , HNumber distance) = &hGeometricDelayNearField;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field.

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param delays: Output vector containing the delays in seconds for all antennas and positions [antenna index runs fastest: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter>
void hGeometricDelays (
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const Iter delays,
   const Iter delays_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    sky=skyPositions,
    del=delays,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  if (farfield) {
    while (sky < sky_end && del < delays_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && del < delays_end) {
 *del=hGeometricDelayFarField(ant,sky,distance);
 ant+=3; ++del;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && del < delays_end) {
      distance = hNorm(sky,sky+3); //distance from phase center
      ant=antPositions;
      while (ant < ant_end && del < delays_end) {
 *del=hGeometricDelayNearField(ant,sky,distance);
 ant+=3; ++del;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricDelays( std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & delays , bool farfield) {
hGeometricDelays ( antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , delays.begin(),delays.end() , farfield);
}

inline void hGeometricDelays( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricDelays ( antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , delays.begin(),delays.end() , farfield);
antPositions.next();
skyPositions.next();
delays.next();
iterate = antPositions.iterate(); };
}

inline void hGeometricDelays( casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HNumber> & delays , bool farfield) {
hGeometricDelays ( antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , delays.cbegin(),delays.cend() , farfield);
}


void (*fptr_hGeometricDelays_STL_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & delays , bool farfield) = &hGeometricDelays;
void (*fptr_hGeometricDelays_hARRAY_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , bool farfield) = &hGeometricDelays;

 inline void hGeometricDelays_hSLICED ( std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) {
hGeometricDelays ( antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , delays.begin() + delaysslice1,delays.begin() + delaysslice2 , farfield);
}

inline void hGeometricDelays_hSLICED ( casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) {
hGeometricDelays ( antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , delays.cbegin() + delaysslice1,delays.cbegin() + delaysslice2 , farfield);
}


void (*fptr_hGeometricDelays_hSLICED_STL_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) = &hGeometricDelays_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the phase gradients for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.

    \param frequencies: Vector of frequencies 

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param phases: Output vector containing the phases in radians for all frequencies, antennas and positions [frequency index, runs fastest, then antenna index: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter>
void hGeometricPhases (
   const Iter frequencies,
   const Iter frequencies_end,
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const Iter phases,
   const Iter phases_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    freq,
    sky=skyPositions,
    phase=phases,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  if (farfield) {
    while (sky < sky_end && phase < phases_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && phase < phases_end) {
 freq=frequencies;
 while (freq < frequencies_end && phase < phases_end) {
   *phase=hPhase(*freq,hGeometricDelayFarField(ant,sky,distance));
   ++phase; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && phase < phases_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && phase < phases_end) {
 freq=frequencies;
 while (freq < frequencies_end && phase < phases_end) {
   *phase=hPhase(*freq,hGeometricDelayNearField(ant,sky,distance));
   ++phase; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricPhases( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & phases , bool farfield) {
hGeometricPhases ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , phases.begin(),phases.end() , farfield);
}

inline void hGeometricPhases( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricPhases ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , phases.begin(),phases.end() , farfield);
frequencies.next();
antPositions.next();
skyPositions.next();
phases.next();
iterate = frequencies.iterate(); };
}

inline void hGeometricPhases( casa::Vector<HNumber> & frequencies , casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HNumber> & phases , bool farfield) {
hGeometricPhases ( frequencies.cbegin(),frequencies.cend() , antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , phases.cbegin(),phases.cend() , farfield);
}


void (*fptr_hGeometricPhases_STL_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & phases , bool farfield) = &hGeometricPhases;
void (*fptr_hGeometricPhases_hARRAY_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , bool farfield) = &hGeometricPhases;

 inline void hGeometricPhases_hSLICED ( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) {
hGeometricPhases ( frequencies.begin() + frequenciesslice1,frequencies.begin() + frequenciesslice2 , antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , phases.begin() + phasesslice1,phases.begin() + phasesslice2 , farfield);
}

inline void hGeometricPhases_hSLICED ( casa::Vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) {
hGeometricPhases ( frequencies.cbegin() + frequenciesslice1,frequencies.cbegin() + frequenciesslice2 , antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , phases.cbegin() + phasesslice1,phases.cbegin() + phasesslice2 , farfield);
}


void (*fptr_hGeometricPhases_hSLICED_STL_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) = &hGeometricPhases_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the phase gradients as complex weights for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.

    \param frequencies: Vector of frequencies 

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param weights: Output vector containing the phases in radians for all frequencies, antennas and positions [frequency index, runs fastest, then antenna index: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter, class CIter>
void hGeometricWeights (
   const Iter frequencies,
   const Iter frequencies_end,
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const CIter weights,
   const CIter weights_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    freq,
    sky=skyPositions,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  CIter weight=weights;
  if (farfield) {
    while (sky < sky_end && weight < weights_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && weight < weights_end) {
 freq=frequencies;
 while (freq < frequencies_end && weight < weights_end) {
   *weight=exp(HComplex(0.0,hPhase(*freq,hGeometricDelayFarField(ant,sky,distance))));
   ++weight; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && weight < weights_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && weight < weights_end) {
 freq=frequencies;
 while (freq < frequencies_end && weight < weights_end) {
   *weight=exp(HComplex(0.0,hPhase(*freq,hGeometricDelayNearField(ant,sky,distance))));
   ++weight; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricWeights( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HComplex> & weights , bool farfield) {
hGeometricWeights ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , weights.begin(),weights.end() , farfield);
}

inline void hGeometricWeights( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricWeights ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , weights.begin(),weights.end() , farfield);
frequencies.next();
antPositions.next();
skyPositions.next();
weights.next();
iterate = frequencies.iterate(); };
}

inline void hGeometricWeights( casa::Vector<HNumber> & frequencies , casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HComplex> & weights , bool farfield) {
hGeometricWeights ( frequencies.cbegin(),frequencies.cend() , antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , weights.cbegin(),weights.cend() , farfield);
}


void (*fptr_hGeometricWeights_STL_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HComplex> & weights , bool farfield) = &hGeometricWeights;
void (*fptr_hGeometricWeights_hARRAY_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , bool farfield) = &hGeometricWeights;

 inline void hGeometricWeights_hSLICED ( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) {
hGeometricWeights ( frequencies.begin() + frequenciesslice1,frequencies.begin() + frequenciesslice2 , antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , weights.begin() + weightsslice1,weights.begin() + weightsslice2 , farfield);
}

inline void hGeometricWeights_hSLICED ( casa::Vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) {
hGeometricWeights ( frequencies.cbegin() + frequenciesslice1,frequencies.cbegin() + frequenciesslice2 , antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , weights.cbegin() + weightsslice1,weights.cbegin() + weightsslice2 , farfield);
}


void (*fptr_hGeometricWeights_hSLICED_STL_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) = &hGeometricWeights_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!

  \brief Calculates the power of a complex spectrum and add it to an output vector.

    \param vec: Numeric input vector

    \param outvec: Vector containing a copy of the input values converted to a new type


  The fact that the result is added to the output vector allows one to
  call the function multiple times and get a summed spectrum. If you
  need it only once, just fill the vector with zeros.
*/
template <class Iterin, class Iter>
void hSpectralPower(const Iterin vec,const Iterin vec_end, const Iter out,const Iter out_end)
{
  Iterin it(vec);
  Iter itout(out);
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout+=real((*it)*conj(*it));
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hSpectralPower( std::vector<HComplex> & vec , std::vector<HNumber> & outvec) {
hSpectralPower ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
}

inline void hSpectralPower( hArray<HComplex> & vec , hArray<HNumber> & outvec) {
bool iterate=true;
while(iterate) {
hSpectralPower ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
vec.next();
outvec.next();
iterate = vec.iterate(); };
}

inline void hSpectralPower( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & outvec) {
hSpectralPower ( vec.cbegin(),vec.cend() , outvec.cbegin(),outvec.cend());
}


void (*fptr_hSpectralPower_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & outvec) = &hSpectralPower;
void (*fptr_hSpectralPower_hARRAY_HInteger_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & outvec) = &hSpectralPower;

 inline void hSpectralPower_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hSpectralPower ( vec.begin() + vecslice1,vec.begin() + vecslice2 , outvec.begin() + outvecslice1,outvec.begin() + outvecslice2);
}

inline void hSpectralPower_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hSpectralPower ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , outvec.cbegin() + outvecslice1,outvec.cbegin() + outvecslice2);
}


void (*fptr_hSpectralPower_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hSpectralPower_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Convert the ADC value to a voltage.

    \param vec: Numeric input and output vector

    \param adc2voltage: Scaling factor if the gain

*/
template <class Iter>
void hADC2Voltage(const Iter vec, const Iter vec_end, const HNumber adc2voltage) {
  Iter it = vec;
  while(it != vec_end) {
    *it *= adc2voltage;
    it++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hADC2Voltage( std::vector<T> & vec , HNumber adc2voltage) {
hADC2Voltage ( vec.begin(),vec.end() , adc2voltage);
}

template < class T > inline void hADC2Voltage( hArray<T> & vec , HNumber adc2voltage) {
bool iterate=true;
while(iterate) {
hADC2Voltage ( vec.begin(),vec.end() , adc2voltage);
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hADC2Voltage( casa::Vector<T> & vec , HNumber adc2voltage) {
hADC2Voltage ( vec.cbegin(),vec.cend() , adc2voltage);
}


void (*fptr_hADC2Voltage_STL_HComplex_1HNumber_STDIT)( std::vector<HComplex> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HComplex_1HNumber_STDIT)( hArray<HComplex> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HNumber_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HInteger_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber adc2voltage) = &hADC2Voltage;

template < class T > inline void hADC2Voltage_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) {
hADC2Voltage ( vec.begin() + vecslice1,vec.begin() + vecslice2 , adc2voltage);
}

template < class T > inline void hADC2Voltage_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) {
hADC2Voltage ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , adc2voltage);
}


void (*fptr_hADC2Voltage_hSLICED_STL_HComplex_1HNumber_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;
void (*fptr_hADC2Voltage_hSLICED_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;
void (*fptr_hADC2Voltage_hSLICED_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

    \param Beta: Width parameter of Hanning function

    \param BetaRise: Rising slope parameter of Hanning function

    \param BetaFall: Falling slope parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha,
         const uint Beta,
         const uint BetaRise,
         const uint BetaFall) {
  uint blocksize = vec_end - vec;
  CR::HanningFilter<HNumber> hanning_filter(blocksize, Alpha, Beta, BetaRise, BetaFall);
  Iter it_v = vec;
  casa::Vector<HNumber> filter = hanning_filter.weights();
  casa::Vector<HNumber>::iterator it_f = filter.begin();
  while ((it_v != vec_end) && (it_f != filter.end())) {
    *it_v = (typename Iter::value_type) *it_f;
    it_v++; it_f++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta , BetaRise , BetaFall);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta , BetaRise , BetaFall);
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha , Beta , BetaRise , BetaFall);
}


void (*fptr_hGetHanningFilter_STL_HComplex_1HNumberuintuintuint_STDIT)( std::vector<HComplex> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_1HNumberuintuintuint_STDIT)( hArray<HComplex> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_1HNumberuintuintuint_STDIT)( std::vector<HNumber> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_1HNumberuintuintuint_STDIT)( hArray<HNumber> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_1HNumberuintuintuint_STDIT)( std::vector<HInteger> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_1HNumberuintuintuint_STDIT)( hArray<HInteger> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha , Beta , BetaRise , BetaFall);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha , Beta , BetaRise , BetaFall);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumberuintuintuint_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumberuintuintuint_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumberuintuintuint_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

    \param Beta: Width parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha,
         const uint Beta) {
  uint blocksize = vec_end - vec;
  uint BetaRise = (blocksize - Beta)/2;
  uint BetaFall = (blocksize - Beta)/2;
  hGetHanningFilter(vec, vec_end, Alpha, Beta, BetaRise, BetaFall);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha , uint Beta) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha , uint Beta) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta);
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha , uint Beta) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha , Beta);
}


void (*fptr_hGetHanningFilter_STL_HComplex_1HNumberuint_STDIT)( std::vector<HComplex> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_1HNumberuint_STDIT)( hArray<HComplex> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_1HNumberuint_STDIT)( std::vector<HNumber> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_1HNumberuint_STDIT)( hArray<HNumber> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_1HNumberuint_STDIT)( std::vector<HInteger> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_1HNumberuint_STDIT)( hArray<HInteger> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha , Beta);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha , Beta);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumberuint_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumberuint_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumberuint_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha) {
  uint Beta = 0;
  hGetHanningFilter(vec, vec_end, Alpha, Beta);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha);
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha);
}


void (*fptr_hGetHanningFilter_STL_HComplex_1HNumber_STDIT)( std::vector<HComplex> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_1HNumber_STDIT)( hArray<HComplex> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber Alpha) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumber_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end){
  double Alpha = 0.5;
  hGetHanningFilter(vec, vec_end, Alpha);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec) {
hGetHanningFilter ( vec.begin(),vec.end());
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end());
vec.next();
iterate = vec.iterate(); };
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec) {
hGetHanningFilter ( vec.cbegin(),vec.cend());
}


void (*fptr_hGetHanningFilter_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & vec) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply a predefined filter on a vector.

    \param data: Vector containing the data on which the filter will be applied.

    \param filter: Vector containing the filter.

*/
template <class Iter, class IterFilter>
void hApplyFilter(const Iter data, const Iter data_end, const IterFilter filter, IterFilter filter_end){
  Iter it_d = data;
  IterFilter it_f = filter;
  while ((it_d != data_end) && (it_f != filter_end)) {
    *it_d *= (typename Iter::value_type) *it_f;
    it_d++; it_f++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hApplyFilter( std::vector<T> & data , std::vector<T> & filter) {
hApplyFilter ( data.begin(),data.end() , filter.begin(),filter.end());
}

template < class T > inline void hApplyFilter( hArray<T> & data , hArray<T> & filter) {
bool iterate=true;
while(iterate) {
hApplyFilter ( data.begin(),data.end() , filter.begin(),filter.end());
data.next();
filter.next();
iterate = data.iterate(); };
}

template < class T > inline void hApplyFilter( casa::Vector<T> & data , casa::Vector<T> & filter) {
hApplyFilter ( data.cbegin(),data.cend() , filter.cbegin(),filter.cend());
}


void (*fptr_hApplyFilter_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & data , std::vector<HComplex> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HComplex_11_STDITSTDIT)( hArray<HComplex> & data , hArray<HComplex> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & data , std::vector<HNumber> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HNumber_11_STDITSTDIT)( hArray<HNumber> & data , hArray<HNumber> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & data , std::vector<HInteger> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HInteger_11_STDITSTDIT)( hArray<HInteger> & data , hArray<HInteger> & filter) = &hApplyFilter;

template < class T > inline void hApplyFilter_hSLICED ( std::vector<T> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<T> & filter , HInteger filterslice1 , HInteger filterslice2) {
hApplyFilter ( data.begin() + dataslice1,data.begin() + dataslice2 , filter.begin() + filterslice1,filter.begin() + filterslice2);
}

template < class T > inline void hApplyFilter_hSLICED ( casa::Vector<T> & data , HInteger dataslice1 , HInteger dataslice2 , casa::Vector<T> & filter , HInteger filterslice1 , HInteger filterslice2) {
hApplyFilter ( data.cbegin() + dataslice1,data.cbegin() + dataslice2 , filter.cbegin() + filterslice1,filter.cbegin() + filterslice2);
}


void (*fptr_hApplyFilter_hSLICED_STL_HComplex_11_STDITSTDIT)( std::vector<HComplex> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HComplex> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;
void (*fptr_hApplyFilter_hSLICED_STL_HNumber_11_STDITSTDIT)( std::vector<HNumber> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HNumber> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;
void (*fptr_hApplyFilter_hSLICED_STL_HInteger_11_STDITSTDIT)( std::vector<HInteger> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HInteger> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply a Hanning filter on a vector.

    \param data: Input and return vector containing the data on which the Hanning filter will be applied.

*/
template <class Iter>
void hApplyHanningFilter(const Iter data, const Iter data_end){
  uint blocksize = data_end - data;
  vector<HNumber> filter(blocksize);
  hGetHanningFilter(filter.begin(), filter.end());
  hApplyFilter(data, data_end, filter.begin(), filter.end());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hApplyHanningFilter( std::vector<T> & data) {
hApplyHanningFilter ( data.begin(),data.end());
}

template < class T > inline void hApplyHanningFilter( hArray<T> & data) {
bool iterate=true;
while(iterate) {
hApplyHanningFilter ( data.begin(),data.end());
data.next();
iterate = data.iterate(); };
}

template < class T > inline void hApplyHanningFilter( casa::Vector<T> & data) {
hApplyHanningFilter ( data.cbegin(),data.cend());
}


void (*fptr_hApplyHanningFilter_STL_HComplex_1_STDIT)( std::vector<HComplex> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HComplex_1_STDIT)( hArray<HComplex> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_STL_HNumber_1_STDIT)( std::vector<HNumber> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HNumber_1_STDIT)( hArray<HNumber> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_STL_HInteger_1_STDIT)( std::vector<HInteger> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HInteger_1_STDIT)( hArray<HInteger> & data) = &hApplyHanningFilter;

template < class T > inline void hApplyHanningFilter_hSLICED ( std::vector<T> & data , HInteger dataslice1 , HInteger dataslice2) {
hApplyHanningFilter ( data.begin() + dataslice1,data.begin() + dataslice2);
}

template < class T > inline void hApplyHanningFilter_hSLICED ( casa::Vector<T> & data , HInteger dataslice1 , HInteger dataslice2) {
hApplyHanningFilter ( data.cbegin() + dataslice1,data.cbegin() + dataslice2);
}


void (*fptr_hApplyHanningFilter_hSLICED_STL_HComplex_1_STDIT)( std::vector<HComplex> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;
void (*fptr_hApplyHanningFilter_hSLICED_STL_HNumber_1_STDIT)( std::vector<HNumber> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;
void (*fptr_hApplyHanningFilter_hSLICED_STL_HInteger_1_STDIT)( std::vector<HInteger> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply an FFT on a vector.

    \param data_in: Vector containing the data on which the FFT will be applied.

    \param data_out: Return vector in which the FFT transformed data is stored.

    \param nyquistZone: Nyquist zone

*/
template <class IterIn, class IterOut>
void hFFT(const IterIn data_in, const IterIn data_in_end,
      const IterOut data_out, const IterOut data_out_end,
      const HInteger nyquistZone) {
  uint channel;
  uint blocksize(data_in_end - data_in);
  uint fftLength(blocksize/2+1);
  uint nofChannels(fftLength);
  IPosition shape_in(1,blocksize);
  IPosition shape_out(1,fftLength);
  FFTServer<Double,DComplex> fftserver(shape_in, FFTEnums::REALTOCOMPLEX);
  //  Vector<Double> cvec_in(shape_in, reinterpret_cast<Double*>(&(*data_in)), casa::SHARE);
  Vector<Double> cvec_in(shape_in, 0.);
  Vector<DComplex> cvec_out(shape_out, 0.);
  IterIn it_in = data_in;
  IterOut it_out = data_out;
  Vector<Double>::iterator it_vin=cvec_in.begin();
  // make copy of input vector since fft will also modify the order of the input data.
  while ((it_in != data_in_end) && (it_vin != cvec_in.end())) {
    *it_vin = *it_in;
    it_in++; it_vin++;
  }
  // Apply FFT
  fftserver.fft(cvec_out, cvec_in);
  // Is there some aftercare needed (checking/setting the size of the in/output vector)
  switch (nyquistZone) {
  case 1:
  case 3:
  case 5:
    {
      it_out = data_out;
      channel = 0;
      while ((it_out != data_out_end) && (channel < nofChannels)) {
 *it_out = cvec_out(channel);
 it_out++; channel++;
      }
    }
    break;
  case 2:
  case 4:
  case 6:
    {
      /// See datareader for implementation.
      it_out = data_out;
      channel = 0;
      while ((it_out != data_out_end) && (channel < nofChannels)) {
 *it_out = conj(cvec_out(fftLength - channel - 1));
 it_out++; channel++;
      }
    }
    break;
  }
  /// TODO: Check if output is correct.
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hFFT( std::vector<HNumber> & data_in , std::vector<HComplex> & data_out , HInteger nyquistZone) {
hFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
}

inline void hFFT( hArray<HNumber> & data_in , hArray<HComplex> & data_out , HInteger nyquistZone) {
bool iterate=true;
while(iterate) {
hFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
data_in.next();
data_out.next();
iterate = data_in.iterate(); };
}

inline void hFFT( casa::Vector<HNumber> & data_in , casa::Vector<HComplex> & data_out , HInteger nyquistZone) {
hFFT ( data_in.cbegin(),data_in.cend() , data_out.cbegin(),data_out.cend() , nyquistZone);
}


void (*fptr_hFFT_STL_HInteger_HNumberHComplexHInteger_STDITSTDIT)( std::vector<HNumber> & data_in , std::vector<HComplex> & data_out , HInteger nyquistZone) = &hFFT;
void (*fptr_hFFT_hARRAY_HInteger_HNumberHComplexHInteger_STDITSTDIT)( hArray<HNumber> & data_in , hArray<HComplex> & data_out , HInteger nyquistZone) = &hFFT;

 inline void hFFT_hSLICED ( std::vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hFFT ( data_in.begin() + data_inslice1,data_in.begin() + data_inslice2 , data_out.begin() + data_outslice1,data_out.begin() + data_outslice2 , nyquistZone);
}

inline void hFFT_hSLICED ( casa::Vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , casa::Vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hFFT ( data_in.cbegin() + data_inslice1,data_in.cbegin() + data_inslice2 , data_out.cbegin() + data_outslice1,data_out.cbegin() + data_outslice2 , nyquistZone);
}


void (*fptr_hFFT_hSLICED_STL_HInteger_HNumberHComplexHInteger_STDITSTDIT)( std::vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) = &hFFT_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply an Inverse FFT on a vector.

    \param data_in: Vector containing the input data on which the inverse FFT will be applied.

    \param data_out: Return vector in which the inverse FFT transformed data is stored.

    \param nyquistZone: Nyquist zone

*/
template <class IterIn, class IterOut>
void hInvFFT(const IterIn data_in, const IterIn data_in_end,
      const IterOut data_out, const IterOut data_out_end,
      const HInteger nyquistZone) {
  uint channel;
  uint blocksize(data_out_end - data_out);
  uint fftLength(blocksize/2+1);
  uint nofChannels(fftLength);
  IPosition shape_in(1,fftLength);
  IPosition shape_out(1,blocksize);
  Vector<DComplex> cvec_f(shape_in, reinterpret_cast<DComplex*>(&(*data_in)), casa::SHARE);
  Vector<DComplex> cvec_in(fftLength);
  Vector<Double> cvec_out(shape_out, 0.);
  if ((data_in_end - data_in) != (int)fftLength) {
    cerr << "[invfft] Bad input: len(data_in) != fftLength" << endl;
    cerr << "  len(data_in) = " << (data_in_end - data_in) << endl;
    cerr << "  fftLength    = " << fftLength << endl;
  };
  try {
    FFTServer<Double,DComplex> server(shape_out,
          FFTEnums::REALTOCOMPLEX);
    switch (nyquistZone) {
    case 1:
    case 3:
      for (channel=0; channel<nofChannels; channel++) {
    cvec_in(channel) = cvec_f(channel);
      }
      break;
    case 2:
      for (channel=0; channel<nofChannels; channel++) {
   cvec_in(channel) = conj(cvec_f(fftLength - channel - 1));
      }
      break;
    }
    server.fft(cvec_out,cvec_in);
    // Copy result back to data_out
    Vector<Double>::iterator it_vout= cvec_out.begin();
    IterOut it_dout = data_out;
    while ((it_vout != cvec_out.end()) && (it_dout != data_out_end)) {
      *it_dout = *it_vout;
      it_vout++; it_dout++;
    }
  } catch (AipsError x) {
    cerr << "[invfft]" << x.getMesg() << endl;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hInvFFT( std::vector<HComplex> & data_in , std::vector<HNumber> & data_out , HInteger nyquistZone) {
hInvFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
}

inline void hInvFFT( hArray<HComplex> & data_in , hArray<HNumber> & data_out , HInteger nyquistZone) {
bool iterate=true;
while(iterate) {
hInvFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
data_in.next();
data_out.next();
iterate = data_in.iterate(); };
}

inline void hInvFFT( casa::Vector<HComplex> & data_in , casa::Vector<HNumber> & data_out , HInteger nyquistZone) {
hInvFFT ( data_in.cbegin(),data_in.cend() , data_out.cbegin(),data_out.cend() , nyquistZone);
}


void (*fptr_hInvFFT_STL_HInteger_HComplexHNumberHInteger_STDITSTDIT)( std::vector<HComplex> & data_in , std::vector<HNumber> & data_out , HInteger nyquistZone) = &hInvFFT;
void (*fptr_hInvFFT_hARRAY_HInteger_HComplexHNumberHInteger_STDITSTDIT)( hArray<HComplex> & data_in , hArray<HNumber> & data_out , HInteger nyquistZone) = &hInvFFT;

 inline void hInvFFT_hSLICED ( std::vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hInvFFT ( data_in.begin() + data_inslice1,data_in.begin() + data_inslice2 , data_out.begin() + data_outslice1,data_out.begin() + data_outslice2 , nyquistZone);
}

inline void hInvFFT_hSLICED ( casa::Vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , casa::Vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hInvFFT ( data_in.cbegin() + data_inslice1,data_in.cbegin() + data_inslice2 , data_out.cbegin() + data_outslice1,data_out.cbegin() + data_outslice2 , nyquistZone);
}


void (*fptr_hInvFFT_hSLICED_STL_HInteger_HComplexHNumberHInteger_STDITSTDIT)( std::vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) = &hInvFFT_hSLICED;

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:              I/O Function (DataReader)
//========================================================================
//------------------------------------------------------------------------
/*!
 \brief Print a brief summary of the file contents and current settings.

    \param dr: DataReader object

*/
void hFileSummary(CRDataReader & dr) {
  dr.summary();
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hFileSummary_STL_HInteger_CRDataReader_)( CRDataReader & dr) = &hFileSummary;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Function to open a file based on a filename and returning a datareader object.

    \param Filename: Filename of file to opwn including full directory name

*/
CRDataReader & hFileOpen(HString Filename) {
  bool opened;
  //Create the a pointer to the DataReader object and store the pointer
  CR::DataReader* drp;
  HString Filetype = hgetFiletype(Filename);
  if (Filetype=="LOPESEvent") {
    CR::LopesEventIn* lep = new CR::LopesEventIn;
    opened=lep->attachFile(Filename);
    drp=lep;
    cout << "Opening LOPES File="<<Filename<<endl; drp->summary();
  } else if (Filetype=="LOFAR_TBB") {
    drp = new CR::LOFAR_TBB(Filename,1024);
    opened=drp!=__null;
    cout << "Opening LOFAR File="<<Filename<<endl; drp->summary();
  } else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4387 << ": " << "hFileOpen" << ": Unknown Filetype = " << Filetype << ", Filename=" << Filename << endl );
    opened=false;
  }
  if (!opened){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4391 << ": " << "hFileOpen" << ": Opening file " << Filename << " failed." << endl );
    CR::LopesEventIn* lep = new CR::LopesEventIn; //Make a dummy data reader ....  
    drp=lep;
  };
  return *drp;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileOpen_STL_HInteger_HString_)( HString Filename) = &hFileOpen;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return information from a data file as a Python object.

    \param dr: Datareader object openen, e.g. with hFileOpen or crfile.

    \param keyword: Keyword ro be read out from the file metadata

*/
HPyObject hFileGetParameter(CRDataReader &dr, HString key)
{
  DataReader *drp=&dr;
  if (key== "nofAntennas") {
uint result(drp->nofAntennas ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nofSelectedChannels") {
uint result(drp->nofSelectedChannels ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nofSelectedAntennas") {
uint result(drp->nofSelectedAntennas ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "blocksize") {
uint result(drp->blocksize ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "fftLength") {
uint result(drp->fftLength ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "block") {
uint result(drp->block ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "stride") {
uint result(drp->stride ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nyquistZone") {
uint result(drp->nyquistZone ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "sampleInterval") {
double result(drp->sampleInterval ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "referenceTime") {
double result(drp->referenceTime ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "sampleFrequency") {
double result(drp->sampleFrequency ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "nofBaselines") {
uint result(drp->nofBaselines ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "antennas") {
casa::Vector<uint> casavec(drp->antennas ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "selectedAntennas") {
casa::Vector<uint> casavec(drp->selectedAntennas ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "selectedChannels") {
casa::Vector<uint> casavec(drp->selectedChannels ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "positions") {
casa::Vector<uint> casavec(drp->positions ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "increment") {
casa::Vector<double> casavec(drp->increment ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "frequencyValues") {
casa::Vector<double> casavec(drp->frequencyValues ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "frequencyRange") {
casa::Vector<double> casavec(drp->frequencyRange ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
      if (key== "Date") {
uint result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "Observatory") {
casa::String result;
drp->headerRecord().get(key,result);
HPyObject pyob((HString)result);
return pyob;} else
 if (key== "Filesize") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "dDate") {
double result;
drp->headerRecord().get(key,result);
HPyObject pyob((double)result);
return pyob;} else
 if (key== "presync") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "TL") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "LTL") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "EventClass") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "SampleFreq") {
casa::uChar result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "StartSample") {
uint result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "AntennaIDs") {
casa::Vector<int> casavec;
drp->headerRecord().get(key,casavec);
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    { HString result; result = result
  + "nofAntennas" + ", "
    + "nofSelectedChannels" + ", "
    + "nofSelectedAntennas" + ", "
    + "nofBaselines" + ", "
    + "block" + ", "
    + "blocksize" + ", "
    + "stride" + ", "
    + "fftLength" + ", "
    + "nyquistZone" + ", "
    + "sampleInterval" + ", "
    + "referenceTime" + ", "
    + "sampleFrequency" + ", "
    + "antennas" + ", "
    + "selectedAntennas" + ", "
    + "selectedChannels" + ", "
    + "positions" + ", "
    + "increment" + ", "
    + "frequencyValues" + ", "
    + "frequencyRange" + ", "
      + "Date" + ", "
 + "Observatory" + ", "
 + "Filesize" + ", "
 + "dDate" + ", "
 + "presync" + ", "
 + "TL" + ", "
 + "LTL" + ", "
 + "EventClass" + ", "
 + "SampleFreq" + ", "
 + "StartSample" + ", "
//------------------------------------------------------------------------
 + "AntennaIDs" + ", "
       + "help";
      if (key!="help") cout << "Unknown keyword " << key <<"!"<<endl;
      cout << "hFileGetParameter" << " - available keywords: "<< result <<endl;
      HPyObject pyob(result);
      return pyob;
    };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HPyObject (*fptr_hFileGetParameter_STL_HInteger_CRDataReaderHString_)( CRDataReader & dr , HString keyword) = &hFileGetParameter;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
 \brief Set parameters in a data file with a Python object as input.

    \param dr: Datareader object openen, e.g. with hFileOpen or crfile.

    \param keyword: Keyword to be set in the file

    \param pyob: Input paramter

*/
CRDataReader & hFileSetParameter(CRDataReader &dr, HString key, HPyObjectPtr pyob)
{
  DataReader *drp=&dr;
  if (key== "Block") {uint input(PyInt_AsLong (pyob)); drp->setBlock (input);} else
    if (key== "Blocksize") {uint input(PyInt_AsLong (pyob)); drp->setBlocksize (input);} else
    if (key== "StartBlock") {uint input(PyInt_AsLong (pyob)); drp->setStartBlock (input);} else
    if (key== "Stride") {uint input(PyInt_AsLong (pyob)); drp->setStride (input);} else
    if (key== "SampleOffset") {uint input(PyInt_AsLong (pyob)); drp->setSampleOffset (input);} else
    if (key== "NyquistZone") {uint input(PyInt_AsLong (pyob)); drp->setNyquistZone (input);} else
    if (key== "ReferenceTime") {double input(PyFloat_AsDouble (pyob)); drp->setReferenceTime (input);} else
    if (key== "SampleFrequency") {double input(PyFloat_AsDouble (pyob)); drp->setSampleFrequency (input);} else
    if (key== "Shift") {int input(PyInt_AsLong (pyob)); drp->setShift (input);} else
    if (key=="SelectedAntennas") {
      vector<uint> stlvec(PyList2STLuIntVec(pyob));
      uint * storage = &(stlvec[0]);
      casa::IPosition shape(1,stlvec.size()); //tell casa the size of the vector
      casa::Vector<uint> casavec(shape,storage,casa::SHARE);
      drp->setSelectedAntennas(casavec);
    } else
    { HString txt; txt = txt
  + "Blocksize" + ", "
    + "StartBlock" + ", "
    + "Block" + ", "
    + "Stride" + ", "
    + "SampleOffset" + ", "
    + "NyquistZone" + ", "
    + "ReferenceTime" + ", "
    + "SampleFrequency" + ", "
    + "Shift" + ", "
    + "SelectedAntennas" + ", "
       + "help";
      if (key!="help") cout << "Unknown keyword " << key <<"!"<<endl;
      cout << "hFileSetParameter" << " - available keywords: "<< txt <<endl;
    };
  return dr;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileSetParameter_STL_HInteger_CRDataReaderHStringHPyObjectPtr_)( CRDataReader & dr , HString keyword , HPyObjectPtr pyob) = &hFileSetParameter;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
 \brief Read data from a Datareader object (pointer in iptr) into a vector, where the size should be pre-allocated.

    \param dr: Datareader object, opened e.g. with hFileOpen or crfile.

    \param Datatype: Name of the data column to be retrieved 

    \param vec: Data 


Example on how to use this with the Python wrapper

file=hFileOpen("data/lofar/RS307C-readfullsecond.h5")
file=hFileOpen("/Users/falcke/LOFAR/usg/data/lopes/test.event")

#offsets=IntVec()
idata=IntVec()
hReadFile(file,"Fx",idata)
hCloseFile(file)

The data will then be in the vector idata. You can covert that to a
Python list with [].extend(idata)
*/
template <class T>
CRDataReader & hFileRead(
      CRDataReader &dr,
      HString Datatype,
      std::vector<T> & vec
      )
{
  //Create a DataReader Pointer from an interger variable
  DataReader *drp=&dr;
  //Check whether it is non-NULL.
  if (drp==reinterpret_cast<HPointer>(__null)){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4605 << ": " << "hFileRead" << ": pointer to FileObject is NULL, DataReader not found." << endl );
    return dr;
  };
  //------TIME------------------------------
  if (Datatype=="Time") {
    if (typeid(vec) == typeid(vector<double>)) {
      std::vector<double> * vec_p;
      vec_p=reinterpret_cast<vector<double>*>(&vec); //That is just a trick to fool the compiler
      drp->timeValues(*vec_p);
    } else {
      cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
    };
  //------FREQUENCY------------------------------
  } else if (Datatype=="Frequency") {
    if (typeid(vec) == typeid(vector<double>)) {
    casa::Vector<double> val = drp->frequencyValues();
    aipsvec2stlvec(val,vec);
    } else {
      cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
    };
  }
//..........................................................................................
//Conversion from aips to stl using shared memory space
//..........................................................................................
//..........................................................................................
  //------FX------------------------------
  else if (Datatype=="Fx") {if (typeid(vec)==typeid(std::vector<HNumber>)) {
casa::IPosition shape(2);
shape(0)=drp->blocksize (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<double> casamtrx(shape,reinterpret_cast<double*>(&(vec[0])),casa::SHARE);
drp->fx (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------VOLTAGE------------------------------
  else if (Datatype=="Voltage") {if (typeid(vec)==typeid(std::vector<HNumber>)) {
casa::IPosition shape(2);
shape(0)=drp->blocksize (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<double> casamtrx(shape,reinterpret_cast<double*>(&(vec[0])),casa::SHARE);
drp->voltage (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------FFT------------------------------
  else if (Datatype=="FFT") {if (typeid(vec)==typeid(std::vector<HComplex>)) {
casa::IPosition shape(2);
shape(0)=drp->fftLength (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<CasaComplex> casamtrx(shape,reinterpret_cast<CasaComplex*>(&(vec[0])),casa::SHARE);
drp->fft (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------CALFFT------------------------------
  else if (Datatype=="CalFFT") {if (typeid(vec)==typeid(std::vector<HComplex>)) {
casa::IPosition shape(2);
shape(0)=drp->fftLength (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<CasaComplex> casamtrx(shape,reinterpret_cast<CasaComplex*>(&(vec[0])),casa::SHARE);
drp->calfft (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4650 << ": " << "hFileRead" << ": Datatype=" << Datatype << " is unknown." << endl );
    vec.clear();
  };
  return dr;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileRead_STL_HComplex_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HComplex> & vec) = &hFileRead;
CRDataReader & (*fptr_hFileRead_STL_HNumber_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HNumber> & vec) = &hFileRead;
CRDataReader & (*fptr_hFileRead_STL_HInteger_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HInteger> & vec) = &hFileRead;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return a list of antenna positions from the CalTables - this is a test.

    \param filename: Filename of the caltable

    \param keyword: Keyword to be read out from the file metadata 

    \param date: Date for which the information is requested

    \param pyob: 


Example:
antennaIDs=hFileGetParameter(file,"AntennaIDs")
x=hCalTable("~/LOFAR/usg/data/lopes/LOPES-CalTable",obsdate,list(antennaIDs))

*/
HPyObjectPtr hCalTable(HString filename, HString keyword, HInteger date, HPyObjectPtr pyob) {
  CR::CalTableReader* CTRead = new CR::CalTableReader(filename);
  HInteger i,ant,size;
  casa::Vector<Double> tmpvec;
  HPyObjectPtr list=PyList_New(0),tuple;
  if (CTRead != __null && ((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)) { //Check if CalTable was opened ... and Python object is a list
    size=PyList_Size(pyob);
    for (i=0;i<size;++i){ //loop over all antennas
      ant=PyInt_AsLong(PyList_GetItem(pyob,i)); //Get the ith element of the list, i.e. the antenna ID
      CTRead->GetData((uint)date, ant, keyword, &tmpvec);
      tuple=PyTuple_Pack(3,PyFloat_FromDouble(tmpvec[0]),PyFloat_FromDouble(tmpvec[1]),PyFloat_FromDouble(tmpvec[2]));
      PyList_Append(list,tuple);
    };
  };
  return list;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HPyObjectPtr (*fptr_hCalTable_STL_HInteger_HStringHStringHIntegerHPyObjectPtr_)( HString filename , HString keyword , HInteger date , HPyObjectPtr pyob) = &hCalTable;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:      Coordinate Conversion (VectorConversion.cc)
//========================================================================
//$ORIGIN: Math/VectorConversion.cc
//-----------------------------------------------------------------------
/*!
  \brief Converts a 3D spatial vector into a different Coordinate type (e.g. Spherical to Cartesian).

    \param source: Coordinates of the source to be converted - vector of length 3

    \param sourceCoordinate: Type of the coordinates for the source

    \param target: Coordinates of the source to be converted - vector of length 3

    \param targetCoordinate: Type of the coordinates for the target 

    \param anglesInDegrees: True if the angles are in degree, otherwise in radians


Available Coordinate Types are:

      -  Azimuth-Elevation-Height, \f$ \vec x = (Az,El,H) \f$
      AzElHeight,
      -  Azimuth-Elevation-Radius, \f$ \vec x = (Az,El,R) \f$
      AzElRadius,
      -  Cartesian coordinates, \f$ \vec x = (x,y,z) \f$
      Cartesian,
      -  Cylindrical coordinates, \f$ \vec x = (r,\phi,h) \f$
      Cylindrical,
      -  Direction on the sky, \f$ \vec x = (Lon,Lat) \f$
      Direction,
      -  Direction on the sky with radial distance, \f$ \vec x = (Lon,Lat,R) \f$
      DirectionRadius,
      -  Frquency
      Frequency,
      -  Longitude-Latitude-Radius
      LongLatRadius,
      -  North-East-Height
      NorthEastHeight,
      -  Spherical coordinates, \f$ \vec x = (r,\phi,\theta) \f$
      Spherical,
      - Time
      Time
*/
template <class Iter>
bool hCoordinateConvert (Iter source,
      CR::CoordinateType::Types const &sourceCoordinate,
      Iter target,
      CR::CoordinateType::Types const &targetCoordinate,
      bool anglesInDegrees
      )
{
  return CR::convertVector(
      *target,
      *(target+1),
      *(target+2),
      targetCoordinate,
      *source,
      *(source+1),
      *(source+2),
      sourceCoordinate,
      anglesInDegrees
          );
    }
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline bool hCoordinateConvert( std::vector<HNumber> & source , CRCoordinateType sourceCoordinate , std::vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
return hCoordinateConvert ( source.begin() , sourceCoordinate , target.begin() , targetCoordinate , anglesInDegrees);
}

inline BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(bool, vector<bool>) hCoordinateConvert( hArray<HNumber> & source , CRCoordinateType sourceCoordinate , hArray<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
bool iterate=true;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, vector<bool> returnvector;
bool returnvalue;
) while(iterate) {
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(, returnvalue =) hCoordinateConvert ( source.begin() , sourceCoordinate , target.begin() , targetCoordinate , anglesInDegrees);
source.next();
target.next();
iterate = source.iterate(); BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(};, returnvector.push_back(returnvalue); };
return returnvector;)
}

inline bool hCoordinateConvert( casa::Vector<HNumber> & source , CRCoordinateType sourceCoordinate , casa::Vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
return hCoordinateConvert ( source.cbegin() , sourceCoordinate , target.cbegin() , targetCoordinate , anglesInDegrees);
}


bool (*fptr_hCoordinateConvert_STL_HInteger_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & source , CRCoordinateType sourceCoordinate , std::vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) = &hCoordinateConvert;
BOOST_PP_IIF_BOOST_PP_BOOL_HFPP_FUNC_IS_VOID(bool, vector<bool >) (*fptr_hCoordinateConvert_hARRAY_HInteger_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED)( hArray<HNumber> & source , CRCoordinateType sourceCoordinate , hArray<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) = &hCoordinateConvert;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================================
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//========================================================================================
//-----------------------------------------------------------------------
//#define HFPP_PARDEF_8 (HInteger)(Offsets)()("Offsets per antenna")(HFPP_PAR_IS_VECTOR)(STL)(HFPP_PASS_AS_REFERENCE)
/*!
 \brief Read data from a Datareader object (pointer in iptr) into a vector.

    \param vec: Data 

    \param iptr: Integer containing pointer to the datareader object

    \param Datatype: Name of the data column to be retrieved 

    \param Antenna: Antenna number

    \param Blocksize: Length of the data block to read

    \param Block: Block number to read

    \param Stride: Stride between blocks

    \param Shift: Shift start of first block by n samples


Example on how to use this with the Python wrapper

file=hOpenFile("data/lofar/RS307C-readfullsecond.h5")
file=hOpenFile("/Users/falcke/LOFAR/usg/data/lopes/test.event")

#offsets=IntVec()
data=FloatVec()
idata=IntVec()
cdata=ComplexVec()
sdata=StringVec()
Datatype="Fx"
Antenna=1
Blocksize=1024
Block=10
Stride=0
Shift=0
hReadFile(idata,file,Datatype,Antenna,Blocksize,Block,Stride,Shift,offsets)
hCloseFile(file)

The data will then be in the vector idata. You can covert that to a
Python list with [].extend(idata)
*/
template <class T>
void hReadFileOld(std::vector<T> & vec,
      HIntPointer iptr,
      HString Datatype,
      HInteger Antenna,
      HInteger Blocksize,
      HInteger Block,
      HInteger Stride,
      HInteger Shift)
//	       std::vector<HInteger> & Offsets)
{
  DataReader *drp=reinterpret_cast<DataReader*>(iptr);
  //First retrieve the pointer to the pointer to the dataRead and check whether it is non-NULL.
  if (drp==reinterpret_cast<HPointer>(__null)){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4862 << ": " << "dataRead: pointer to FileObject is NULL, DataReader not found." << endl );
    return;
  };
//!!!One Needs to verify somehow that the parameters make sense !!!
  if (Antenna > static_cast<HInteger>(drp->nofAntennas()-1)) {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4868 << ": " << "Requested Antenna number too large!" << endl );
    return;
  };
  drp->setBlocksize(Blocksize);
  drp->setBlock(Block);
  drp->setStride(Stride);
  drp->setShift(Shift);
  casa::Vector<uint> antennas(1,Antenna);
  drp->setSelectedAntennas(antennas);
  address ncol;
  if (Datatype=="Time") {
    if (typeid(vec) == typeid(vector<double>)) {
      std::vector<double> * vec_p;
      vec_p=reinterpret_cast<vector<double>*>(&vec); //That is just a tr
      drp->timeValues(*vec_p);
    } else {
      std::vector<double> tmpvec;
      drp->timeValues(tmpvec);
      hConvert(tmpvec,vec);
    };
  }
  else if (Datatype=="Frequency") {
    //vector<HNumber>* vp2; *vp2 = drp->frequencyValues().tovec();
    //    std::vector<double> vals;
    //copycast_vec(vals,vec);
    casa::Vector<double> val = drp->frequencyValues();
    aipsvec2stlvec(val,vec);
  }
  else if (Datatype=="Fx") {
//hf #define MAKE_UNION_CASA_MATRIX_AND_STLVEC(TYPECASA,STLVEC,CASAVEC) //     casa::IPosition shape(2,STLVEC.size()); shape(1)=1;	//     casa::Matrix<TYPECASA> CASAVEC(shape,reinterpret_cast<TYPECASA*>(&(STLVEC[0])),casa::SHARE)
//     if (typeid(vec)==typeid(std::vector<double>)) {
//       vec.resize(Blocksize);
//       MAKE_UNION_CASA_MATRIX_AND_STLVEC(double,vec,mtrx);
//       drp->fx(mtrx);
//     } else {
//       std::vector<double> nvec(Blocksize);
//       MAKE_UNION_CASA_MATRIX_AND_STLVEC(double,nvec,mtrx);
//       drp->fx(mtrx);
//       copycast_vec(nvec,vec); //Copy back to output vector and convert type
//     };
    casa::Matrix<CasaNumber> ary=drp->fx();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="Voltage") {
    //    std::vector<HNumber>* vp2 = new std::vector<HNumber>;
    casa::Matrix<CasaNumber> ary=drp->voltage();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="invFFT") {
    //    std::vector<HNumber>* vp2 = new std::vector<HNumber>;
    casa::Matrix<CasaNumber> ary=drp->invfft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="FFT") {
    //    std::vector<HComplex>* vp2 = new std::vector<HComplex>;
    casa::Matrix<CasaComplex> ary=drp->fft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="CalFFT") {
    //    std::vector<HComplex>* vp2 = new std::vector<HComplex>;
    casa::Matrix<CasaComplex> ary=drp->calfft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 4940 << ": " << "DataFunc_CR_dataRead: Datatype=" << Datatype << " is unknown." << endl );
    vec.clear();
    return;
  };
  return;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hReadFileOld_STL_HComplex_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HComplex> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;
void (*fptr_hReadFileOld_STL_HNumber_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HNumber> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;
void (*fptr_hReadFileOld_STL_HInteger_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HInteger> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*
  else if (Datatype=="Fx") {aipscol2stlvec(drp->fx(),*vp,0);}
  else if (Datatype=="Voltage") {aipscol2stlvec(drp->voltage(),*vp,0);}
  else if (Datatype=="invFFT") {aipscol2stlvec(drp->invfft(),*vp,0);}
  else if (Datatype=="FFT") {aipscol2stlvec(drp->fft(),*vp,0);}
  else if (Datatype=="CalFFT") {aipscol2stlvec(drp->calfft(),*vp,0);}
*/
//       std::vector<double> tmpvec;
//       STL2CASA_SHARED(double,tmpvec,casavec); //Create casa vector sharing memory with the stl vector
//       casa::Vector<double> * vec_p;  //Get pointer to casa vector
//       vec_p=reinterpret_cast<casa::Vector<double>*>(&casavec); //That is just a trick to fool the compiler to
//                                                               //compile this section for T!=double (even though it is then never used)
//       *vec_p=drp->frequencyValues(); //read data into the casa and hence also into the stl vector
//       hConvert(tmpvec,vec);
//     }  else {   //Input vector is not of the right format
//       std::vector<double> tmpvec;  //Create temporary stl vector
//       STL2CASA_SHARED(double,tmpvec,casavec);  //Create casa vector sharing memory with the tmp stl vector
//       casavec=drp->frequencyValues(); //read data into the casa vector (hence als tmp stl vector)
//       hConvert(tmpvec,vec); // Copy and convert data from tmp stl (=casa) vector to the output vector.
//     };
//========================================================================================
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//========================================================================================
////////////////////////////////////////////////////////////////////////
//Definition of Python bindings for hftools ...
////////////////////////////////////////////////////////////////////////
// Tell the preprocessor (for generating wrappers) that this is a c++
// header file for Python exposure
//BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(hArray_setDimensions_overloads,setDimensions<HNumber>,1,2)
/*
std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_1)(HInteger dim0) = &std::hArray<HNumber>::setDimensions1;
std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_2)(HInteger dim0, HInteger dim1)= &std::hArray<HNumber>::setDimensions;
*/
//std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_1)(HInteger dim0) = &std::hArray::setDimensions;
//std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_2)(HInteger dim0, HInteger dim1) = &std::hArray::setDimensions;
void init_module_hftools(); extern "C" __attribute__ ((visibility("default"))) void inithftools() { boost::python::detail::init_module("hftools", &init_module_hftools); } void init_module_hftools()
{
    using namespace boost::python;
    class_<CR::DataReader>("DataReader")
      //      .def("read",&hFileRead) -> This is defined in pycrtools.py, since it is templated
      .def("get",&hFileGetParameter)
      .def("set",&hFileSetParameter,return_internal_reference<>())
      .def("summary",&hFileSummary)
      ;
    /*
  class_<casa::Vector<HInteger> >("CasaIntVec")
    .def(vector_indexing_suite<casa::Vector<HInteger> >())
    ;
    */
  class_<std::vector<HInteger> >("IntVec")
    .def(vector_indexing_suite<std::vector<HInteger> >())
      /*.def("thiAdd",fptr_hiAdd_HComplexHComplex12)
	.def("thiAdd",fptr_hiAdd_HComplexHNumber12)
	.def("thiAdd",fptr_hiAdd_HComplexHInteger12)
	.def("thiAdd",fptr_hiAdd_HNumberHComplex12)
	.def("thiAdd",fptr_hiAdd_HNumberHNumber12)
	.def("thiAdd",fptr_hiAdd_HNumberHInteger12)
	.def("thiAdd",fptr_hiAdd_HIntegerHComplex12)
	.def("thiAdd",fptr_hiAdd_HIntegerHNumber12)
	.def("thiAdd",fptr_hiAdd_HIntegerHInteger12)
      */
      ;
    class_<std::vector<HNumber> >("FloatVec")
        .def(vector_indexing_suite<std::vector<HNumber> >())
      ;
    class_<std::vector<bool> >("BoolVec")
        .def(vector_indexing_suite<std::vector<bool> >())
      ;
    class_<std::vector<HComplex> >("ComplexVec")
        .def(vector_indexing_suite<std::vector<HComplex> >())
      ;
    class_<std::vector<HString> >("StringVec")
        .def(vector_indexing_suite<std::vector<HString> >())
      ;
    class_<hArray<HNumber> >("FloatAry")
      .def("setVector",&hArray<HNumber>::setVector,return_internal_reference<>())
      .def("Vector",&hArray<HNumber>::Vector,return_internal_reference<>())
      .def("getDimensions",&hArray<HNumber>::getDimensions)
      .def("setDimensions",&hArray<HNumber>::setDimensions1,return_internal_reference<>())
      .def("setDimensions",&hArray<HNumber>::setDimensions2,return_internal_reference<>())
      .def("setDimensions",&hArray<HNumber>::setDimensions3,return_internal_reference<>())
      .def("setDimensions",&hArray<HNumber>::setDimensions4,return_internal_reference<>())
      .def("setDimensions",&hArray<HNumber>::setDimensions5,return_internal_reference<>())
      //      .def("setDimensions",fptr_hArray_setDimensions_overloads_1,return_internal_reference<>())
      //.def("setDimensions",fptr_hArray_setDimensions_overloads_2,return_internal_reference<>())
      //      .def("setDimensions",&hArray<HNumber>::setDimensions,return_internal_reference<>(),hArray_setDimensions_overloads())
      .def("setSlice",&hArray<HNumber>::setSlice,return_internal_reference<>())
      .def("getNumberOfDimensions",&hArray<HNumber>::getNumberOfDimensions)
      .def("getBegin",&hArray<HNumber>::getBegin)
      .def("getEnd",&hArray<HNumber>::getEnd)
      .def("getSize",&hArray<HNumber>::getSize)
      .def("iterate",&hArray<HNumber>::iterate)
      .def("__len__",&hArray<HNumber>::length)
      .def("setSize",&hArray<HNumber>::setSize,return_internal_reference<>())
      .def("loop",&hArray<HNumber>::loop,return_internal_reference<>())
      .def("noloop",&hArray<HNumber>::noloop,return_internal_reference<>())
      .def("next",&hArray<HNumber>::next,return_internal_reference<>())
      .def("reset",&hArray<HNumber>::reset,return_internal_reference<>())
      ;
    //boost::python::converter::registry::insert(&extract_swig_wrapped_pointer, type_id<mglData>());
    // def("pytointptr",getPointerFromPythonObject);
    //def("getptr", PyGetPtr);
    def("hgetFiletype",hgetFiletype);
    def("hgetFileExtension",hgetFileExtension);
    enum_<DATATYPE>("TYPE")
      .value("POINTER",POINTER)
      .value("INTEGER",INTEGER)
      .value("NUMBER", NUMBER)
      .value("COMPLEX",COMPLEX)
      .value("STRING",STRING)
      .value("BOOLEAN",BOOLEAN)
      .value("UNDEF",UNDEF);
    enum_<hWEIGHTS>("hWEIGHTS")
      .value("FLAT",WEIGHTS_FLAT)
      .value("LINEAR",WEIGHTS_LINEAR)
      .value("GAUSSIAN", WEIGHTS_GAUSSIAN);
    enum_<CR::CoordinateType::Types>("CoordinateTypes")
      //! Azimuth-Elevation-Height, \f$ \vec x = (Az,El,H) \f$
      .value("AzElHeight",CR::CoordinateType::AzElHeight)
      //! Azimuth-Elevation-Radius, \f$ \vec x = (Az,El,R) \f$
      .value("AzElRadius",CR::CoordinateType::AzElRadius)
      //! Cartesian coordinates, \f$ \vec x = (x,y,z) \f$
      .value("Cartesian",CR::CoordinateType::Cartesian)
      //! Cylindrical coordinates, \f$ \vec x = (r,\phi,h) \f$
      .value("Cylindrical",CR::CoordinateType::Cylindrical)
      //! Direction on the sky, \f$ \vec x = (Lon,Lat) \f$
      .value("Direction",CR::CoordinateType::Direction)
      //! Direction on the sky with radial distance, \f$ \vec x = (Lon,Lat,R) \f$
      .value("DirectionRadius",CR::CoordinateType::DirectionRadius)
      //! Frquency
      .value("Frequency",CR::CoordinateType::Frequency)
      //! Longitude-Latitude-Radius
      .value("LongLatRadius",CR::CoordinateType::LongLatRadius)
      //! North-East-Height
      .value("NorthEastHeight",CR::CoordinateType::NorthEastHeight)
      //! Spherical coordinates, \f$ \vec x = (r,\phi,\theta) \f$
      .value("Spherical",CR::CoordinateType::Spherical)
      //! Time
      .value("Time",CR::CoordinateType::Time);
    //The following will include the automatically generated python wrappers
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hArray_intBegin",fptr_hArray_intBegin_STL_HInteger_HPyObjectPtr_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFill",fptr_hFill_STL_HString_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HString_11_STDIT );
def("hFill",fptr_hFill_STL_HBool_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HBool_11_STDIT );
def("hFill",fptr_hFill_STL_HComplex_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HComplex_11_STDIT );
def("hFill",fptr_hFill_STL_HNumber_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HNumber_11_STDIT );
def("hFill",fptr_hFill_STL_HInteger_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HInteger_11_STDIT );




def("hFill",fptr_hFill_hSLICED_STL_HString_11_STDIT );
def("hFill",fptr_hFill_hSLICED_STL_HBool_11_STDIT );
def("hFill",fptr_hFill_hSLICED_STL_HComplex_11_STDIT );
def("hFill",fptr_hFill_hSLICED_STL_HNumber_11_STDIT );
def("hFill",fptr_hFill_hSLICED_STL_HInteger_11_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hNew",fptr_hNew_STL_HString_1_STL );
def("hNew",fptr_hNew_STL_HBool_1_STL );
def("hNew",fptr_hNew_STL_HComplex_1_STL );
def("hNew",fptr_hNew_STL_HNumber_1_STL );
def("hNew",fptr_hNew_STL_HInteger_1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HString_1HInteger_STL );
def("hResize",fptr_hResize_STL_HBool_1HInteger_STL );
def("hResize",fptr_hResize_STL_HComplex_1HInteger_STL );
def("hResize",fptr_hResize_STL_HNumber_1HInteger_STL );
def("hResize",fptr_hResize_STL_HInteger_1HInteger_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HString_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HBool_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HComplex_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HNumber_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HInteger_1HInteger1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HStringHString_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHBool_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHComplex_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHNumber_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHInteger_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHString_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHBool_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHComplex_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHNumber_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHInteger_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHString_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHBool_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHComplex_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHNumber_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHInteger_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHString_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHBool_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHComplex_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHNumber_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHInteger_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHString_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHBool_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHComplex_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHNumber_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHInteger_12_STLSTL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HStringHString_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHBool_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHComplex_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHNumber_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHInteger_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHString_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHBool_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHComplex_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHNumber_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHInteger_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHString_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHBool_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHComplex_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHNumber_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHInteger_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHString_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHBool_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHComplex_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHNumber_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHInteger_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHString_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHBool_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHComplex_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHNumber_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHInteger_12_CASACASA );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers


def("hConvert",fptr_hConvert_STL_HComplexHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HComplexHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HComplexHInteger_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHInteger_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHInteger_12_STDITSTDIT );




def("hConvert",fptr_hConvert_hSLICED_STL_HComplexHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HComplexHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HComplexHInteger_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HNumberHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HNumberHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HNumberHInteger_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT );
def("hConvert",fptr_hConvert_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCopy",fptr_hCopy_STL_HComplex_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HComplex_11_STDITSTDIT );
def("hCopy",fptr_hCopy_STL_HNumber_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HNumber_11_STDITSTDIT );
def("hCopy",fptr_hCopy_STL_HInteger_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HInteger_11_STDITSTDIT );




def("hCopy",fptr_hCopy_hSLICED_STL_HComplex_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hSLICED_STL_HNumber_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hSLICED_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("square",fptr_square_STL_HComplex_1_ );
def("square",fptr_square_STL_HNumber_1_ );
def("square",fptr_square_STL_HInteger_1_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hPhase",fptr_hPhase_STL_HInteger_HNumberHNumber_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("funcGaussian",fptr_funcGaussian_STL_HInteger_HNumberHNumberHNumber_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hExp",fptr_hExp1_STL_HComplex_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HComplex_1_STDIT );
def("hExp",fptr_hExp1_STL_HNumber_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HNumber_1_STDIT );
def("hExp",fptr_hExp1_STL_HInteger_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HInteger_1_STDIT );




def("hExp",fptr_hExp_hSLICED1_STL_HComplex_1_STDIT );
def("hExp",fptr_hExp_hSLICED1_STL_HNumber_1_STDIT );
def("hExp",fptr_hExp_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hExp",fptr_hExp2_STL_HComplex_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HComplex_11_STDITSTDIT );
def("hExp",fptr_hExp2_STL_HNumber_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HNumber_11_STDITSTDIT );
def("hExp",fptr_hExp2_STL_HInteger_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HInteger_11_STDITSTDIT );




def("hExp",fptr_hExp_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hExp",fptr_hExp_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hExp",fptr_hExp_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog",fptr_hLog1_STL_HComplex_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HComplex_1_STDIT );
def("hLog",fptr_hLog1_STL_HNumber_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HNumber_1_STDIT );
def("hLog",fptr_hLog1_STL_HInteger_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HInteger_1_STDIT );




def("hLog",fptr_hLog_hSLICED1_STL_HComplex_1_STDIT );
def("hLog",fptr_hLog_hSLICED1_STL_HNumber_1_STDIT );
def("hLog",fptr_hLog_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog",fptr_hLog2_STL_HComplex_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HComplex_11_STDITSTDIT );
def("hLog",fptr_hLog2_STL_HNumber_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HNumber_11_STDITSTDIT );
def("hLog",fptr_hLog2_STL_HInteger_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HInteger_11_STDITSTDIT );




def("hLog",fptr_hLog_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hLog",fptr_hLog_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hLog",fptr_hLog_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog10",fptr_hLog101_STL_HComplex_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HComplex_1_STDIT );
def("hLog10",fptr_hLog101_STL_HNumber_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HNumber_1_STDIT );
def("hLog10",fptr_hLog101_STL_HInteger_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HInteger_1_STDIT );




def("hLog10",fptr_hLog10_hSLICED1_STL_HComplex_1_STDIT );
def("hLog10",fptr_hLog10_hSLICED1_STL_HNumber_1_STDIT );
def("hLog10",fptr_hLog10_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog10",fptr_hLog102_STL_HComplex_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HComplex_11_STDITSTDIT );
def("hLog10",fptr_hLog102_STL_HNumber_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HNumber_11_STDITSTDIT );
def("hLog10",fptr_hLog102_STL_HInteger_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HInteger_11_STDITSTDIT );




def("hLog10",fptr_hLog10_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hLog10",fptr_hLog10_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hLog10",fptr_hLog10_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSin",fptr_hSin1_STL_HComplex_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HComplex_1_STDIT );
def("hSin",fptr_hSin1_STL_HNumber_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HNumber_1_STDIT );
def("hSin",fptr_hSin1_STL_HInteger_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HInteger_1_STDIT );




def("hSin",fptr_hSin_hSLICED1_STL_HComplex_1_STDIT );
def("hSin",fptr_hSin_hSLICED1_STL_HNumber_1_STDIT );
def("hSin",fptr_hSin_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSin",fptr_hSin2_STL_HComplex_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HComplex_11_STDITSTDIT );
def("hSin",fptr_hSin2_STL_HNumber_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HNumber_11_STDITSTDIT );
def("hSin",fptr_hSin2_STL_HInteger_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HInteger_11_STDITSTDIT );




def("hSin",fptr_hSin_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hSin",fptr_hSin_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hSin",fptr_hSin_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSinh",fptr_hSinh1_STL_HComplex_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HComplex_1_STDIT );
def("hSinh",fptr_hSinh1_STL_HNumber_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HNumber_1_STDIT );
def("hSinh",fptr_hSinh1_STL_HInteger_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HInteger_1_STDIT );




def("hSinh",fptr_hSinh_hSLICED1_STL_HComplex_1_STDIT );
def("hSinh",fptr_hSinh_hSLICED1_STL_HNumber_1_STDIT );
def("hSinh",fptr_hSinh_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSinh",fptr_hSinh2_STL_HComplex_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HComplex_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_STL_HNumber_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HNumber_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_STL_HInteger_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HInteger_11_STDITSTDIT );




def("hSinh",fptr_hSinh_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hSinh",fptr_hSinh_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hSinh",fptr_hSinh_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSqrt",fptr_hSqrt1_STL_HComplex_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HComplex_1_STDIT );
def("hSqrt",fptr_hSqrt1_STL_HNumber_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HNumber_1_STDIT );
def("hSqrt",fptr_hSqrt1_STL_HInteger_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HInteger_1_STDIT );




def("hSqrt",fptr_hSqrt_hSLICED1_STL_HComplex_1_STDIT );
def("hSqrt",fptr_hSqrt_hSLICED1_STL_HNumber_1_STDIT );
def("hSqrt",fptr_hSqrt_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSqrt",fptr_hSqrt2_STL_HComplex_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HComplex_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_STL_HNumber_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HNumber_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_STL_HInteger_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HInteger_11_STDITSTDIT );




def("hSqrt",fptr_hSqrt_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSquare",fptr_hSquare1_STL_HComplex_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HComplex_1_STDIT );
def("hSquare",fptr_hSquare1_STL_HNumber_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HNumber_1_STDIT );
def("hSquare",fptr_hSquare1_STL_HInteger_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HInteger_1_STDIT );




def("hSquare",fptr_hSquare_hSLICED1_STL_HComplex_1_STDIT );
def("hSquare",fptr_hSquare_hSLICED1_STL_HNumber_1_STDIT );
def("hSquare",fptr_hSquare_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSquare",fptr_hSquare2_STL_HComplex_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HComplex_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_STL_HNumber_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HNumber_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_STL_HInteger_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HInteger_11_STDITSTDIT );




def("hSquare",fptr_hSquare_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hSquare",fptr_hSquare_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hSquare",fptr_hSquare_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTan",fptr_hTan1_STL_HComplex_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HComplex_1_STDIT );
def("hTan",fptr_hTan1_STL_HNumber_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HNumber_1_STDIT );
def("hTan",fptr_hTan1_STL_HInteger_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HInteger_1_STDIT );




def("hTan",fptr_hTan_hSLICED1_STL_HComplex_1_STDIT );
def("hTan",fptr_hTan_hSLICED1_STL_HNumber_1_STDIT );
def("hTan",fptr_hTan_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTan",fptr_hTan2_STL_HComplex_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HComplex_11_STDITSTDIT );
def("hTan",fptr_hTan2_STL_HNumber_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HNumber_11_STDITSTDIT );
def("hTan",fptr_hTan2_STL_HInteger_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HInteger_11_STDITSTDIT );




def("hTan",fptr_hTan_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hTan",fptr_hTan_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hTan",fptr_hTan_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTanh",fptr_hTanh1_STL_HComplex_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HComplex_1_STDIT );
def("hTanh",fptr_hTanh1_STL_HNumber_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HNumber_1_STDIT );
def("hTanh",fptr_hTanh1_STL_HInteger_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HInteger_1_STDIT );




def("hTanh",fptr_hTanh_hSLICED1_STL_HComplex_1_STDIT );
def("hTanh",fptr_hTanh_hSLICED1_STL_HNumber_1_STDIT );
def("hTanh",fptr_hTanh_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTanh",fptr_hTanh2_STL_HComplex_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HComplex_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_STL_HNumber_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HNumber_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_STL_HInteger_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HInteger_11_STDITSTDIT );




def("hTanh",fptr_hTanh_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hTanh",fptr_hTanh_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hTanh",fptr_hTanh_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAbs",fptr_hAbs1_STL_HComplex_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HComplex_1_STDIT );
def("hAbs",fptr_hAbs1_STL_HNumber_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HNumber_1_STDIT );
def("hAbs",fptr_hAbs1_STL_HInteger_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HInteger_1_STDIT );




def("hAbs",fptr_hAbs_hSLICED1_STL_HComplex_1_STDIT );
def("hAbs",fptr_hAbs_hSLICED1_STL_HNumber_1_STDIT );
def("hAbs",fptr_hAbs_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAbs",fptr_hAbs2_STL_HComplex_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HComplex_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_STL_HNumber_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HNumber_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_STL_HInteger_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HInteger_11_STDITSTDIT );




def("hAbs",fptr_hAbs_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hAbs",fptr_hAbs_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hAbs",fptr_hAbs_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCos",fptr_hCos1_STL_HComplex_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HComplex_1_STDIT );
def("hCos",fptr_hCos1_STL_HNumber_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HNumber_1_STDIT );
def("hCos",fptr_hCos1_STL_HInteger_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HInteger_1_STDIT );




def("hCos",fptr_hCos_hSLICED1_STL_HComplex_1_STDIT );
def("hCos",fptr_hCos_hSLICED1_STL_HNumber_1_STDIT );
def("hCos",fptr_hCos_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCos",fptr_hCos2_STL_HComplex_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HComplex_11_STDITSTDIT );
def("hCos",fptr_hCos2_STL_HNumber_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HNumber_11_STDITSTDIT );
def("hCos",fptr_hCos2_STL_HInteger_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HInteger_11_STDITSTDIT );




def("hCos",fptr_hCos_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hCos",fptr_hCos_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hCos",fptr_hCos_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCosh",fptr_hCosh1_STL_HComplex_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HComplex_1_STDIT );
def("hCosh",fptr_hCosh1_STL_HNumber_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HNumber_1_STDIT );
def("hCosh",fptr_hCosh1_STL_HInteger_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HInteger_1_STDIT );




def("hCosh",fptr_hCosh_hSLICED1_STL_HComplex_1_STDIT );
def("hCosh",fptr_hCosh_hSLICED1_STL_HNumber_1_STDIT );
def("hCosh",fptr_hCosh_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCosh",fptr_hCosh2_STL_HComplex_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HComplex_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_STL_HNumber_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HNumber_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_STL_HInteger_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HInteger_11_STDITSTDIT );




def("hCosh",fptr_hCosh_hSLICED2_STL_HComplex_11_STDITSTDIT );
def("hCosh",fptr_hCosh_hSLICED2_STL_HNumber_11_STDITSTDIT );
def("hCosh",fptr_hCosh_hSLICED2_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCeil",fptr_hCeil1_STL_HNumber_1_STDIT );
def("hCeil",fptr_hCeil1_hARRAY_HNumber_1_STDIT );
def("hCeil",fptr_hCeil1_STL_HInteger_1_STDIT );
def("hCeil",fptr_hCeil1_hARRAY_HInteger_1_STDIT );




def("hCeil",fptr_hCeil_hSLICED1_STL_HNumber_1_STDIT );
def("hCeil",fptr_hCeil_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCeil",fptr_hCeil2_STL_HNumberHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HNumberHInteger_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HIntegerHInteger_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hCeil",fptr_hCeil_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT );
def("hCeil",fptr_hCeil_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hCeil",fptr_hCeil_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFloor",fptr_hFloor1_STL_HNumber_1_STDIT );
def("hFloor",fptr_hFloor1_hARRAY_HNumber_1_STDIT );
def("hFloor",fptr_hFloor1_STL_HInteger_1_STDIT );
def("hFloor",fptr_hFloor1_hARRAY_HInteger_1_STDIT );




def("hFloor",fptr_hFloor_hSLICED1_STL_HNumber_1_STDIT );
def("hFloor",fptr_hFloor_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFloor",fptr_hFloor2_STL_HNumberHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HNumberHInteger_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HIntegerHInteger_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hFloor",fptr_hFloor_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT );
def("hFloor",fptr_hFloor_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hFloor",fptr_hFloor_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAcos",fptr_hAcos1_STL_HNumber_1_STDIT );
def("hAcos",fptr_hAcos1_hARRAY_HNumber_1_STDIT );
def("hAcos",fptr_hAcos1_STL_HInteger_1_STDIT );
def("hAcos",fptr_hAcos1_hARRAY_HInteger_1_STDIT );




def("hAcos",fptr_hAcos_hSLICED1_STL_HNumber_1_STDIT );
def("hAcos",fptr_hAcos_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAcos",fptr_hAcos2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HIntegerHInteger_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hAcos",fptr_hAcos_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAcos",fptr_hAcos_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAcos",fptr_hAcos_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAsin",fptr_hAsin1_STL_HNumber_1_STDIT );
def("hAsin",fptr_hAsin1_hARRAY_HNumber_1_STDIT );
def("hAsin",fptr_hAsin1_STL_HInteger_1_STDIT );
def("hAsin",fptr_hAsin1_hARRAY_HInteger_1_STDIT );




def("hAsin",fptr_hAsin_hSLICED1_STL_HNumber_1_STDIT );
def("hAsin",fptr_hAsin_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAsin",fptr_hAsin2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HIntegerHInteger_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hAsin",fptr_hAsin_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAsin",fptr_hAsin_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAsin",fptr_hAsin_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAtan",fptr_hAtan1_STL_HNumber_1_STDIT );
def("hAtan",fptr_hAtan1_hARRAY_HNumber_1_STDIT );
def("hAtan",fptr_hAtan1_STL_HInteger_1_STDIT );
def("hAtan",fptr_hAtan1_hARRAY_HInteger_1_STDIT );




def("hAtan",fptr_hAtan_hSLICED1_STL_HNumber_1_STDIT );
def("hAtan",fptr_hAtan_hSLICED1_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAtan",fptr_hAtan2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HIntegerHInteger_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hAtan",fptr_hAtan_hSLICED2_STL_HNumberHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan_hSLICED2_STL_HNumberHInteger_12_STDITSTDIT );
def("hAtan",fptr_hAtan_hSLICED2_STL_HIntegerHNumber_12_STDITSTDIT );
def("hAtan",fptr_hAtan_hSLICED2_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiSub",fptr_hiSub_STL_HComplexHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HComplexHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HComplexHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HComplexHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HComplexHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HComplexHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HNumberHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HNumberHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HNumberHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HNumberHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HIntegerHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_STL_HIntegerHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hiSub",fptr_hiSub_hSLICED_STL_HComplexHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HComplexHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HComplexHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HNumberHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HNumberHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HNumberHInteger_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiSub",fptr_hiSub_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiSub",fptr_hiSub2_STL_HComplexHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HComplexHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HComplexHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HComplexHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HComplexHInteger_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HComplexHInteger_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HNumberHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HNumberHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HNumberHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HNumberHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HNumberHInteger_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HNumberHInteger_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HIntegerHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HIntegerHComplex_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HIntegerHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HIntegerHNumber_12_STDIT );
def("hiSub",fptr_hiSub2_STL_HIntegerHInteger_12_STDIT );
def("hiSub",fptr_hiSub2_hARRAY_HIntegerHInteger_12_STDIT );




def("hiSub",fptr_hiSub_hSLICED2_STL_HComplexHComplex_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HComplexHNumber_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HComplexHInteger_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HNumberHComplex_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HNumberHNumber_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HNumberHInteger_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HIntegerHComplex_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HIntegerHNumber_12_STDIT );
def("hiSub",fptr_hiSub_hSLICED2_STL_HIntegerHInteger_12_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSub",fptr_hSub_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hSub",fptr_hSub_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSubAdd",fptr_hSubAdd_STL_HComplex_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HComplex_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_STL_HNumber_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HNumber_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_STL_HInteger_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HInteger_111_STDITSTDITSTDIT );




def("hSubAdd",fptr_hSubAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSub",fptr_hSub2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hSub",fptr_hSub_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiMul",fptr_hiMul_STL_HComplexHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HComplexHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HComplexHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HComplexHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HComplexHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HComplexHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HNumberHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HNumberHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HNumberHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HNumberHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HIntegerHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_STL_HIntegerHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hiMul",fptr_hiMul_hSLICED_STL_HComplexHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HComplexHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HComplexHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HNumberHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HNumberHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HNumberHInteger_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiMul",fptr_hiMul_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiMul",fptr_hiMul2_STL_HComplexHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HComplexHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HComplexHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HComplexHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HComplexHInteger_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HComplexHInteger_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HNumberHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HNumberHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HNumberHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HNumberHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HNumberHInteger_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HNumberHInteger_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HIntegerHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HIntegerHComplex_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HIntegerHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HIntegerHNumber_12_STDIT );
def("hiMul",fptr_hiMul2_STL_HIntegerHInteger_12_STDIT );
def("hiMul",fptr_hiMul2_hARRAY_HIntegerHInteger_12_STDIT );




def("hiMul",fptr_hiMul_hSLICED2_STL_HComplexHComplex_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HComplexHNumber_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HComplexHInteger_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HNumberHComplex_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HNumberHNumber_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HNumberHInteger_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HIntegerHComplex_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HIntegerHNumber_12_STDIT );
def("hiMul",fptr_hiMul_hSLICED2_STL_HIntegerHInteger_12_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMul",fptr_hMul_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hMul",fptr_hMul_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMulAdd",fptr_hMulAdd_STL_HComplex_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HComplex_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_STL_HNumber_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HNumber_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_STL_HInteger_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HInteger_111_STDITSTDITSTDIT );




def("hMulAdd",fptr_hMulAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMul",fptr_hMul2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hMul",fptr_hMul_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiAdd",fptr_hiAdd_STL_HComplexHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HComplexHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HComplexHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HComplexHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HComplexHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HComplexHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HNumberHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HNumberHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HNumberHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HNumberHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HIntegerHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_STL_HIntegerHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hiAdd",fptr_hiAdd_hSLICED_STL_HComplexHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HComplexHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HComplexHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HNumberHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HNumberHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HNumberHInteger_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiAdd",fptr_hiAdd_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiAdd",fptr_hiAdd2_STL_HComplexHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HComplexHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HComplexHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HComplexHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HComplexHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HComplexHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HNumberHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HNumberHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HNumberHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HNumberHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HNumberHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HNumberHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HIntegerHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HIntegerHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HIntegerHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HIntegerHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd2_STL_HIntegerHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd2_hARRAY_HIntegerHInteger_12_STDIT );




def("hiAdd",fptr_hiAdd_hSLICED2_STL_HComplexHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HComplexHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HComplexHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HNumberHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HNumberHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HNumberHInteger_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HIntegerHComplex_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HIntegerHNumber_12_STDIT );
def("hiAdd",fptr_hiAdd_hSLICED2_STL_HIntegerHInteger_12_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAdd",fptr_hAdd_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAddAdd",fptr_hAddAdd_STL_HComplex_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HComplex_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_STL_HNumber_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HNumber_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_STL_HInteger_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HInteger_111_STDITSTDITSTDIT );




def("hAddAdd",fptr_hAddAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAdd",fptr_hAdd2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiDiv",fptr_hiDiv_STL_HComplexHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HComplexHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HComplexHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HComplexHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HComplexHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HComplexHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HNumberHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HNumberHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HNumberHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HNumberHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HNumberHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HNumberHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HIntegerHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HIntegerHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_STL_HIntegerHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hARRAY_HIntegerHInteger_12_STDITSTDIT );




def("hiDiv",fptr_hiDiv_hSLICED_STL_HComplexHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HComplexHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HComplexHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HNumberHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HNumberHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HNumberHInteger_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HIntegerHComplex_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HIntegerHNumber_12_STDITSTDIT );
def("hiDiv",fptr_hiDiv_hSLICED_STL_HIntegerHInteger_12_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hiDiv",fptr_hiDiv2_STL_HComplexHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HComplexHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HComplexHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HComplexHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HComplexHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HComplexHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HNumberHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HNumberHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HNumberHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HNumberHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HNumberHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HNumberHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HIntegerHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HIntegerHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HIntegerHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HIntegerHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv2_STL_HIntegerHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv2_hARRAY_HIntegerHInteger_12_STDIT );




def("hiDiv",fptr_hiDiv_hSLICED2_STL_HComplexHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HComplexHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HComplexHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HNumberHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HNumberHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HNumberHInteger_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HIntegerHComplex_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HIntegerHNumber_12_STDIT );
def("hiDiv",fptr_hiDiv_hSLICED2_STL_HIntegerHInteger_12_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDiv",fptr_hDiv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDivAdd",fptr_hDivAdd_STL_HComplex_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HComplex_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_STL_HNumber_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HNumber_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_STL_HInteger_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HInteger_111_STDITSTDITSTDIT );




def("hDivAdd",fptr_hDivAdd_hSLICED_STL_HComplex_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hSLICED_STL_HNumber_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hSLICED_STL_HInteger_111_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDiv",fptr_hDiv2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );




def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHInteger_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHComplex_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHNumber_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHInteger_123_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hConj",fptr_hConj_STL_HInteger_HComplex_STDIT );
def("hConj",fptr_hConj_hARRAY_HInteger_HComplex_STDIT );




def("hConj",fptr_hConj_hSLICED_STL_HInteger_HComplex_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCrossCorrelateComplex",fptr_hCrossCorrelateComplex_STL_HInteger_HComplexHComplex_STDITSTDIT );
def("hCrossCorrelateComplex",fptr_hCrossCorrelateComplex_hARRAY_HInteger_HComplexHComplex_STDITSTDIT );




def("hCrossCorrelateComplex",fptr_hCrossCorrelateComplex_hSLICED_STL_HInteger_HComplexHComplex_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hReal",fptr_hReal_STL_HInteger_HComplexHNumber_STDITSTDIT );
def("hReal",fptr_hReal_hARRAY_HInteger_HComplexHNumber_STDITSTDIT );




def("hReal",fptr_hReal_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hArg",fptr_hArg_STL_HInteger_HComplexHNumber_STDITSTDIT );
def("hArg",fptr_hArg_hARRAY_HInteger_HComplexHNumber_STDITSTDIT );




def("hArg",fptr_hArg_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hImag",fptr_hImag_STL_HInteger_HComplexHNumber_STDITSTDIT );
def("hImag",fptr_hImag_hARRAY_HInteger_HComplexHNumber_STDITSTDIT );




def("hImag",fptr_hImag_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNorm",fptr_hNorm_STL_HInteger_HComplexHNumber_STDITSTDIT );
def("hNorm",fptr_hNorm_hARRAY_HInteger_HComplexHNumber_STDITSTDIT );




def("hNorm",fptr_hNorm_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNegate",fptr_hNegate_STL_HComplex_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HComplex_1_STDIT );
def("hNegate",fptr_hNegate_STL_HNumber_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HNumber_1_STDIT );
def("hNegate",fptr_hNegate_STL_HInteger_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HInteger_1_STDIT );




def("hNegate",fptr_hNegate_hSLICED_STL_HComplex_1_STDIT );
def("hNegate",fptr_hNegate_hSLICED_STL_HNumber_1_STDIT );
def("hNegate",fptr_hNegate_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSum",fptr_hSum_STL_HComplex_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HComplex_1_STDIT );
def("hSum",fptr_hSum_STL_HNumber_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HNumber_1_STDIT );
def("hSum",fptr_hSum_STL_HInteger_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HInteger_1_STDIT );




def("hSum",fptr_hSum_hSLICED_STL_HComplex_1_STDIT );
def("hSum",fptr_hSum_hSLICED_STL_HNumber_1_STDIT );
def("hSum",fptr_hSum_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hProduct",fptr_hProduct_STL_HComplex_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HComplex_1_STDIT );
def("hProduct",fptr_hProduct_STL_HNumber_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HNumber_1_STDIT );
def("hProduct",fptr_hProduct_STL_HInteger_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HInteger_1_STDIT );




def("hProduct",fptr_hProduct_hSLICED_STL_HComplex_1_STDIT );
def("hProduct",fptr_hProduct_hSLICED_STL_HNumber_1_STDIT );
def("hProduct",fptr_hProduct_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNorm",fptr_hNorm_STL_HNumber_1_STDIT );
def("hNorm",fptr_hNorm_hARRAY_HNumber_1_STDIT );
def("hNorm",fptr_hNorm_STL_HInteger_1_STDIT );
def("hNorm",fptr_hNorm_hARRAY_HInteger_1_STDIT );




def("hNorm",fptr_hNorm_hSLICED_STL_HNumber_1_STDIT );
def("hNorm",fptr_hNorm_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNormalize",fptr_hNormalize_STL_HNumber_1_STDIT );
def("hNormalize",fptr_hNormalize_hARRAY_HNumber_1_STDIT );
def("hNormalize",fptr_hNormalize_STL_HInteger_1_STDIT );
def("hNormalize",fptr_hNormalize_hARRAY_HInteger_1_STDIT );




def("hNormalize",fptr_hNormalize_hSLICED_STL_HNumber_1_STDIT );
def("hNormalize",fptr_hNormalize_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMean",fptr_hMean_STL_HNumber_1_STDIT );
def("hMean",fptr_hMean_hARRAY_HNumber_1_STDIT );
def("hMean",fptr_hMean_STL_HInteger_1_STDIT );
def("hMean",fptr_hMean_hARRAY_HInteger_1_STDIT );




def("hMean",fptr_hMean_hSLICED_STL_HNumber_1_STDIT );
def("hMean",fptr_hMean_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSort",fptr_hSort_STL_HComplex_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HComplex_1_STDIT );
def("hSort",fptr_hSort_STL_HNumber_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HNumber_1_STDIT );
def("hSort",fptr_hSort_STL_HInteger_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HInteger_1_STDIT );




def("hSort",fptr_hSort_hSLICED_STL_HComplex_1_STDIT );
def("hSort",fptr_hSort_hSLICED_STL_HNumber_1_STDIT );
def("hSort",fptr_hSort_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSortMedian",fptr_hSortMedian_STL_HNumber_1_STDIT );
def("hSortMedian",fptr_hSortMedian_hARRAY_HNumber_1_STDIT );
def("hSortMedian",fptr_hSortMedian_STL_HInteger_1_STDIT );
def("hSortMedian",fptr_hSortMedian_hARRAY_HInteger_1_STDIT );




def("hSortMedian",fptr_hSortMedian_hSLICED_STL_HNumber_1_STDIT );
def("hSortMedian",fptr_hSortMedian_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hMedian",fptr_hMedian_STL_HNumber_1_STL );
def("hMedian",fptr_hMedian_STL_HInteger_1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hStdDev",fptr_hStdDev_STL_HNumber_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HNumber_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_STL_HInteger_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HInteger_1HNumber_STDIT );




def("hStdDev",fptr_hStdDev_hSLICED_STL_HNumber_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hSLICED_STL_HInteger_1HNumber_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hStdDev",fptr_hStdDev_STL_HNumber_1_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HNumber_1_STDIT );
def("hStdDev",fptr_hStdDev_STL_HInteger_1_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HInteger_1_STDIT );




def("hStdDev",fptr_hStdDev_hSLICED_STL_HNumber_1_STDIT );
def("hStdDev",fptr_hStdDev_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindLessEqual",fptr_hFindLessEqual_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindLessEqual",fptr_hFindLessEqual_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindGreaterThan",fptr_hFindGreaterThan_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindGreaterThan",fptr_hFindGreaterThan_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindGreaterEqual",fptr_hFindGreaterEqual_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindGreaterEqual",fptr_hFindGreaterEqual_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindLessThan",fptr_hFindLessThan_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindLessThan",fptr_hFindLessThan_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindLessThanAbs",fptr_hFindLessThanAbs_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAY_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_STL_HInteger_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAY_HInteger_11HInteger_STDITSTDIT );




def("hFindLessThanAbs",fptr_hFindLessThanAbs_hSLICED_STL_HNumber_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hSLICED_STL_HInteger_11HInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDownsample",fptr_hDownsample_STL_HNumber_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_hARRAY_HNumber_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_STL_HInteger_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_hARRAY_HInteger_11_STDITSTDIT );




def("hDownsample",fptr_hDownsample_hSLICED_STL_HNumber_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_hSLICED_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hDownsample",fptr_hDownsample_STL_HNumber_1HNumber_STL );
def("hDownsample",fptr_hDownsample_STL_HInteger_1HNumber_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFindLowerBound",fptr_hFindLowerBound_STL_HComplex_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HComplex_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_STL_HNumber_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HNumber_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_STL_HInteger_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HInteger_11_STDIT );




def("hFindLowerBound",fptr_hFindLowerBound_hSLICED_STL_HComplex_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hSLICED_STL_HNumber_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hSLICED_STL_HInteger_11_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFlatWeights",fptr_hFlatWeights_STL_HInteger_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hLinearWeights",fptr_hLinearWeights_STL_HInteger_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hGaussianWeights",fptr_hGaussianWeights_STL_HInteger_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hWeights",fptr_hWeights_STL_HInteger_HIntegerhWEIGHTS_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hRunningAverage",fptr_hRunningAverage_STL_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT );
def("hRunningAverage",fptr_hRunningAverage_hARRAY_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT );




def("hRunningAverage",fptr_hRunningAverage_hSLICED_STL_HInteger_HNumberHNumberHNumber_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hRunningAverage",fptr_hRunningAverage_STL_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );
def("hRunningAverage",fptr_hRunningAverage_hARRAY_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );




def("hRunningAverage",fptr_hRunningAverage_hSLICED_STL_HInteger_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGeometricDelayFarField",fptr_hGeometricDelayFarField_STL_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayFarField",fptr_hGeometricDelayFarField_hARRAY_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGeometricDelayNearField",fptr_hGeometricDelayNearField_STL_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayNearField",fptr_hGeometricDelayNearField_hARRAY_HInteger_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGeometricDelays",fptr_hGeometricDelays_STL_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT );
def("hGeometricDelays",fptr_hGeometricDelays_hARRAY_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT );




def("hGeometricDelays",fptr_hGeometricDelays_hSLICED_STL_HInteger_HNumberHNumberHNumberbool_STDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGeometricPhases",fptr_hGeometricPhases_STL_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );
def("hGeometricPhases",fptr_hGeometricPhases_hARRAY_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );




def("hGeometricPhases",fptr_hGeometricPhases_hSLICED_STL_HInteger_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGeometricWeights",fptr_hGeometricWeights_STL_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );
def("hGeometricWeights",fptr_hGeometricWeights_hARRAY_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );




def("hGeometricWeights",fptr_hGeometricWeights_hSLICED_STL_HInteger_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSpectralPower",fptr_hSpectralPower_STL_HInteger_HComplexHNumber_STDITSTDIT );
def("hSpectralPower",fptr_hSpectralPower_hARRAY_HInteger_HComplexHNumber_STDITSTDIT );




def("hSpectralPower",fptr_hSpectralPower_hSLICED_STL_HInteger_HComplexHNumber_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hADC2Voltage",fptr_hADC2Voltage_STL_HComplex_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HComplex_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_STL_HNumber_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HNumber_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_STL_HInteger_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HInteger_1HNumber_STDIT );




def("hADC2Voltage",fptr_hADC2Voltage_hSLICED_STL_HComplex_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hSLICED_STL_HNumber_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hSLICED_STL_HInteger_1HNumber_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_1HNumberuintuintuint_STDIT );




def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumberuintuintuint_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_1HNumberuint_STDIT );




def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumberuint_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_1HNumber_STDIT );




def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HComplex_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HNumber_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HInteger_1HNumber_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_1_STDIT );




def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HComplex_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HNumber_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hApplyFilter",fptr_hApplyFilter_STL_HComplex_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HComplex_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_STL_HNumber_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HNumber_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_STL_HInteger_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HInteger_11_STDITSTDIT );




def("hApplyFilter",fptr_hApplyFilter_hSLICED_STL_HComplex_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hSLICED_STL_HNumber_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hSLICED_STL_HInteger_11_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HComplex_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HComplex_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HNumber_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HNumber_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HInteger_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HInteger_1_STDIT );




def("hApplyHanningFilter",fptr_hApplyHanningFilter_hSLICED_STL_HComplex_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hSLICED_STL_HNumber_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hSLICED_STL_HInteger_1_STDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFFT",fptr_hFFT_STL_HInteger_HNumberHComplexHInteger_STDITSTDIT );
def("hFFT",fptr_hFFT_hARRAY_HInteger_HNumberHComplexHInteger_STDITSTDIT );




def("hFFT",fptr_hFFT_hSLICED_STL_HInteger_HNumberHComplexHInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hInvFFT",fptr_hInvFFT_STL_HInteger_HComplexHNumberHInteger_STDITSTDIT );
def("hInvFFT",fptr_hInvFFT_hARRAY_HInteger_HComplexHNumberHInteger_STDITSTDIT );




def("hInvFFT",fptr_hInvFFT_hSLICED_STL_HInteger_HComplexHNumberHInteger_STDITSTDIT );

//#if HFPP_FUNC_hARRAY
//HFPP_MAKE_WRAPPERS_hARRAY
//#endif
////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileSummary",fptr_hFileSummary_STL_HInteger_CRDataReader_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileOpen",fptr_hFileOpen_STL_HInteger_HString_ , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileGetParameter",fptr_hFileGetParameter_STL_HInteger_CRDataReaderHString_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileSetParameter",fptr_hFileSetParameter_STL_HInteger_CRDataReaderHStringHPyObjectPtr_ , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileRead",fptr_hFileRead_STL_HComplex_CRDataReaderHString1_STL , return_internal_reference<>());
def("hFileRead",fptr_hFileRead_STL_HNumber_CRDataReaderHString1_STL , return_internal_reference<>());
def("hFileRead",fptr_hFileRead_STL_HInteger_CRDataReaderHString1_STL , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hCalTable",fptr_hCalTable_STL_HInteger_HStringHStringHIntegerHPyObjectPtr_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCoordinateConvert",fptr_hCoordinateConvert_STL_HInteger_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED );
def("hCoordinateConvert",fptr_hCoordinateConvert_hARRAY_HInteger_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 17 22:18:43 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
//#define HFPP_PARDEF_8 (HInteger)(Offsets)()("Offsets per antenna")(HFPP_PAR_IS_VECTOR)(STL)(HFPP_PASS_AS_REFERENCE)
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//If function has no vectors don't make multiple PYthon wrappers for
//different vector classes
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hReadFileOld",fptr_hReadFileOld_STL_HComplex_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );
def("hReadFileOld",fptr_hReadFileOld_STL_HNumber_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );
def("hReadFileOld",fptr_hReadFileOld_STL_HInteger_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
}
