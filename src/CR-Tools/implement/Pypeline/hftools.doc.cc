//HFDOCSTART: Marks begin of file hftools.doc.cc which is being read by doxygen--------------
//HFDOCSTART: Marks begin of file hftools.doc.cc which is being read by doxygen--------------
/*!
 HFTOOLS Version 0.2 - Basic algorithms for the CR pipeline with
  automatic wrapper generation for python.  Includes various tools to
  manipulate stl vectors in python and wrapper function for CR Tool classes.

========================================================================
Here is a list of the available functions:
========================================================================

SECTION: Administrative Vector Function
--------------------------------------------------
hFill(vec, fill_value) - Fills a vector with a constant value.
 
hNew(vec)              - Make and return a new vector of the same size and 
                         type as the input vector.
 
hConvert(vec1, vec2)   - Copies and converts a vector to a vector of another 
                         type.
 
hCopy(vec, outvec)     - Copies a vector to another one.
 

SECTION: Math Function
--------------------------------------------------
square(val)            - Returns the squared value of the parameter.
 
hPhase(frequency, time) - Returns the interferometer phase in radians for a 
                         given frequency and time.
 
funcGaussian(x, sigma, mu) - Implementation of the Gauss function.
 
hExp(vec)              - Take the exp of all the elements in the vector.
 
hExp(vec, vecout)      - Take the exp of all the elements in the vector and 
                         return results in a second vector.
 
hLog(vec)              - Take the log of all the elements in the vector.
 
hLog(vec, vecout)      - Take the log of all the elements in the vector and 
                         return results in a second vector.
 
hLog10(vec)            - Take the log10 of all the elements in the vector.
 
hLog10(vec, vecout)    - Take the log10 of all the elements in the vector and 
                         return results in a second vector.
 
hSin(vec)              - Take the sin of all the elements in the vector.
 
hSin(vec, vecout)      - Take the sin of all the elements in the vector and 
                         return results in a second vector.
 
hSinh(vec)             - Take the sinh of all the elements in the vector.
 
hSinh(vec, vecout)     - Take the sinh of all the elements in the vector and 
                         return results in a second vector.
 
hSqrt(vec)             - Take the sqrt of all the elements in the vector.
 
hSqrt(vec, vecout)     - Take the sqrt of all the elements in the vector and 
                         return results in a second vector.
 
hSquare(vec)           - Take the square of all the elements in the vector.
 
hSquare(vec, vecout)   - Take the square of all the elements in the vector 
                         and return results in a second vector.
 
hTan(vec)              - Take the tan of all the elements in the vector.
 
hTan(vec, vecout)      - Take the tan of all the elements in the vector and 
                         return results in a second vector.
 
hTanh(vec)             - Take the tanh of all the elements in the vector.
 
hTanh(vec, vecout)     - Take the tanh of all the elements in the vector and 
                         return results in a second vector.
 
hAbs(vec)              - Take the abs of all the elements in the vector.
 
hAbs(vec, vecout)      - Take the abs of all the elements in the vector and 
                         return results in a second vector.
 
hCos(vec)              - Take the cos of all the elements in the vector.
 
hCos(vec, vecout)      - Take the cos of all the elements in the vector and 
                         return results in a second vector.
 
hCosh(vec)             - Take the cosh of all the elements in the vector.
 
hCosh(vec, vecout)     - Take the cosh of all the elements in the vector and 
                         return results in a second vector.
 
hCeil(vec)             - Take the ceil of all the elements in the vector.
 
hCeil(vec, vecout)     - Take the ceil of all the elements in the vector and 
                         return results in a second vector.
 
hFloor(vec)            - Take the floor of all the elements in the vector.
 
hFloor(vec, vecout)    - Take the floor of all the elements in the vector and 
                         return results in a second vector.
 
hAcos(vec)             - Take the acos of all the elements in the vector.
 
hAcos(vec, vecout)     - Take the acos of all the elements in the vector and 
                         return results in a second vector.
 
hAsin(vec)             - Take the asin of all the elements in the vector.
 
hAsin(vec, vecout)     - Take the asin of all the elements in the vector and 
                         return results in a second vector.
 
hAtan(vec)             - Take the atan of all the elements in the vector.
 
hAtan(vec, vecout)     - Take the atan of all the elements in the vector and 
                         return results in a second vector.
 
hSub(vec1, vec2)       - Performs a Sub between the two vectors, which is 
                         returned in the first vector. If the second vector 
                         is shorter it will be applied multiple times.
 
hSub(vec1, val)        - Performs a Sub between the vector and a scalar 
                         (applied to each element), which is returned in the 
                         first vector.
 
hSub(vec1, vec2, vec3) - Performs a Sub between the two vectors, which is 
                         returned in the third vector.
 
hSubAdd(vec1, vec2, vec3) - Performs a Sub between the two vectors, and adds 
                         the result to the output (third) vector.
 
hSubAddConv(vec1, vec2, vec3) - Performs a Sub between the two vectors, and 
                         adds the result to the output (third) vector - 
                         automatic casting is done.
 
hSub(vec1, val, vec2)  - Performs a Sub between the vector and a scalar, 
                         where the result is returned in the second vector.
 
hMul(vec1, vec2)       - Performs a Mul between the two vectors, which is 
                         returned in the first vector. If the second vector 
                         is shorter it will be applied multiple times.
 
hMul(vec1, val)        - Performs a Mul between the vector and a scalar 
                         (applied to each element), which is returned in the 
                         first vector.
 
hMul(vec1, vec2, vec3) - Performs a Mul between the two vectors, which is 
                         returned in the third vector.
 
hMulAdd(vec1, vec2, vec3) - Performs a Mul between the two vectors, and adds 
                         the result to the output (third) vector.
 
hMulAddConv(vec1, vec2, vec3) - Performs a Mul between the two vectors, and 
                         adds the result to the output (third) vector - 
                         automatic casting is done.
 
hMul(vec1, val, vec2)  - Performs a Mul between the vector and a scalar, 
                         where the result is returned in the second vector.
 
hAdd(vec1, vec2)       - Performs a Add between the two vectors, which is 
                         returned in the first vector. If the second vector 
                         is shorter it will be applied multiple times.
 
hAdd(vec1, val)        - Performs a Add between the vector and a scalar 
                         (applied to each element), which is returned in the 
                         first vector.
 
hAdd(vec1, vec2, vec3) - Performs a Add between the two vectors, which is 
                         returned in the third vector.
 
hAddAdd(vec1, vec2, vec3) - Performs a Add between the two vectors, and adds 
                         the result to the output (third) vector.
 
hAddAddConv(vec1, vec2, vec3) - Performs a Add between the two vectors, and 
                         adds the result to the output (third) vector - 
                         automatic casting is done.
 
hAdd(vec1, val, vec2)  - Performs a Add between the vector and a scalar, 
                         where the result is returned in the second vector.
 
hDiv(vec1, vec2)       - Performs a Div between the two vectors, which is 
                         returned in the first vector. If the second vector 
                         is shorter it will be applied multiple times.
 
hDiv(vec1, val)        - Performs a Div between the vector and a scalar 
                         (applied to each element), which is returned in the 
                         first vector.
 
hDiv(vec1, vec2, vec3) - Performs a Div between the two vectors, which is 
                         returned in the third vector.
 
hDivAdd(vec1, vec2, vec3) - Performs a Div between the two vectors, and adds 
                         the result to the output (third) vector.
 
hDivAddConv(vec1, vec2, vec3) - Performs a Div between the two vectors, and 
                         adds the result to the output (third) vector - 
                         automatic casting is done.
 
hDiv(vec1, val, vec2)  - Performs a Div between the vector and a scalar, 
                         where the result is returned in the second vector.
 
hConj(vec)             - Calculate the complex conjugate of all elements in 
                         the complex vector.
 
hCrossCorrelateComplex(vec1, vec2) - Multiplies the elements of the first 
                         vector with the complex conjugate of the elements in 
                         the second and returns the results in the first.
 
hReal(vec, vecout)     - Take the real of all the elements in the complex 
                         vector and return results in a float vector.
 
hArg(vec, vecout)      - Take the arg of all the elements in the complex 
                         vector and return results in a float vector.
 
hImag(vec, vecout)     - Take the imag of all the elements in the complex 
                         vector and return results in a float vector.
 
hNorm(vec, vecout)     - Take the norm of all the elements in the complex 
                         vector and return results in a float vector.
 
hNegate(vec)           - Multiplies each element in the vector with -1 in 
                         place, i.e. the input vector is also the output 
                         vector.
 
hSum(vec)              - Performs a sum over the values in a vector and 
                         returns the value.
 
hProduct(vec)          - Multiplies all elements in the vector with each 
                         other and return the result
 
hNorm(vec)             - Returns the lengths or norm of a vector (i.e. 
                         Sqrt(Sum_i(xi*+2))).
 
hNormalize(vec)        - Normalizes a vector to length unity.
 
hMean(vec)             - Returns the mean value of all elements in a vector.
 
hSort(vec)             - Sorts a vector in place.
 
hSortMedian(vec)       - Sorts a vector in place and returns the median value 
                         of the elements.
 
hMedian(vec)           - Returns the median value of the elements.
 
hStdDev(vec, mean)     - Calculates the standard deviation around a mean 
                         value.
 
hStdDev(vec)           - Calculates the standard deviation of a vector of 
                         values.
 
hFindLessEqual(vec, threshold, vecout) - Find the samples that are LessEqual 
                         a certain threshold value and returns the number of 
                         samples found and the positions of the samples in a 
                         second vector.
 
hFindLessEqualAbs(vec, threshold, vecout) - Find the samples whose absolute 
                         values are LessEqual a certain threshold value and 
                         returns the number of samples found and the 
                         positions of the samples in a second vector.
 
hFindGreaterThan(vec, threshold, vecout) - Find the samples that are 
                         GreaterThan a certain threshold value and returns 
                         the number of samples found and the positions of the 
                         samples in a second vector.
 
hFindGreaterThanAbs(vec, threshold, vecout) - Find the samples whose absolute 
                         values are GreaterThan a certain threshold value and 
                         returns the number of samples found and the 
                         positions of the samples in a second vector.
 
hFindGreaterEqual(vec, threshold, vecout) - Find the samples that are 
                         GreaterEqual a certain threshold value and returns 
                         the number of samples found and the positions of the 
                         samples in a second vector.
 
hFindGreaterEqualAbs(vec, threshold, vecout) - Find the samples whose 
                         absolute values are GreaterEqual a certain threshold 
                         value and returns the number of samples found and 
                         the positions of the samples in a second vector.
 
hFindLessThan(vec, threshold, vecout) - Find the samples that are LessThan a 
                         certain threshold value and returns the number of 
                         samples found and the positions of the samples in a 
                         second vector.
 
hFindLessThanAbs(vec, threshold, vecout) - Find the samples whose absolute 
                         values are LessThan a certain threshold value and 
                         returns the number of samples found and the 
                         positions of the samples in a second vector.
 
hDownsample(vec1, vec2) - Downsample the input vector to a smaller output 
                         vector.
 
hDownsample(vec, downsample_factor) - Downsample the input vector by a cetain 
                         factor and return a new vector.
 
hFindLowerBound(vec, value) - Finds the location (i.e., returns integer) in a 
                         monotonically increasing vector, where the input 
                         search value is just above or equal to the value in 
                         the vector.
 
hFlatWeights(wlen)     - Returns vector of weights of length len with 
                         constant weights normalized to give a sum of unity. 
                         Can be used by hRunningAverageT.
 
hLinearWeights(wlen)   - Returns vector of weights of length wlen with 
                         linearly rising and decreasing weights centered at 
                         len/2.
 
hGaussianWeights(wlen) - Returns vector of weights of length wlen with 
                         Gaussian distribution centered at len/2 and 
                         sigma=len/4 (i.e. the Gaussian extends over 2 sigma 
                         in both directions).
 
hWeights(wlen, wtype)  - Create a normalized weight vector.
 
hRunningAverage(idata, odata, weights) - Calculate the running average of an 
                         input vector using a weight vector.
 
hRunningAverage(idata, odata, wlen, wtype) - Overloaded function to 
                         automatically calculate weights.
 

SECTION: RF (Radio Frequency) Function
--------------------------------------------------
hGeometricDelayFarField(antPosition, skyDirection, length) - Calculates the 
                         time delay in seconds for a signal received at an 
                         antenna position relative to a phase center from a 
                         source located in a certain direction in farfield 
                         (based on L. Bahren).
 
hGeometricDelayNearField(antPosition, skyPosition, distance) - Calculates the 
                         time delay in seconds for a signal received at an 
                         antenna position relative to a phase center from a 
                         source located at a certain 3D space coordinate in 
                         nearfield (based on L. Bahren).
 
hGeometricDelays(antPositions, skyPositions, delays, farfield) - Calculates 
                         the time delay in seconds for signals received at 
                         various antenna positions relative to a phase center 
                         from sources located at certain 3D space coordinates 
                         in near or far field.
 
hGeometricPhases(frequencies, antPositions, skyPositions, phases, farfield) - 
                         Calculates the phase gradients for signals received 
                         at various antenna positions relative to a phase 
                         center from sources located at certain 3D space 
                         coordinates in near or far field and for different 
                         frequencies.
 
hGeometricWeights(frequencies, antPositions, skyPositions, weights, farfield) 
                         - Calculates the phase gradients as complex weights 
                         for signals received at various antenna positions 
                         relative to a phase center from sources located at 
                         certain 3D space coordinates in near or far field 
                         and for different frequencies.
 
hSpectralPower(vec, outvec) - Calculates the power of a complex spectrum and 
                         add it to an output vector.
 
hADC2Voltage(vec, adc2voltage) - Convert the ADC value to a voltage.
 
hGetHanningFilter(vec, Alpha, Beta, BetaRise, BetaFall) - Create a Hanning 
                         filter.
 
hGetHanningFilter(vec, Alpha, Beta) - Create a Hanning filter.
 
hGetHanningFilter(vec, Alpha) - Create a Hanning filter.
 
hGetHanningFilter(vec) - Create a Hanning filter.
 
hApplyFilter(data, filter) - Apply a predefined filter on a vector.
 
hApplyHanningFilter(data) - Apply a Hanning filter on a vector.
 
hFFT(data_in, data_out, nyquistZone) - Apply an FFT on a vector.
 
hInvFFT(data_in, data_out, nyquistZone) - Apply an Inverse FFT on a vector.
 

SECTION: I/O Function (DataReader)
--------------------------------------------------
hFileSummary(dr)       - Print a brief summary of the file contents and 
                         current settings.
 
hFileOpen(Filename)    - Function to open a file based on a filename and 
                         returning a datareader object.
 
hFileGetParameter(dr, keyword) - Return information from a data file as a 
                         Python object.
 
hFileSetParameter(dr, keyword, pyob) - Set parameters in a data file with a 
                         Python object as input.
 
hFileRead(dr, Datatype, vec) - Read data from a Datareader object (pointer in 
                         iptr) into a vector, where the size should be 
                         pre-allocated.
 
hCalTable(filename, keyword, date, pyob) - Return a list of antenna positions 
                         from the CalTables - this is a test.
 

SECTION: Coordinate Conversion (VectorConversion.cc)
--------------------------------------------------
hCoordinateConvert(source, sourceCoordinate, target, targetCoordinate, 
                         anglesInDegrees) - Converts a 3D spatial vector into 
                         a different Coordinate type (e.g. Spherical to 
                         Cartesian).
 
hReadFileOld(vec, iptr, Datatype, Antenna, Blocksize, Block, Stride, Shift) - 
                         Read data from a Datareader object (pointer in iptr) 
                         into a vector.
 

*/
//========================================================================
//                 Casting & Conversion Functions
//========================================================================
template<class T> T hfnull(){};
template<> inline HString hfnull<HString>(){HString null=""; return null;}
template<> inline HPointer hfnull<HPointer>(){return __null;}
template<> inline HInteger hfnull<HInteger>(){return 0;}
template<> inline HNumber hfnull<HNumber>(){return 0.0;}
template<> inline HComplex hfnull<HComplex>(){return 0.0;}
//Identity
template<class T> inline T hfcast(/*const*/ T v){return v;}
//Convert to arbitrary class T if not specified otherwise
template<class T> inline T hfcast(uint v){return static_cast<T>(v);}
template<class T> inline T hfcast(HInteger v){return static_cast<T>(v);}
template<class T> inline T hfcast(HNumber v){return static_cast<T>(v);}
template<class T> inline T hfcast(HComplex v){return static_cast<T>(v);}
//Convert Numbers to Numbers and loose information (round float, absolute of complex)
template<> inline HInteger hfcast<HInteger>(HNumber v){return static_cast<HInteger>(floor(v+0.5));}
template<> inline HInteger hfcast<HInteger>(HComplex v){return static_cast<HInteger>(floor(real(v)+0.5));}
template<> inline HNumber hfcast<HNumber>(HComplex v){return real(v);}
inline HInteger ptr2int(HPointer v){return reinterpret_cast<HInteger>(v);}
inline HPointer int2ptr(HInteger v){return reinterpret_cast<HPointer>(v);}
inline HComplex operator*(HInteger i, HComplex c) {return hfcast<HComplex>(i)*c;}
inline HComplex operator*(HComplex c, HInteger i) {return hfcast<HComplex>(i)*c;}
inline HComplex operator+(HInteger i, HComplex c) {return hfcast<HComplex>(i)+c;}
inline HComplex operator+(HComplex c, HInteger i) {return hfcast<HComplex>(i)+c;}
inline HComplex operator-(HInteger i, HComplex c) {return hfcast<HComplex>(i)-c;}
inline HComplex operator-(HComplex c, HInteger i) {return c-hfcast<HComplex>(i);}
inline HComplex operator/(HInteger i, HComplex c) {return hfcast<HComplex>(i)/c;}
inline HComplex operator/(HComplex c, HInteger i) {return c/hfcast<HComplex>(i);}
template <class T>
casa::Vector<T> stl2casa(std::vector<T>& stlvec)
{
  T * storage = &(stlvec[0]);
  casa::IPosition shape(1,stlvec.size()); //tell casa the size of the vector
  casa::Vector<T> casavec(shape,storage,casa::SHARE);
  return casavec;
}
vector<HNumber> PyList2STLFloatVec(PyObject* pyob){
  std::vector<HNumber> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyFloat_AsDouble(PyList_GetItem(pyob,i)));
  }
  return vec;
}
vector<HInteger> PyList2STLIntVec(PyObject* pyob){
  std::vector<HInteger> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyInt_AsLong(PyList_GetItem(pyob,i)));
  }
  return vec;
}
vector<uint> PyList2STLuIntVec(PyObject* pyob){
  std::vector<uint> vec;
  if (((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)){
    HInteger i,size=PyList_Size(pyob);
    vec.reserve(size);
    for (i=0;i<size;++i) vec.push_back(PyInt_AsLong(PyList_GetItem(pyob,i)));
  }
  return vec;
}
template <class S, class T>
void aipscol2stlvec(casa::Matrix<S> &data, std::vector<T>& stlvec, const HInteger col){
    HInteger i,nrow,ncol;
    nrow=data.nrow();
    ncol=data.ncolumn();
    //    if (ncol>1) {MSG("aipscol2stlvec: ncol="<<ncol <<" (nrow="<<nrow<<")");};
    if (col>=ncol) {
 ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 558 << ": " << "aipscol2stlvec: column number col=" << col << " is larger than total number of columns (" << ncol << ") in matrix." << endl );
 stlvec.clear();
 return;
    }
    stlvec.resize(nrow);
    casa::Vector<S> CASAVec = data.column(col);
//    p=stlvec.begin();
    for (i=0;i<nrow;i++) {
//	*p=hfcast<T>(CASAVec[i]);
 stlvec[i]=hfcast<T>(CASAVec[i]);
//	p++;
    };
}
/*!
  \brief The function converts an aips++ vector to an stl vector
 */
template <class S, class T>
void aipsvec2stlvec(casa::Vector<S>& data, std::vector<T>& stlvec){
    HInteger i,n;
//    std::vector<R>::iterator p;
    n=data.size();
    stlvec.resize(n);
//    p=stlvec.begin();
    for (i=0;i<n;i++) {
//	*p=hfcast<T>(data[i]);
 stlvec[i]=hfcast<T>(data[i]);
//	++p;
    };
}
//This function is copied from hfget.cc since I don't know a better
//way to do a proper instantiation of a templated function across two
//cpp files ..
template <class T, class S>
void copycast_vec(std::vector<T> &vi, std::vector<S> & vo) {
  typedef typename std::vector<T>::iterator Tit;
  typedef typename std::vector<S>::iterator Sit;
  Tit it1=vi.begin();
  Tit end=vi.end();
  if (it1==end) {vo.clear();}
  else {
    vo.assign(vi.size(),hfnull<S>()); //make the new vector equal in size and initialize with proper Null values
    Sit it2=vo.begin();
    while (it1!=end) {
      *it2=hfcast<S>(*it1);
      it1++; it2++;
    };
  };
}
//========================================================================
//                             Array Class 
//========================================================================
//! Testing a rudimentary Array class, that allows contiguous slicing
template <class T> void hArray<T>::init(){
  //  cout << "Creating hArray ptr=" << reinterpret_cast<void*>(this) << endl;
  storage_p = __null;
  slice_begin=0;
  slice_end=0;
  slice_size=0;
  array_is_shared=false;
  doiterate=false;
  loop_slice_begin=0; loop_slice_end=0; loop_slice_size=0;
  loop_i=0; loop_start=0; loop_end=0; loop_increment=1; loop_maxn=0;
  loop_next=false;
  loop_nslice=0;
  loop_over_indexvector=false;
}
template <class T> void hArray<T>::new_storage(){
  storage_p=new storage_container;
  storage_p->parent=this;
  storage_p->ndims_p=__null;
  storage_p->size_p=__null;
  storage_p->dimensions_p=__null;
  storage_p->slice_sizes_p=__null;
  storage_p->vec_p=__null;
  storage_p->vector_is_shared=false;
}
template <class T> void hArray<T>::initialize_storage(){
  if (storage_p==__null) new_storage();
  if (storage_p->ndims_p==__null) storage_p->ndims_p=new HInteger;
  if (storage_p->size_p==__null) storage_p->size_p=new HInteger;
  if (storage_p->dimensions_p==__null) storage_p->dimensions_p=new std::vector<HInteger>;
  if (storage_p->slice_sizes_p==__null) storage_p->slice_sizes_p=new std::vector<HInteger>;
  if (storage_p->vec_p==__null) storage_p->vec_p=new std::vector<T>;
}
template <class T> void hArray<T>::delete_storage(){
  if (!array_is_shared) {
    if (storage_p->ndims_p!=__null) {delete storage_p->ndims_p; storage_p->ndims_p=__null;}
    if (storage_p->size_p!=__null) {delete storage_p->dimensions_p; storage_p->dimensions_p=__null;}
    if (storage_p->dimensions_p!=__null) {delete storage_p->dimensions_p; storage_p->dimensions_p=__null;}
    if (storage_p->slice_sizes_p!=__null) {delete storage_p->slice_sizes_p; storage_p->slice_sizes_p=__null;}
    delVector();
    delete storage_p;
  }
  storage_p=__null;
}
template <class T> hArray<T>::hArray(){
  copycount=0;
  init();
  initialize_storage();
}
template <class T> hArray<T>::hArray(const std::vector<T> & vec){
  copycount=0;
  init();
  storage_p=new storage_container;
  setVector(vec);
  storage_p->vector_is_shared=true;
  initialize_storage();
}
/*!
\brief Creates a new array as a shared copy, i.e. it shares the data vector and dimensions of its parent.

*/
template <class T> hArray<T>::hArray(storage_container * sptr){
  if (sptr==__null) return;
  copycount=sptr->parent->copycount+1;
  init();
  storage_p=sptr;
  array_is_shared=true;
  initialize_storage();
  setSlice(0,storage_p->vec_p->size());
}
/*! \brief Returns a new hArray object, which shares the same vector and storage description (i.e. dimensions).

The storage will be deleted when the original object is deleted (not
when the shared copy is deleted) - even if the shared copied object is
still around.

 */
template <class T> hArray<T> & hArray<T>::shared_copy(){hArray<T> * ary_p=new hArray<T>(storage_p); return *ary_p;}
template <class T> void hArray<T>::delVector(){
  if (storage_p==__null) return; //Check if vector was deleted elsewhere
  if ((storage_p->vec_p != __null) && !storage_p->vector_is_shared) delete storage_p->vec_p;
  storage_p->vec_p=__null;
}
template <class T> hArray<T>::~hArray(){
  //  cout << "Deleting hArray ptr=" << reinterpret_cast<void*>(this) << endl;
  delete_storage();
}
/*
template <class T> hArray::storage_container * hArray<T>::getStorage(){
  return storage_p;
}
*/
/*!

\brief Set the vector to be stored (as reference, hence no copy is
made). Creation and destruction of this vector has to be done outside
this class!!
 
*/
template <class T> hArray<T> & hArray<T>::setVector(std::vector<T> & vec){
  delVector();
  initialize_storage();
  storage_p->vec_p=&vec;
  (*storage_p->size_p)=vec.size();
  setDimensions1((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  storage_p->vector_is_shared=true;
  return *this;
}
/*!
\brief Retrieve the stored vector (returned as reference, hence no copy is made).
 */
template <class T> std::vector<T> & hArray<T>::getVector(){
  if (storage_p==__null) { static vector<T> v; return v;} //Check if vector was deleted elsewhere
  return *(storage_p->vec_p);
}
/*!
\brief Retrieve the stored vector (returned as reference, hence no copy is made).
 */
template <class T> std::vector<HInteger> & hArray<T>::getDimensions(){
  if (storage_p==__null) {static vector<HInteger> v; return v;} //Check if vector was deleted elsewhere
  return *(storage_p->dimensions_p);
}
/*!
\brief Calculate the size of one slice in each dimension, will be called whenever dimensions change.
 */
template <class T> void hArray<T>::calcSizes(){
  if (storage_p==__null) return; //Check if vector was deleted elsewhere
  (*storage_p->slice_sizes_p).resize((*storage_p->dimensions_p).size());
  (*storage_p->slice_sizes_p)[(*storage_p->dimensions_p).size()-1]=1;
  for (int i=(*storage_p->dimensions_p).size()-1; i>0; --i) (*storage_p->slice_sizes_p)[i-1]=(*storage_p->slice_sizes_p)[i]*(*storage_p->dimensions_p)[i];
}
/*!
\brief Calculate the size of one slice in each dimension, will be called whenever dimensions change.
 */
template <class T> std::vector<HInteger> & hArray<T>::getSizes(){
  if (storage_p==__null) {static vector<HInteger> v; return v;} //Check if vector was deleted elsewhere
  return *(storage_p->slice_sizes_p);
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> void hArray<T>::setDimensions1(HInteger dim0){
  if (storage_p==__null) return ; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return ; //Check if vector was deleted elsewhere
  (*storage_p->ndims_p)=1;
  if ((*storage_p->dimensions_p).size()!=(uint)(*storage_p->ndims_p)) (*storage_p->dimensions_p).resize((*storage_p->ndims_p));
  (*storage_p->dimensions_p)[0]=dim0;
  (*storage_p->size_p)=hProduct<HInteger>((*storage_p->dimensions_p));
  if (storage_p->vec_p->size() != (uint)(*storage_p->size_p)) storage_p->vec_p->resize((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  calcSizes();
  return ;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> void hArray<T>::setDimensions2(HInteger dim0, HInteger dim1){
  if (storage_p==__null) return ; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return ; //Check if vector was deleted elsewhere
  (*storage_p->ndims_p)=2;
  if ((*storage_p->dimensions_p).size()!=(uint)(*storage_p->ndims_p)) (*storage_p->dimensions_p).resize((*storage_p->ndims_p));
  (*storage_p->dimensions_p)[0]=dim0;
  (*storage_p->dimensions_p)[1]=dim1;
  (*storage_p->size_p)=hProduct<HInteger>((*storage_p->dimensions_p));
  if ((uint)(*storage_p->size_p) != storage_p->vec_p->size()) storage_p->vec_p->resize((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  calcSizes();
  return ;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> void hArray<T>::setDimensions3(HInteger dim0, HInteger dim1, HInteger dim2){
  if (storage_p==__null) return ; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return ; //Check if vector was deleted elsewhere
  (*storage_p->ndims_p)=3;
  if ((*storage_p->dimensions_p).size()!=(uint)(*storage_p->ndims_p)) (*storage_p->dimensions_p).resize((*storage_p->ndims_p));
  (*storage_p->dimensions_p)[0]=dim0;
  (*storage_p->dimensions_p)[1]=dim1;
  (*storage_p->dimensions_p)[2]=dim2;
  (*storage_p->size_p)=hProduct<HInteger>((*storage_p->dimensions_p));
  if ((uint)(*storage_p->size_p) != storage_p->vec_p->size()) storage_p->vec_p->resize((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  calcSizes();
  return ;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> void hArray<T>::setDimensions4(HInteger dim0, HInteger dim1, HInteger dim2, HInteger dim3){
  if (storage_p==__null) return ; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return ; //Check if vector was deleted elsewhere
  (*storage_p->ndims_p)=4;
  if ((*storage_p->dimensions_p).size()!=(uint)(*storage_p->ndims_p)) (*storage_p->dimensions_p).resize((*storage_p->ndims_p));
  (*storage_p->dimensions_p)[0]=dim0;
  (*storage_p->dimensions_p)[1]=dim1;
  (*storage_p->dimensions_p)[2]=dim2;
  (*storage_p->dimensions_p)[3]=dim3;
  (*storage_p->size_p)=hProduct<HInteger>((*storage_p->dimensions_p));
  if ((uint)(*storage_p->size_p) != storage_p->vec_p->size()) storage_p->vec_p->resize((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  calcSizes();
  return ;
}
/*!
\brief Sets the dimensions of the array. Last index runs fastest, i.e., from left to right one goes from large to small chunks in memory.
 */
template <class T> void hArray<T>::setDimensions5(HInteger dim0, HInteger dim1, HInteger dim2, HInteger dim3, HInteger dim4){
  if (storage_p==__null) return ; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return ; //Check if vector was deleted elsewhere
  (*storage_p->ndims_p)=5;
  if ((*storage_p->dimensions_p).size()!=(uint)(*storage_p->ndims_p)) (*storage_p->dimensions_p).resize((*storage_p->ndims_p));
  (*storage_p->dimensions_p)[0]=dim0;
  (*storage_p->dimensions_p)[1]=dim1;
  (*storage_p->dimensions_p)[2]=dim2;
  (*storage_p->dimensions_p)[3]=dim3;
  (*storage_p->dimensions_p)[4]=dim4;
  (*storage_p->size_p)=hProduct<HInteger>((*storage_p->dimensions_p));
  if ((uint)(*storage_p->size_p) != storage_p->vec_p->size()) storage_p->vec_p->resize((*storage_p->size_p));
  setSlice(0,(*storage_p->size_p));
  calcSizes();
  return ;
}
/*!
\brief Sets begin and end the currently active slice using integer offsets from the begin of the stored vector. Use (0,size(vector)) to get the full vector
 */
template <class T> hArray<T> & hArray<T>::setSlice(HInteger beg, HInteger end){
  if (storage_p==__null) return *this; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return *this; //Check if vector was deleted elsewhere
  slice_begin=max(beg,0);
  if (end==-1) end=storage_p->vec_p->size();
  if (end>=0) slice_end=min(end,(*storage_p->size_p));
  else slice_end=(*storage_p->size_p);
  slice_size=slice_end-slice_begin;
  return *this;
}
/*!  \brief Sets begin and end of the currently active slice using an integer array of array indices.

If the length of the index vector is shorter than the actual number of
dimensions, this will provide a slice over the remanining dimensions
(belonging to the element indicated by the index vector)

 */
template <class T> hArray<T> & hArray<T>::setSliceVector(vector<HInteger> & index_vector, HInteger offset_start, HInteger offset_end){
  if (storage_p==__null) return *this; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return *this; //Check if vector was deleted elsewhere
  HInteger level=index_vector.size();
  if ((level > *storage_p->ndims_p) || (level < 0)) {( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 892 << ": " << "setSliceVector: Dimension wrong" << endl ); return *this;};
  offset_start=offset_start * (storage_p->slice_sizes_p->at(level));
  if (offset_end==-1) offset_end=storage_p->dimensions_p->at(level);
  offset_end=offset_end * (storage_p->slice_sizes_p->at(level));
  slice_begin=max(0,min(hMulSum(index_vector,*storage_p->slice_sizes_p)+offset_start,storage_p->vec_p->size()));
  slice_end=max(0,min(hMulSum(index_vector,*storage_p->slice_sizes_p)+offset_end,storage_p->vec_p->size()));
  //  slice_end=min(max(slice_begin+storage_p->slice_sizes_p->at(level-1),slice_begin),storage_p->vec_p->size());
  slice_size=slice_end-slice_begin;
  return *this;
}
/*!
\brief Returns the number of dimensions that have been associated with the current array
 */
template <class T> HInteger hArray<T>::getNumberOfDimensions(){
  if (storage_p==__null) return 0; //Check if vector was deleted elsewhere
  return (*storage_p->ndims_p);
}
/*!
\brief Returns the begin iterator of the current slice in the stored vector
 */
template <class T> typename std::vector<T>::iterator hArray<T>::begin(){
  return storage_p->vec_p->begin()+getBegin();
}
/*!
\brief Returns the end iterator of the current slice in the stored vector
 */
template <class T> typename std::vector<T>::iterator hArray<T>::end(){
  return storage_p->vec_p->begin()+getEnd();
}
/*!
\brief Returns the offset of the current slice from the begin iterator of the stored vector
 */
template <class T> HInteger hArray<T>::getBegin(){
  if (doiterate) return min(loop_slice_begin+loop_nslice*loop_slice_size,loop_slice_end);
  else return slice_begin;
}
/*!
\brief Returns the offset of the end of the current slice from the begin iterator of the stored vector
 */
template <class T> HInteger hArray<T>::getEnd(){
  if (doiterate) return min(loop_slice_begin+(loop_nslice+1)*loop_slice_size,loop_slice_end);
  else return slice_end;
}
/*!
\brief Returns the size (length) of the current slice
 */
template <class T> HInteger hArray<T>::getSize(){
  if (doiterate) return loop_slice_size;
  else return slice_size;
}
/*!
\brief Returns the length of the underlying vector
 */
template <class T> HInteger hArray<T>::length(){
  if (storage_p==__null) return 0; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return 0; //Check if vector was deleted elsewhere
  return storage_p->vec_p->size();
}
/*!  \brief Resizes the vector to the length given as input. If the
new size differs, then the vector will be resized and slices and
dimensions be reset to a flat (one dimensional) vector array.
 */
template <class T> hArray<T> & hArray<T>::resize(HInteger newsize){
  if (storage_p==__null) return *this; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return *this; //Check if vector was deleted elsewhere
  if (newsize==(HInteger)storage_p->vec_p->size()) return *this;
  storage_p->vec_p->resize(newsize);
  *storage_p->size_p=newsize;
  storage_p->dimensions_p->resize(1);
  storage_p->dimensions_p->at(0)=newsize;
  setSlice(0,newsize);
  calcSizes();
  return *this;
}
/*!
\brief Returns whether or not to iterate over all slices in the vector
 */
template <class T> bool hArray<T>::doLoopAgain(){return doiterate && loop_next;}
/*!
\brief Returns whether or not the  iterate over all slices in the vector
 */
template <class T> bool hArray<T>::loopingMode(){return doiterate;}
/*!  \brief Returns the current loop index (which may be different
from loop_nslice if one loops over an array of indices)
 */
template <class T> HInteger hArray<T>::getLoop_i(){return loop_i;}
/*!
\brief Returns the current loop start
 */
template <class T> HInteger hArray<T>::getLoop_start(){return loop_start;}
/*!
\brief Returns the current loop end
 */
template <class T> HInteger hArray<T>::getLoop_end(){return loop_end;}
/*!
\brief Returns the current loop index increment
 */
template <class T> HInteger hArray<T>::getLoop_increment(){return loop_increment;}
/*!  \brief Returns the number of the currently used slice in the loop
(which may be different from loop_i, if one loops over an array of
indices)
 */
template <class T> HInteger hArray<T>::getLoop_nslice(){return loop_nslice;}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector). 

 */
template <class T> hArray<T> & hArray<T>::loopOn(){
  loop_next=true;
  doiterate=true;
  return *this;
}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector). 

 */
template <class T> hArray<T> & hArray<T>::all(){setSlice(0,-1); return *this;}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector). 

\param "start_element_index" indicates the array element to start with. Looping
will be done over the next higher dimension.

\param start (starting at 0), end, increment indicate over how
many slices the iteration should proceed.

 */
template <class T> hArray<T> & hArray<T>::loop(vector<HInteger> & start_element_index, HInteger start, HInteger end, HInteger increment){
  if (storage_p==__null) return *this; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return *this; //Check if vector was deleted elsewhere
  HInteger level=setLoopSlice(start_element_index);
  if ( level <= -1 ) {( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 1041 << ": " << "loop: dimensions are wrong!" << endl ); return *this;};
  if (end<0) end=storage_p->dimensions_p->at(level);
  start=min(max(0,start),loop_maxn);
  end=min(max(start,end),loop_maxn);
  increment = max(increment,1);
  loopOn();
  loop_over_indexvector=false;
  loop_i=start; loop_start=start; loop_end=end; loop_increment=increment;
  loop_nslice = loop_i;
  return *this;
}
/*!
\brief Sets the array to looping mode (i.e. the next function will loop over all slices in the vector). 

The parameters start (statring at 0), end, increment indicate over how
many slices the iteration should proceed.

 */
template <class T> hArray<T> & hArray<T>::loopVector(vector<HInteger> & start_element_index, vector<HInteger> & vec){
  if (storage_p==__null) return *this; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return *this; //Check if vector was deleted elsewhere
  HInteger level=setLoopSlice(start_element_index);
  if ( level <= -1 ) {( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 1064 << ": " << "loopVector: dimensions are wrong!" << endl ); return *this;};
  loopOn();
  loop_over_indexvector=true;
  loop_i=0; loop_start=0; loop_end=vec.size(); loop_increment=1;
  index_vector=vec;
  loop_nslice=index_vector[loop_i];
  return *this;
}
/*!
\brief Sets the array to looping mode and resets the loop parameters to its start values

 */
template <class T> hArray<T> & hArray<T>::resetLoop(){
  loop_i=loop_start;
  if (loop_over_indexvector) loop_nslice=index_vector[loop_i];
  else loop_nslice = loop_i;
  loopOn();
  return *this;
}
/*!
\brief Sets the slice parameters used by the looping algorithm to calculate the currently worked on slice.

\param start_element_index: a vector of n indices which remain
constant during the looping. Looping will be done over the n+1st
index.

 */
template <class T> HInteger hArray<T>::setLoopSlice(vector<HInteger> & start_element_index){
  if (storage_p==__null) return -1; //Check if vector was deleted elsewhere
  if (storage_p->vec_p==__null) return -1; //Check if vector was deleted elsewhere
  HInteger level=start_element_index.size();
  if (level >= *storage_p->ndims_p) {( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 1099 << ": " << "setLoopSlice: dimensions are wrong!" << endl ); return -1;};
  loop_maxn = storage_p->dimensions_p->at(level);
  loop_slice_begin=hMulSum(start_element_index,*storage_p->slice_sizes_p); // multiplies the start element indices with the (cummulaitve) sizes of slices per dimension - giving the total offset
  loop_slice_size=storage_p->slice_sizes_p->at(level);
  loop_slice_end=loop_slice_begin+loop_slice_size*loop_maxn;
  return level;
}
/*!
\brief Switches the looping mode off (i.e. the next function will not loop over all slices in the vector)
 */
template <class T> hArray<T> & hArray<T>::loopOff(){doiterate=false; return *this;}
/*!
\brief Increase the current slice by one, if array is in looping mode. 

If the end of the vector is reached, switch looping mode off and reset array to first slice.
 */
template <class T> hArray<T> & hArray<T>::next(){
  if (!doiterate) return *this;
  if (loop_next==false) resetLoop(); // start all over again
  loop_i+=loop_increment;
  if (loop_i>=loop_end) { // the end is near, stop looping ...
    loop_next=false;
  } else {
    if (loop_over_indexvector) loop_nslice=index_vector[loop_i];
    else loop_nslice = loop_i;
    loop_nslice = min(loop_nslice,loop_maxn);
  };
  return *this;
}
    //      .def("setVector",&hArray<TYPE>::setVector,return_value_policy<manage_new_object>())     //      .def("getVector",&hArray<TYPE>::getVector,return_value_policy<manage_new_object>())     //  .def("shared_copy",&hArray<TYPE>::shared_copy,return_value_policy<manage_new_object>()) 
/*
    .def("getVector",&hArray<TYPE>::getVector,return_value_policy<manage_new_object>())     .def("shared_copy",&hArray<TYPE>::shared_copy,return_value_policy<manage_new_object>())     .def("getDimensions",&hArray<TYPE>::getDimensions,return_value_policy<manage_new_object>())     .def("getSizes",&hArray<TYPE>::getSizes,return_value_policy<manage_new_object>()) */
/*
return_internal_reference<1,
        with_custodian_and_ward<1, 2> >
*/
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return the offset of the current slice from the begin pointer

    \param pyob: Python hArray Object


Example:
antennaIDs=hFileGetParameter(file,"AntennaIDs")
x=hCalTable("~/LOFAR/usg/data/lopes/LOPES-CalTable",obsdate,list(antennaIDs))

*/
HInteger hArray_intBegin(HPyObjectPtr pyobj) {
//   if (!PyObject_HasAttrString(pyob, "ArrayType")) {
//     HPyObjectPtr objrepr=PyObject_Repr(pyobj);
//     char * objrepr_str= PyString_AsString(objrepr);
//     ERROR(BOOST_PP_STRINGIZE(HFPP_FUNC_NAME) << ": Object is not of hArray type;");
//     return 0;
//   }
//   HPyObjectPtr list=PyList_New(0),tuple;
//   if (CTRead != NULL && PyList_Check(pyob)) {  //Check if CalTable was opened ... and Python object is a list
//     size=PyList_Size(pyob);
//     for (i=0;i<size;++i){  //loop over all antennas
//       ant=PyInt_AsLong(PyList_GetItem(pyob,i));  //Get the ith element of the list, i.e. the antenna ID
//       CTRead->GetData((uint)date, ant, keyword, &tmpvec);
//       tuple=PyTuple_Pack(3,PyFloat_FromDouble(tmpvec[0]),PyFloat_FromDouble(tmpvec[1]),PyFloat_FromDouble(tmpvec[2]));
//       PyList_Append(list,tuple);
//     };
//   };
//   return list;
  return 0;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HInteger (*fptr_hArray_intBegin_STL_HInteger_pyob_HPyObjectPtr_)( HPyObjectPtr pyob) = &hArray_intBegin;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//                        Helper Functions
//========================================================================
/*!
\brief Determine the filetype based on the extension of the filename
 */
HString hgetFiletype(HString filename){
  HString ext=hgetFileExtension(filename);
  HString typ="";
  if (ext=="event") typ="LOPESEvent";
  else if (ext=="h5") typ="LOFAR_TBB";
  return typ;
}
/*!
\brief Get the extension of the filename, i.e. the text after the last dot.
 */
HString hgetFileExtension(HString filename){
  HInteger size=filename.size();
  HInteger pos=filename.rfind('.',size);
  pos++;
  if (pos>=size) {return "";}
  else {return filename.substr(pos,size-pos);};
}
//========================================================================
//$SECTION:           Administrative Vector Function
//========================================================================
//-----------------------------------------------------------------------
/*!
  hFill(vec,0) -> [0,0,0,...]
  vec.fill(0) -> [0,0,0,...]

  \brief Fills a vector with a constant value.

    \param vec: Vector to fill

    \param fill_value: Fill value

*/
template <class Iter>
void hFill(const Iter vec,const Iter vec_end, const typename Iter::value_type fill_value)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=fill_value;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hFill( std::vector<T> & vec , T fill_value) {
hFill ( vec.begin(),vec.end() , fill_value);
}

template < class T > inline void hFill( casa::Vector<T> & vec , T fill_value) {
hFill ( vec.cbegin(),vec.cend() , fill_value);
}

template < class T > inline void hFill( hArray<T> & vec , T fill_value) {
bool iterate=true;
while(iterate) {
hFill ( vec.begin(),vec.end() , fill_value);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hFill( hArray<T> & vec , vector<T> & fill_value) {
bool iterate=true;
vector< T >::iterator fill_value_iterator = fill_value.begin();
while(iterate) {
hFill ( vec.begin(),vec.end() , *fill_value_iterator);
vec.next();
fill_value_iterator++; if (fill_value.end()==fill_value_iterator) fill_value_iterator = fill_value.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hFill_STL_HString_vecfill_value_11_STDIT)( std::vector<HString> & vec , HString fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HString_vecfill_value_11_STDIT)( hArray<HString> & vec , HString fill_value) = &hFill;
void (*fptr_hFill_hARRAYALL_HString_vecfill_value_11_STDIT)( hArray<HString> & vec , vector<HString> & fill_value) = &hFill;
void (*fptr_hFill_STL_HBool_vecfill_value_11_STDIT)( std::vector<HBool> & vec , HBool fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HBool_vecfill_value_11_STDIT)( hArray<HBool> & vec , HBool fill_value) = &hFill;
void (*fptr_hFill_hARRAYALL_HBool_vecfill_value_11_STDIT)( hArray<HBool> & vec , vector<HBool> & fill_value) = &hFill;
void (*fptr_hFill_STL_HComplex_vecfill_value_11_STDIT)( std::vector<HComplex> & vec , HComplex fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HComplex_vecfill_value_11_STDIT)( hArray<HComplex> & vec , HComplex fill_value) = &hFill;
void (*fptr_hFill_hARRAYALL_HComplex_vecfill_value_11_STDIT)( hArray<HComplex> & vec , vector<HComplex> & fill_value) = &hFill;
void (*fptr_hFill_STL_HNumber_vecfill_value_11_STDIT)( std::vector<HNumber> & vec , HNumber fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HNumber_vecfill_value_11_STDIT)( hArray<HNumber> & vec , HNumber fill_value) = &hFill;
void (*fptr_hFill_hARRAYALL_HNumber_vecfill_value_11_STDIT)( hArray<HNumber> & vec , vector<HNumber> & fill_value) = &hFill;
void (*fptr_hFill_STL_HInteger_vecfill_value_11_STDIT)( std::vector<HInteger> & vec , HInteger fill_value) = &hFill;
void (*fptr_hFill_hARRAY_HInteger_vecfill_value_11_STDIT)( hArray<HInteger> & vec , HInteger fill_value) = &hFill;
void (*fptr_hFill_hARRAYALL_HInteger_vecfill_value_11_STDIT)( hArray<HInteger> & vec , vector<HInteger> & fill_value) = &hFill;

template < class T > inline void hFill_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T fill_value ) {
hFill ( vec.begin() + vecslice1,vec.begin() + vecslice2 , fill_value);
}

template < class T > inline void hFill_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T fill_value ) {
hFill ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , fill_value);
}


void (*fptr_hFill_hSLICED_STL_HString_vecfill_value_11_STDIT)( std::vector<HString> & vec , HInteger vecslice1 , HInteger vecslice2 , HString fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HBool_vecfill_value_11_STDIT)( std::vector<HBool> & vec , HInteger vecslice1 , HInteger vecslice2 , HBool fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HComplex_vecfill_value_11_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HComplex fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HNumber_vecfill_value_11_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber fill_value ) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HInteger_vecfill_value_11_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger fill_value ) = &hFill_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  hFill(vec,[0,1,2]) -> [0,1,2,0,1,2,...]
  vec.fill([0,1,2]) -> [0,1,2,0,1,2,...]

  \brief Fills a vector with the content of another vector.

    \param vec: Vector to fill

    \param fill_vec: Vector of values to fill it with


If fill_vec is shorther than vec, the procedure will wrap around and
start from the beginning of fill_vec again. Hence, in this case
fill_vec will appear repeated multiple times in vec.

*/
template <class Iter>
void hFill(const Iter vec,const Iter vec_end, const Iter fill_vec, const Iter fill_vec_end)
{
  Iter it1=vec;
  Iter it2=fill_vec;
  if (it2==vec_end) return;
  while (it1!=vec_end) {
    *it1=*it2;
    ++it1;++it2;
    if (it2==fill_vec_end) it2=fill_vec;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hFill( std::vector<T> & vec , std::vector<T> & fill_vec) {
hFill ( vec.begin(),vec.end() , fill_vec.begin(),fill_vec.end());
}

template < class T > inline void hFill( casa::Vector<T> & vec , casa::Vector<T> & fill_vec) {
hFill ( vec.cbegin(),vec.cend() , fill_vec.cbegin(),fill_vec.cend());
}

template < class T > inline void hFill( hArray<T> & vec , hArray<T> & fill_vec) {
bool iterate=true;
while(iterate) {
hFill ( vec.begin(),vec.end() , fill_vec.begin(),fill_vec.end());
vec.next();
fill_vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hFill_STL_HString_vecfill_vec_11_STDITSTDIT)( std::vector<HString> & vec , std::vector<HString> & fill_vec) = &hFill;
void (*fptr_hFill_hARRAY_HString_vecfill_vec_11_STDITSTDIT)( hArray<HString> & vec , hArray<HString> & fill_vec) = &hFill;
void (*fptr_hFill_STL_HBool_vecfill_vec_11_STDITSTDIT)( std::vector<HBool> & vec , std::vector<HBool> & fill_vec) = &hFill;
void (*fptr_hFill_hARRAY_HBool_vecfill_vec_11_STDITSTDIT)( hArray<HBool> & vec , hArray<HBool> & fill_vec) = &hFill;
void (*fptr_hFill_STL_HComplex_vecfill_vec_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & fill_vec) = &hFill;
void (*fptr_hFill_hARRAY_HComplex_vecfill_vec_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & fill_vec) = &hFill;
void (*fptr_hFill_STL_HNumber_vecfill_vec_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & fill_vec) = &hFill;
void (*fptr_hFill_hARRAY_HNumber_vecfill_vec_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & fill_vec) = &hFill;
void (*fptr_hFill_STL_HInteger_vecfill_vec_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & fill_vec) = &hFill;
void (*fptr_hFill_hARRAY_HInteger_vecfill_vec_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & fill_vec) = &hFill;

template < class T > inline void hFill_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) {
hFill ( vec.begin() + vecslice1,vec.begin() + vecslice2 , fill_vec.begin() + fill_vecslice1,fill_vec.begin() + fill_vecslice2);
}

template < class T > inline void hFill_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) {
hFill ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , fill_vec.cbegin() + fill_vecslice1,fill_vec.cbegin() + fill_vecslice2);
}


void (*fptr_hFill_hSLICED_STL_HString_vecfill_vec_11_STDITSTDIT)( std::vector<HString> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HString> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HBool_vecfill_vec_11_STDITSTDIT)( std::vector<HBool> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HBool> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HComplex_vecfill_vec_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HNumber_vecfill_vec_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) = &hFill_hSLICED;
void (*fptr_hFill_hSLICED_STL_HInteger_vecfill_vec_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & fill_vec , HInteger fill_vecslice1 , HInteger fill_vecslice2) = &hFill_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Make and return a new vector of the same size and type as the input vector.

    \param vec: Input vector

*/
template <class T>
std::vector<T> hNew(std::vector<T> & vec)
{
  std::vector<T> vnew(vec.size());
  return vnew;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HString> (*fptr_hNew_STL_HString_vec_1_STL)( std::vector<HString> & vec) = &hNew;
std::vector<HBool> (*fptr_hNew_STL_HBool_vec_1_STL)( std::vector<HBool> & vec) = &hNew;
std::vector<HComplex> (*fptr_hNew_STL_HComplex_vec_1_STL)( std::vector<HComplex> & vec) = &hNew;
std::vector<HNumber> (*fptr_hNew_STL_HNumber_vec_1_STL)( std::vector<HNumber> & vec) = &hNew;
std::vector<HInteger> (*fptr_hNew_STL_HInteger_vec_1_STL)( std::vector<HInteger> & vec) = &hNew;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a vector to a new length.

    \param vec: Input vector

    \param newsize: New size of vector

 */
template <class T>
void hResize(std::vector<T> & vec, HInteger newsize)
{
  vec.resize(newsize);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HString_vecnewsize_1HInteger_STL)( std::vector<HString> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HBool_vecnewsize_1HInteger_STL)( std::vector<HBool> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HComplex_vecnewsize_1HInteger_STL)( std::vector<HComplex> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HNumber_vecnewsize_1HInteger_STL)( std::vector<HNumber> & vec , HInteger newsize) = &hResize;
void (*fptr_hResize_STL_HInteger_vecnewsize_1HInteger_STL)( std::vector<HInteger> & vec , HInteger newsize) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a vector to a new length and fill new elements in vector with a specific value.

    \param vec: Input vector

    \param newsize: New size

    \param fill: Value to fill new vector elements with

*/
template <class T>
void hResize(std::vector<T> & vec, HInteger newsize, T fill)
{
  vec.resize(newsize,fill);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HString_vecnewsizefill_1HInteger1_STL)( std::vector<HString> & vec , HInteger newsize , HString fill) = &hResize;
void (*fptr_hResize_STL_HBool_vecnewsizefill_1HInteger1_STL)( std::vector<HBool> & vec , HInteger newsize , HBool fill) = &hResize;
void (*fptr_hResize_STL_HComplex_vecnewsizefill_1HInteger1_STL)( std::vector<HComplex> & vec , HInteger newsize , HComplex fill) = &hResize;
void (*fptr_hResize_STL_HNumber_vecnewsizefill_1HInteger1_STL)( std::vector<HNumber> & vec , HInteger newsize , HNumber fill) = &hResize;
void (*fptr_hResize_STL_HInteger_vecnewsizefill_1HInteger1_STL)( std::vector<HInteger> & vec , HInteger newsize , HInteger fill) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize an STL vector to the same length as a second vector.

    \param vec1: Input vector to be resized

    \param vec2: Reference vector

*/
template <class T, class S>
void hResize(std::vector<T> & vec1,std::vector<S> & vec2)
{
  vec1.resize(vec2.size());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HStringHString_vec1vec2_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHBool_vec1vec2_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHComplex_vec1vec2_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHNumber_vec1vec2_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHInteger_vec1vec2_12_STLSTL)( std::vector<HString> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHString_vec1vec2_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHBool_vec1vec2_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHComplex_vec1vec2_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHNumber_vec1vec2_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHInteger_vec1vec2_12_STLSTL)( std::vector<HBool> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHString_vec1vec2_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHBool_vec1vec2_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHComplex_vec1vec2_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHNumber_vec1vec2_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHInteger_vec1vec2_12_STLSTL)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHString_vec1vec2_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHBool_vec1vec2_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHComplex_vec1vec2_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHNumber_vec1vec2_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHInteger_vec1vec2_12_STLSTL)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHString_vec1vec2_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHBool_vec1vec2_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHComplex_vec1vec2_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHNumber_vec1vec2_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHInteger_vec1vec2_12_STLSTL)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*!
  \brief Resize a casa vector to the same length as a second vector.

    \param vec1: Input vector to be resized

    \param vec2: Reference vector

*/
template <class T, class S>
void hResize(casa::Vector<T> & vec1,casa::Vector<S> & vec2)
{
  vec1.resize(*(vec2.shape().begin()));
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hResize_STL_HStringHString_vec1vec2_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHBool_vec1vec2_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHComplex_vec1vec2_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHNumber_vec1vec2_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HStringHInteger_vec1vec2_12_CASACASA)( std::vector<HString> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHString_vec1vec2_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHBool_vec1vec2_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHComplex_vec1vec2_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHNumber_vec1vec2_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HBoolHInteger_vec1vec2_12_CASACASA)( std::vector<HBool> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHString_vec1vec2_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHBool_vec1vec2_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHComplex_vec1vec2_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHNumber_vec1vec2_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HComplexHInteger_vec1vec2_12_CASACASA)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHString_vec1vec2_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHBool_vec1vec2_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHComplex_vec1vec2_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHNumber_vec1vec2_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HNumberHInteger_vec1vec2_12_CASACASA)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHString_vec1vec2_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HString> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHBool_vec1vec2_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HBool> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHComplex_vec1vec2_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHNumber_vec1vec2_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hResize;
void (*fptr_hResize_STL_HIntegerHInteger_vec1vec2_12_CASACASA)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hResize;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Copies and converts a vector to a vector of another type.

    \param vec1: Numeric input vector

    \param vec2: Vector containing a copy of the input values converted to a new type

*/
template <class Iterin, class Iter>
void hConvert(const Iterin vec1,const Iterin vec1_end, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin it=vec1;
  Iter itout=vec2;
  while ((it!=vec1_end) && (itout !=vec2_end)) {
    *itout=hfcast<T>(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hConvert( std::vector<T> & vec1 , std::vector<S> & vec2) {
hResize(vec2,vec1); hConvert ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}


void (*fptr_hConvert_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hConvert;
void (*fptr_hConvert_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hConvert;

template < class T , class S > inline void hConvert_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hResize(vec2,vec1); hConvert ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hConvert_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hResize(vec2,vec1); hConvert ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hConvert_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;
void (*fptr_hConvert_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hConvert_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  vec1.copy(vec2) -> copy elements of vec1 to vec2

  \brief Copies a vector to another one without resizing them.

    \param vec: Input vector

    \param outvec: Vector containing a copy of the input values


  Use vec.resize first if you want to ensure that both vectors have the same size.
*/
template <class Iterin, class Iter>
void hCopy(const Iterin vec,const Iterin vec_end, const Iter out,const Iter out_end)
{
  typedef typename Iter::value_type T;
  Iterin it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=*it;
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCopy( std::vector<T> & vec , std::vector<T> & outvec) {
hCopy ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
}

template < class T > inline void hCopy( casa::Vector<T> & vec , casa::Vector<T> & outvec) {
hCopy ( vec.cbegin(),vec.cend() , outvec.cbegin(),outvec.cend());
}

template < class T > inline void hCopy( hArray<T> & vec , hArray<T> & outvec) {
bool iterate=true;
while(iterate) {
hCopy ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
vec.next();
outvec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCopy_STL_HComplex_vecoutvec_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HComplex_vecoutvec_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & outvec) = &hCopy;
void (*fptr_hCopy_STL_HNumber_vecoutvec_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HNumber_vecoutvec_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & outvec) = &hCopy;
void (*fptr_hCopy_STL_HInteger_vecoutvec_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & outvec) = &hCopy;
void (*fptr_hCopy_hARRAY_HInteger_vecoutvec_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & outvec) = &hCopy;

template < class T > inline void hCopy_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hCopy ( vec.begin() + vecslice1,vec.begin() + vecslice2 , outvec.begin() + outvecslice1,outvec.begin() + outvecslice2);
}

template < class T > inline void hCopy_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hCopy ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , outvec.cbegin() + outvecslice1,outvec.cbegin() + outvecslice2);
}


void (*fptr_hCopy_hSLICED_STL_HComplex_vecoutvec_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;
void (*fptr_hCopy_hSLICED_STL_HNumber_vecoutvec_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;
void (*fptr_hCopy_hSLICED_STL_HInteger_vecoutvec_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hCopy_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$SECTION:                 Math Function
//========================================================================
//------------------------------------------------------------------------
/*!
 \brief Returns the squared value of the parameter.

    \param val: Value to be squared

*/
template <class T>
inline T square(T val)
{
  return val*val;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HComplex (*fptr_square_STL_HComplex_val_1_)( HComplex val) = &square;
HNumber (*fptr_square_STL_HNumber_val_1_)( HNumber val) = &square;
HInteger (*fptr_square_STL_HInteger_val_1_)( HInteger val) = &square;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Returns the interferometer phase in radians for a given frequency and time.

    \param frequency: Frequency in Hz

    \param time: Time in seconds

*/
inline HNumber hPhase(HNumber frequency, HNumber time)
{
  return CR::_2pi*frequency*time;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_hPhase_STL_HInteger_frequencytime_HNumberHNumber_)( HNumber frequency , HNumber time) = &hPhase;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Implementation of the Gauss function.

    \param x: Position at which the Gaussian is evaluated

    \param sigma: Width of the Gaussian

    \param mu: Mean value of the Gaussian

*/
inline HNumber funcGaussian (HNumber x,
        HNumber sigma,
        HNumber mu)
{
  return exp(-(x-mu)*(x-mu)/(2*sigma*sigma))/(sigma*sqrt(2*casa::C::pi));
};
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_funcGaussian_STL_HInteger_xsigmamu_HNumberHNumberHNumber_)( HNumber x , HNumber sigma , HNumber mu) = &funcGaussian;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$ITERATE MFUNC abs,cos,cosh,exp,log,log10,sin,sinh,sqrt,square,tan,tanh
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the exp of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hExp1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=exp(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hExp( std::vector<T> & vec) {
hExp1 ( vec.begin(),vec.end());
}

template < class T > inline void hExp( casa::Vector<T> & vec) {
hExp1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hExp( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hExp1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hExp1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hExp;
void (*fptr_hExp1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hExp;
void (*fptr_hExp1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hExp;
void (*fptr_hExp1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hExp;

template < class T > inline void hExp_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hExp1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hExp_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hExp1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hExp_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hExp_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the exp of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hExp2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=exp(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hExp( std::vector<T> & vec , std::vector<T> & vecout) {
hExp2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hExp( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hExp2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hExp( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hExp2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hExp2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hExp;
void (*fptr_hExp2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hExp;
void (*fptr_hExp2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hExp;
void (*fptr_hExp2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hExp;

template < class T > inline void hExp_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hExp2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hExp_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hExp2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hExp_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;
void (*fptr_hExp_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hExp_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the log of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hLog1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=log(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog( std::vector<T> & vec) {
hLog1 ( vec.begin(),vec.end());
}

template < class T > inline void hLog( casa::Vector<T> & vec) {
hLog1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hLog( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hLog1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hLog1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hLog;
void (*fptr_hLog1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hLog;
void (*fptr_hLog1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hLog;
void (*fptr_hLog1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hLog;

template < class T > inline void hLog_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hLog_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hLog_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the log of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hLog2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=log(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog( std::vector<T> & vec , std::vector<T> & vecout) {
hLog2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hLog( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hLog2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hLog( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hLog2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hLog2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hLog;
void (*fptr_hLog2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hLog;
void (*fptr_hLog2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hLog;
void (*fptr_hLog2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hLog;

template < class T > inline void hLog_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hLog_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hLog_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;
void (*fptr_hLog_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the log10 of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hLog101(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=log10(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog10( std::vector<T> & vec) {
hLog101 ( vec.begin(),vec.end());
}

template < class T > inline void hLog10( casa::Vector<T> & vec) {
hLog101 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hLog10( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hLog101 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hLog101_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hLog10;
void (*fptr_hLog101_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hLog10;
void (*fptr_hLog101_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hLog10;
void (*fptr_hLog101_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hLog10;

template < class T > inline void hLog10_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog101 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hLog10_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hLog101 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hLog10_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hLog10_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the log10 of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hLog102(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=log10(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hLog10( std::vector<T> & vec , std::vector<T> & vecout) {
hLog102 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hLog10( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hLog102 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hLog10( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hLog102 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hLog102_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hLog10;
void (*fptr_hLog102_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hLog10;
void (*fptr_hLog102_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hLog10;
void (*fptr_hLog102_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hLog10;

template < class T > inline void hLog10_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog102 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hLog10_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hLog102 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hLog10_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;
void (*fptr_hLog10_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hLog10_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sin of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSin1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sin(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSin( std::vector<T> & vec) {
hSin1 ( vec.begin(),vec.end());
}

template < class T > inline void hSin( casa::Vector<T> & vec) {
hSin1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hSin( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSin1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSin1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSin;
void (*fptr_hSin1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSin;
void (*fptr_hSin1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSin;
void (*fptr_hSin1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSin;

template < class T > inline void hSin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSin1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSin1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSin_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSin_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sin of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSin2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sin(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSin( std::vector<T> & vec , std::vector<T> & vecout) {
hSin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSin( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSin2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hSin( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSin2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSin;
void (*fptr_hSin2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSin;
void (*fptr_hSin2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSin;
void (*fptr_hSin2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSin;

template < class T > inline void hSin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSin2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSin2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSin_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;
void (*fptr_hSin_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSin_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sinh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSinh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sinh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSinh( std::vector<T> & vec) {
hSinh1 ( vec.begin(),vec.end());
}

template < class T > inline void hSinh( casa::Vector<T> & vec) {
hSinh1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hSinh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSinh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSinh1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSinh;
void (*fptr_hSinh1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSinh;
void (*fptr_hSinh1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSinh;
void (*fptr_hSinh1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSinh;

template < class T > inline void hSinh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSinh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSinh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSinh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSinh_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSinh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sinh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSinh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sinh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSinh( std::vector<T> & vec , std::vector<T> & vecout) {
hSinh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSinh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSinh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hSinh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSinh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSinh2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSinh;
void (*fptr_hSinh2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSinh;
void (*fptr_hSinh2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSinh;
void (*fptr_hSinh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSinh;

template < class T > inline void hSinh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSinh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSinh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSinh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSinh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;
void (*fptr_hSinh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSinh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the sqrt of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSqrt1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=sqrt(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSqrt( std::vector<T> & vec) {
hSqrt1 ( vec.begin(),vec.end());
}

template < class T > inline void hSqrt( casa::Vector<T> & vec) {
hSqrt1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hSqrt( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSqrt1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSqrt1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSqrt;
void (*fptr_hSqrt1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSqrt;
void (*fptr_hSqrt1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSqrt;
void (*fptr_hSqrt1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSqrt;

template < class T > inline void hSqrt_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSqrt1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSqrt_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSqrt1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSqrt_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSqrt_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the sqrt of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSqrt2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=sqrt(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSqrt( std::vector<T> & vec , std::vector<T> & vecout) {
hSqrt2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSqrt( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSqrt2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hSqrt( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSqrt2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSqrt2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSqrt;
void (*fptr_hSqrt2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSqrt;
void (*fptr_hSqrt2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSqrt;
void (*fptr_hSqrt2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSqrt;

template < class T > inline void hSqrt_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSqrt2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSqrt_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSqrt2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSqrt_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;
void (*fptr_hSqrt_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSqrt_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the square of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hSquare1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=square(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSquare( std::vector<T> & vec) {
hSquare1 ( vec.begin(),vec.end());
}

template < class T > inline void hSquare( casa::Vector<T> & vec) {
hSquare1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hSquare( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSquare1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSquare1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSquare;
void (*fptr_hSquare1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSquare;
void (*fptr_hSquare1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSquare;
void (*fptr_hSquare1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSquare;

template < class T > inline void hSquare_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSquare1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSquare_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSquare1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSquare_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSquare_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the square of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hSquare2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=square(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSquare( std::vector<T> & vec , std::vector<T> & vecout) {
hSquare2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hSquare( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hSquare2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hSquare( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hSquare2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSquare2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hSquare;
void (*fptr_hSquare2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hSquare;
void (*fptr_hSquare2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hSquare;
void (*fptr_hSquare2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hSquare;

template < class T > inline void hSquare_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSquare2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hSquare_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hSquare2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hSquare_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;
void (*fptr_hSquare_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hSquare_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the tan of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hTan1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=tan(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTan( std::vector<T> & vec) {
hTan1 ( vec.begin(),vec.end());
}

template < class T > inline void hTan( casa::Vector<T> & vec) {
hTan1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hTan( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hTan1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hTan1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hTan;
void (*fptr_hTan1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hTan;
void (*fptr_hTan1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hTan;
void (*fptr_hTan1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hTan;

template < class T > inline void hTan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTan1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hTan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTan1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hTan_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the tan of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hTan2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=tan(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTan( std::vector<T> & vec , std::vector<T> & vecout) {
hTan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hTan( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hTan2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hTan( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hTan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hTan2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hTan;
void (*fptr_hTan2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hTan;
void (*fptr_hTan2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hTan;
void (*fptr_hTan2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hTan;

template < class T > inline void hTan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTan2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hTan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTan2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hTan_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;
void (*fptr_hTan_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the tanh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hTanh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=tanh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTanh( std::vector<T> & vec) {
hTanh1 ( vec.begin(),vec.end());
}

template < class T > inline void hTanh( casa::Vector<T> & vec) {
hTanh1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hTanh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hTanh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hTanh1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hTanh;
void (*fptr_hTanh1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hTanh;
void (*fptr_hTanh1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hTanh;
void (*fptr_hTanh1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hTanh;

template < class T > inline void hTanh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTanh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hTanh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hTanh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hTanh_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hTanh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the tanh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hTanh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=tanh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hTanh( std::vector<T> & vec , std::vector<T> & vecout) {
hTanh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hTanh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hTanh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hTanh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hTanh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hTanh2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hTanh;
void (*fptr_hTanh2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hTanh;
void (*fptr_hTanh2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hTanh;
void (*fptr_hTanh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hTanh;

template < class T > inline void hTanh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTanh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hTanh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hTanh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hTanh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;
void (*fptr_hTanh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hTanh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the abs of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAbs1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=abs(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAbs( std::vector<T> & vec) {
hAbs1 ( vec.begin(),vec.end());
}

template < class T > inline void hAbs( casa::Vector<T> & vec) {
hAbs1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hAbs( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAbs1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAbs1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hAbs;
void (*fptr_hAbs1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hAbs;
void (*fptr_hAbs1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hAbs;
void (*fptr_hAbs1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hAbs;

template < class T > inline void hAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAbs1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAbs1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAbs_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the abs of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hAbs2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=abs(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAbs( std::vector<T> & vec , std::vector<T> & vecout) {
hAbs2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hAbs( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hAbs2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hAbs( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hAbs2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAbs2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hAbs;
void (*fptr_hAbs2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAbs;
void (*fptr_hAbs2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAbs;
void (*fptr_hAbs2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAbs;

template < class T > inline void hAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAbs2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAbs2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAbs_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;
void (*fptr_hAbs_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the cos of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCos1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=cos(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCos( std::vector<T> & vec) {
hCos1 ( vec.begin(),vec.end());
}

template < class T > inline void hCos( casa::Vector<T> & vec) {
hCos1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hCos( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCos1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCos1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hCos;
void (*fptr_hCos1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hCos;
void (*fptr_hCos1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hCos;
void (*fptr_hCos1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hCos;

template < class T > inline void hCos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCos1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCos1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCos_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCos_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the cos of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hCos2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=cos(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCos( std::vector<T> & vec , std::vector<T> & vecout) {
hCos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hCos( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hCos2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hCos( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hCos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCos2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hCos;
void (*fptr_hCos2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCos;
void (*fptr_hCos2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCos;
void (*fptr_hCos2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCos;

template < class T > inline void hCos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCos2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hCos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCos2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCos_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;
void (*fptr_hCos_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCos_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the cosh of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCosh1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=cosh(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCosh( std::vector<T> & vec) {
hCosh1 ( vec.begin(),vec.end());
}

template < class T > inline void hCosh( casa::Vector<T> & vec) {
hCosh1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hCosh( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCosh1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCosh1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hCosh;
void (*fptr_hCosh1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hCosh;
void (*fptr_hCosh1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hCosh;
void (*fptr_hCosh1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hCosh;

template < class T > inline void hCosh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCosh1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCosh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCosh1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCosh_hSLICED1_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCosh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the cosh of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter>
void hCosh2(const Iter vec,const Iter vec_end, const Iter out,const Iter out_end)
{
  Iter it=vec;
  Iter itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=cosh(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCosh( std::vector<T> & vec , std::vector<T> & vecout) {
hCosh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T > inline void hCosh( casa::Vector<T> & vec , casa::Vector<T> & vecout) {
hCosh2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T > inline void hCosh( hArray<T> & vec , hArray<T> & vecout) {
bool iterate=true;
while(iterate) {
hCosh2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCosh2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HComplex> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT)( hArray<HComplex> & vec , hArray<HComplex> & vecout) = &hCosh;
void (*fptr_hCosh2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCosh;
void (*fptr_hCosh2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCosh;
void (*fptr_hCosh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCosh;

template < class T > inline void hCosh_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCosh2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline void hCosh_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<T> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCosh2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCosh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HComplex> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;
void (*fptr_hCosh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCosh_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//========================================================================
//$ITERATE MFUNC acos,asin,atan,ceil,floor
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the ceil of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hCeil1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=ceil(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hCeil( std::vector<T> & vec) {
hCeil1 ( vec.begin(),vec.end());
}

template < class T > inline void hCeil( casa::Vector<T> & vec) {
hCeil1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hCeil( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hCeil1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCeil1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hCeil;
void (*fptr_hCeil1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hCeil;
void (*fptr_hCeil1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hCeil;
void (*fptr_hCeil1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hCeil;

template < class T > inline void hCeil_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCeil1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hCeil_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hCeil1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hCeil_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hCeil_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the ceil of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hCeil2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=ceil(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hCeil( std::vector<T> & vec , std::vector<S> & vecout) {
hCeil2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hCeil( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hCeil2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T , class S > inline void hCeil( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hCeil2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hCeil2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hCeil;
void (*fptr_hCeil2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hCeil;
void (*fptr_hCeil2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hCeil;

template < class T , class S > inline void hCeil_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCeil2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hCeil_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hCeil2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hCeil_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;
void (*fptr_hCeil_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hCeil_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the floor of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hFloor1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=floor(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hFloor( std::vector<T> & vec) {
hFloor1 ( vec.begin(),vec.end());
}

template < class T > inline void hFloor( casa::Vector<T> & vec) {
hFloor1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hFloor( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hFloor1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hFloor1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hFloor;
void (*fptr_hFloor1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hFloor;
void (*fptr_hFloor1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hFloor;
void (*fptr_hFloor1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hFloor;

template < class T > inline void hFloor_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hFloor1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hFloor_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hFloor1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hFloor_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hFloor_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the floor of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hFloor2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=floor(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hFloor( std::vector<T> & vec , std::vector<S> & vecout) {
hFloor2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hFloor( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hFloor2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T , class S > inline void hFloor( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hFloor2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hFloor2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hFloor;
void (*fptr_hFloor2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hFloor;
void (*fptr_hFloor2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hFloor;

template < class T , class S > inline void hFloor_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hFloor2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hFloor_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hFloor2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hFloor_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;
void (*fptr_hFloor_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFloor_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the acos of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAcos1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=acos(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAcos( std::vector<T> & vec) {
hAcos1 ( vec.begin(),vec.end());
}

template < class T > inline void hAcos( casa::Vector<T> & vec) {
hAcos1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hAcos( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAcos1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAcos1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hAcos;
void (*fptr_hAcos1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hAcos;
void (*fptr_hAcos1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hAcos;
void (*fptr_hAcos1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hAcos;

template < class T > inline void hAcos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAcos1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAcos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAcos1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAcos_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAcos_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the acos of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAcos2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=acos(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAcos( std::vector<T> & vec , std::vector<S> & vecout) {
hAcos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAcos( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAcos2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T , class S > inline void hAcos( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAcos2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAcos2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAcos;
void (*fptr_hAcos2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAcos;
void (*fptr_hAcos2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAcos;

template < class T , class S > inline void hAcos_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAcos2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAcos_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAcos2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAcos_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;
void (*fptr_hAcos_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAcos_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the asin of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAsin1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=asin(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAsin( std::vector<T> & vec) {
hAsin1 ( vec.begin(),vec.end());
}

template < class T > inline void hAsin( casa::Vector<T> & vec) {
hAsin1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hAsin( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAsin1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAsin1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hAsin;
void (*fptr_hAsin1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hAsin;
void (*fptr_hAsin1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hAsin;
void (*fptr_hAsin1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hAsin;

template < class T > inline void hAsin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAsin1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAsin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAsin1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAsin_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAsin_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the asin of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAsin2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=asin(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAsin( std::vector<T> & vec , std::vector<S> & vecout) {
hAsin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAsin( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAsin2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T , class S > inline void hAsin( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAsin2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAsin2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAsin;
void (*fptr_hAsin2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAsin;
void (*fptr_hAsin2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAsin;

template < class T , class S > inline void hAsin_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAsin2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAsin_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAsin2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAsin_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;
void (*fptr_hAsin_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAsin_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the atan of all the elements in the vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hAtan1(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=atan(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAtan( std::vector<T> & vec) {
hAtan1 ( vec.begin(),vec.end());
}

template < class T > inline void hAtan( casa::Vector<T> & vec) {
hAtan1 ( vec.cbegin(),vec.cend());
}

template < class T > inline void hAtan( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hAtan1 ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAtan1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hAtan;
void (*fptr_hAtan1_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hAtan;
void (*fptr_hAtan1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hAtan;
void (*fptr_hAtan1_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hAtan;

template < class T > inline void hAtan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAtan1 ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hAtan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hAtan1 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hAtan_hSLICED1_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED1_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hAtan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Take the atan of all the elements in the vector and return results in a second vector.

    \param vec: Numeric input vector

    \param vecout: Numeric output vector

*/
template <class Iter1,class Iter2>
void hAtan2(const Iter1 vec,const Iter1 vec_end, const Iter2 out,const Iter2 out_end)
{
  Iter1 it=vec;
  Iter2 itout=out;
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout=atan(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAtan( std::vector<T> & vec , std::vector<S> & vecout) {
hAtan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

template < class T , class S > inline void hAtan( casa::Vector<T> & vec , casa::Vector<S> & vecout) {
hAtan2 ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

template < class T , class S > inline void hAtan( hArray<T> & vec , hArray<S> & vecout) {
bool iterate=true;
while(iterate) {
hAtan2 ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hAtan2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , std::vector<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT)( hArray<HNumber> & vec , hArray<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HNumber> & vecout) = &hAtan;
void (*fptr_hAtan2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , std::vector<HInteger> & vecout) = &hAtan;
void (*fptr_hAtan2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT)( hArray<HInteger> & vec , hArray<HInteger> & vecout) = &hAtan;

template < class T , class S > inline void hAtan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAtan2 ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T , class S > inline void hAtan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<S> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hAtan2 ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hAtan_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;
void (*fptr_hAtan_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hAtan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//========================================================================
//$ITERATE MFUNC Mul,Add,Div,Sub
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hSub(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 -= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hSub( std::vector<T> & vec1 , std::vector<S> & vec2) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hSub( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hSub ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T , class S > inline void hSub( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSub_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hSub;

template < class T , class S > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hSub_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hSub2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it -= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hSub( std::vector<T> & vec1 , S val) {
hSub2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hSub( casa::Vector<T> & vec1 , S val) {
hSub2 ( vec1.cbegin(),vec1.cend() , val);
}

template < class T , class S > inline void hSub( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hSub2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S > inline void hSub( hArray<T> & vec1 , vector<S> & val) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hSub2 ( vec1.begin(),vec1.end() , *val_iterator);
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSub2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val) = &hSub;
void (*fptr_hSub2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val) = &hSub;
void (*fptr_hSub2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val) = &hSub;
void (*fptr_hSub2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val) = &hSub;

template < class T , class S > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hSub2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hSub2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hSub_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hSub_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hSub(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) - (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSub( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hSub( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hSub ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hSub( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hSub ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSub_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSub;
void (*fptr_hSub_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSub;
void (*fptr_hSub_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSub;

template < class T , class S , class U > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSub ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSub ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSub_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSub_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hSubAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) - (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSubAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hSubAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hSubAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hSubAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T > inline void hSubAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hSubAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSubAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAdd;
void (*fptr_hSubAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAdd;

template < class T > inline void hSubAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hSubAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSubAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;
void (*fptr_hSubAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;
void (*fptr_hSubAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hSubAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) - (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSubAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hSubAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hSubAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hSubAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hSubAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hSubAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSubAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hSubAddConv;
void (*fptr_hSubAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hSubAddConv;

template < class T , class S , class U > inline void hSubAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hSubAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hSubAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;
void (*fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hSubAddConv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Sub between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hSub2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) - val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hSub( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hSub2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hSub( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hSub2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}

template < class T , class S , class U > inline void hSub( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hSub2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S , class U > inline void hSub( hArray<T> & vec1 , vector<S> & val , hArray<U> & vec2) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hSub2 ( vec1.begin(),vec1.end() , val $$$2 , vec2.begin(),vec2.end());
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hSub2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hSub;
void (*fptr_hSub2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hSub;
void (*fptr_hSub2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hSub;

template < class T , class S , class U > inline void hSub_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hSub_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hSub2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;
void (*fptr_hSub_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hSub_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hMul(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 *= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hMul( std::vector<T> & vec1 , std::vector<S> & vec2) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hMul( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hMul ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T , class S > inline void hMul( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMul_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hMul;

template < class T , class S > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hMul_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hMul2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it *= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hMul( std::vector<T> & vec1 , S val) {
hMul2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hMul( casa::Vector<T> & vec1 , S val) {
hMul2 ( vec1.cbegin(),vec1.cend() , val);
}

template < class T , class S > inline void hMul( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hMul2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S > inline void hMul( hArray<T> & vec1 , vector<S> & val) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hMul2 ( vec1.begin(),vec1.end() , *val_iterator);
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMul2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val) = &hMul;
void (*fptr_hMul2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val) = &hMul;
void (*fptr_hMul2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val) = &hMul;
void (*fptr_hMul2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val) = &hMul;

template < class T , class S > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hMul2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hMul2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hMul_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hMul_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hMul(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) * (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMul( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hMul( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hMul ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hMul( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hMul ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMul_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMul;
void (*fptr_hMul_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMul;
void (*fptr_hMul_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMul;

template < class T , class S , class U > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMul ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMul ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMul_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMul_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hMulAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) * (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hMulAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hMulAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hMulAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hMulAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T > inline void hMulAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hMulAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMulAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAdd;
void (*fptr_hMulAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAdd;

template < class T > inline void hMulAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hMulAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMulAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;
void (*fptr_hMulAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;
void (*fptr_hMulAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hMulAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) * (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMulAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hMulAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hMulAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hMulAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hMulAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hMulAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMulAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hMulAddConv;
void (*fptr_hMulAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hMulAddConv;

template < class T , class S , class U > inline void hMulAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hMulAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hMulAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;
void (*fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hMulAddConv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Mul between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hMul2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) * val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hMul( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hMul2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hMul( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hMul2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}

template < class T , class S , class U > inline void hMul( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hMul2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S , class U > inline void hMul( hArray<T> & vec1 , vector<S> & val , hArray<U> & vec2) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hMul2 ( vec1.begin(),vec1.end() , val $$$2 , vec2.begin(),vec2.end());
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hMul2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hMul;
void (*fptr_hMul2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hMul;
void (*fptr_hMul2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hMul;

template < class T , class S , class U > inline void hMul_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hMul_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hMul2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;
void (*fptr_hMul_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMul_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hAdd(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 += hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAdd( std::vector<T> & vec1 , std::vector<S> & vec2) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hAdd( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T , class S > inline void hAdd( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAdd_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hAdd;

template < class T , class S > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hAdd_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hAdd2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it += val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hAdd( std::vector<T> & vec1 , S val) {
hAdd2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hAdd( casa::Vector<T> & vec1 , S val) {
hAdd2 ( vec1.cbegin(),vec1.cend() , val);
}

template < class T , class S > inline void hAdd( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hAdd2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S > inline void hAdd( hArray<T> & vec1 , vector<S> & val) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hAdd2 ( vec1.begin(),vec1.end() , *val_iterator);
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAdd2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val) = &hAdd;

template < class T , class S > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hAdd2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hAdd2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hAdd_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hAdd(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) + (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAdd( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hAdd( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hAdd( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAdd_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAdd;
void (*fptr_hAdd_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAdd;
void (*fptr_hAdd_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAdd;

template < class T , class S , class U > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hAddAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) + (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hAddAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hAddAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hAddAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hAddAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T > inline void hAddAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hAddAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAddAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAdd;
void (*fptr_hAddAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAdd;

template < class T > inline void hAddAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hAddAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAddAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;
void (*fptr_hAddAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;
void (*fptr_hAddAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hAddAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) + (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAddAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hAddAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hAddAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hAddAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hAddAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hAddAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAddAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hAddAddConv;
void (*fptr_hAddAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hAddAddConv;

template < class T , class S , class U > inline void hAddAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hAddAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hAddAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;
void (*fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hAddAddConv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Add between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hAdd2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) + val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hAdd( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hAdd2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hAdd( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hAdd2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}

template < class T , class S , class U > inline void hAdd( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hAdd2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S , class U > inline void hAdd( hArray<T> & vec1 , vector<S> & val , hArray<U> & vec2) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hAdd2 ( vec1.begin(),vec1.end() , val $$$2 , vec2.begin(),vec2.end());
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hAdd2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hAdd;
void (*fptr_hAdd2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hAdd;
void (*fptr_hAdd2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hAdd;

template < class T , class S , class U > inline void hAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hAdd2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;
void (*fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, which is returned in the first vector. If the second vector is shorter it will be applied multiple times.

    \param vec1: Numeric input and output vector

    \param vec2: Vector containing the second operands

*/
template <class Iter, class Iterin>
void hDiv(const Iter vec1,const Iter vec1_end, const Iterin vec2,const Iterin vec2_end)
{
  typedef typename Iter::value_type T;
  Iter it1=vec1;
  Iterin it2=vec2;
  while (it1!=vec1_end) {
    *it1 /= hfcast<T>(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hDiv( std::vector<T> & vec1 , std::vector<S> & vec2) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T , class S > inline void hDiv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2) {
hDiv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T , class S > inline void hDiv( hArray<T> & vec1 , hArray<S> & vec2) {
bool iterate=true;
while(iterate) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDiv_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hDiv;

template < class T , class S > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hDiv_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the vector and a scalar (applied to each element), which is returned in the first vector.

    \param vec1: Numeric input and output vector

    \param val: Value containing the second operand

*/
template <class Iter, class S>
void hDiv2(const Iter vec1,const Iter vec1_end, S val)
{
  typedef typename Iter::value_type T;
  Iter it=vec1;
  T val_t = hfcast<T>(val);
  while (it!=vec1_end) {
    *it /= val_t;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S > inline void hDiv( std::vector<T> & vec1 , S val) {
hDiv2 ( vec1.begin(),vec1.end() , val);
}

template < class T , class S > inline void hDiv( casa::Vector<T> & vec1 , S val) {
hDiv2 ( vec1.cbegin(),vec1.cend() , val);
}

template < class T , class S > inline void hDiv( hArray<T> & vec1 , S val) {
bool iterate=true;
while(iterate) {
hDiv2 ( vec1.begin(),vec1.end() , val);
vec1.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S > inline void hDiv( hArray<T> & vec1 , vector<S> & val) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hDiv2 ( vec1.begin(),vec1.end() , *val_iterator);
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDiv2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HComplex val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HNumber val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , HInteger val) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val) = &hDiv;

template < class T , class S > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hDiv2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val);
}

template < class T , class S > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val ) {
hDiv2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val);
}


void (*fptr_hDiv_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val ) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val ) = &hDiv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, which is returned in the third vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hDiv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout = hfcast<T>((*it1) / (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDiv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hDiv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hDiv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hDiv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hDiv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDiv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDiv;
void (*fptr_hDiv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDiv;
void (*fptr_hDiv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDiv;

template < class T , class S , class U > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDiv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDiv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDiv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, and adds the result to the output (third) vector.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iter>
void hDivAdd(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iter it1(vec1), it2(vec2), itout(vec3);
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += (*it1) / (*it2);
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hDivAdd( std::vector<T> & vec1 , std::vector<T> & vec2 , std::vector<T> & vec3) {
hDivAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T > inline void hDivAdd( casa::Vector<T> & vec1 , casa::Vector<T> & vec2 , casa::Vector<T> & vec3) {
hDivAdd ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T > inline void hDivAdd( hArray<T> & vec1 , hArray<T> & vec2 , hArray<T> & vec3) {
bool iterate=true;
while(iterate) {
hDivAdd ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDivAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAdd;
void (*fptr_hDivAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAdd;

template < class T > inline void hDivAdd_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAdd ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T > inline void hDivAdd_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<T> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAdd ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDivAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;
void (*fptr_hDivAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;
void (*fptr_hDivAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAdd_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the two vectors, and adds the result to the output (third) vector - automatic casting is done.

    \param vec1: Numeric input vector

    \param vec2: Vector containing the second operands

    \param vec3: Vector containing the results

*/
template <class Iterin1, class Iterin2, class Iter>
void hDivAddConv(const Iterin1 vec1,const Iterin1 vec1_end, const Iterin2 vec2,const Iterin2 vec2_end, const Iter vec3,const Iter vec3_end)
{
  typedef typename Iter::value_type T;
  Iterin1 it1=vec1;
  Iterin2 it2=vec2;
  Iter itout=vec3;
  while ((it1!=vec1_end) && (itout !=vec3_end)) {
    *itout += hfcast<T>((*it1) / (*it2));
    ++it1; ++it2; ++itout;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDivAddConv( std::vector<T> & vec1 , std::vector<S> & vec2 , std::vector<U> & vec3) {
hDivAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
}

template < class T , class S , class U > inline void hDivAddConv( casa::Vector<T> & vec1 , casa::Vector<S> & vec2 , casa::Vector<U> & vec3) {
hDivAddConv ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend() , vec3.cbegin(),vec3.cend());
}

template < class T , class S , class U > inline void hDivAddConv( hArray<T> & vec1 , hArray<S> & vec2 , hArray<U> & vec3) {
bool iterate=true;
while(iterate) {
hDivAddConv ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end() , vec3.begin(),vec3.end());
vec1.next();
vec2.next();
vec3.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDivAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HComplex> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HComplex> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HNumber> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HNumber> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HComplex> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HNumber> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2 , std::vector<HInteger> & vec3) = &hDivAddConv;
void (*fptr_hDivAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2 , hArray<HInteger> & vec3) = &hDivAddConv;

template < class T , class S , class U > inline void hDivAddConv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAddConv ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2 , vec3.begin() + vec3slice1,vec3.begin() + vec3slice2);
}

template < class T , class S , class U > inline void hDivAddConv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<S> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , casa::Vector<U> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) {
hDivAddConv ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2 , vec3.cbegin() + vec3slice1,vec3.cbegin() + vec3slice2);
}


void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HComplex> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HNumber> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;
void (*fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2 , std::vector<HInteger> & vec3 , HInteger vec3slice1 , HInteger vec3slice2) = &hDivAddConv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a Div between the vector and a scalar, where the result is returned in the second vector.

    \param vec1: Numeric input vector

    \param val: Value containing the second operand

    \param vec2: Vector containing the output

*/
template <class Iterin1, class S, class Iter>
void hDiv2(const Iterin1 vec1,const Iterin1 vec1_end, S val, const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  Iterin1 itin=vec1;
  Iter itout=vec2;
  T val_t=hfcast<T>(val);
  while ((itin!=vec1_end) && (itout !=vec2_end)) {
    *itout = hfcast<T>(*itin) / val_t;
    ++itin; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T , class S , class U > inline void hDiv( std::vector<T> & vec1 , S val , std::vector<U> & vec2) {
hDiv2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
}

template < class T , class S , class U > inline void hDiv( casa::Vector<T> & vec1 , S val , casa::Vector<U> & vec2) {
hDiv2 ( vec1.cbegin(),vec1.cend() , val , vec2.cbegin(),vec2.cend());
}

template < class T , class S , class U > inline void hDiv( hArray<T> & vec1 , S val , hArray<U> & vec2) {
bool iterate=true;
while(iterate) {
hDiv2 ( vec1.begin(),vec1.end() , val , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}

template < class T , class S , class U > inline void hDiv( hArray<T> & vec1 , vector<S> & val , hArray<U> & vec2) {
bool iterate=true;
vector< S >::iterator val_iterator = val.begin();
while(iterate) {
hDiv2 ( vec1.begin(),vec1.end() , val $$$2 , vec2.begin(),vec2.end());
vec1.next();
val_iterator++; if (val.end()==val_iterator) val_iterator = val.begin();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDiv2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HComplex> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HNumber> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HComplex val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HComplex val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HComplex> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HNumber val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HNumber val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HNumber> & val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HComplex> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HNumber> & vec2) = &hDiv;
void (*fptr_hDiv2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger val , std::vector<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , HInteger val , hArray<HInteger> & vec2) = &hDiv;
void (*fptr_hDiv2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( hArray<HInteger> & vec1 , vector<HInteger> & val , hArray<HInteger> & vec2) = &hDiv;

template < class T , class S , class U > inline void hDiv_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , std::vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv2 ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , val , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T , class S , class U > inline void hDiv_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , S val , casa::Vector<U> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDiv2 ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , val , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HComplex val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HNumber val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;
void (*fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , HInteger val , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDiv_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
////////////////////
//COMPLEX FUNCTIONS
///////////////////
//-----------------------------------------------------------------------
/*!
  \brief Calculate the complex conjugate of all elements in the complex vector.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hConj(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  while (it!=vec_end) {
    *it=conj(*it);
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hConj( std::vector<HComplex> & vec) {
hConj ( vec.begin(),vec.end());
}

inline void hConj( casa::Vector<HComplex> & vec) {
hConj ( vec.cbegin(),vec.cend());
}

inline void hConj( hArray<HComplex> & vec) {
bool iterate=true;
while(iterate) {
hConj ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hConj_STL_HInteger_vec_HComplex_STDIT)( std::vector<HComplex> & vec) = &hConj;
void (*fptr_hConj_hARRAY_HInteger_vec_HComplex_STDIT)( hArray<HComplex> & vec) = &hConj;

 inline void hConj_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) {
hConj ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

inline void hConj_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) {
hConj ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hConj_hSLICED_STL_HInteger_vec_HComplex_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hConj_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Multiplies the elements of the first vector with the complex conjugate of the elements in the second and returns the results in the first.

    \param vec1: Complex input and output vector

    \param vec2: Second complex vector


 If the second vector is shorter than the first one, the second vector
 will simply wrap around and begin from the start until the end of the
 first vector is reached. If the first vector is shorter, then the
 calculation will simply stop.

 Relation to Cross Correlation:
 ------------------------------
 If the complex input vectors are the Fourier transformed data of two
 (real) vector f1 & f2, then vec1*conj(vec2) will be the Fourier
 transform of the crosscorrelation between f1 and f2.

 Hence, in order to calculate a cross correlation between f1 & f2, first do
 f1.fft(vec1) and f2.fft(vec2), then vec1.crosscorrelatecomplex(vec2)
 and FFT back through vec1.invfft(floatvec).
*/
template <class Iter>
void hCrossCorrelateComplex(const Iter vec1,const Iter vec1_end, const Iter vec2,const Iter vec2_end)
{
  Iter it1=vec1;
  Iter it2=vec2;
  while (it1!=vec1_end) {
    *it1 *= conj(*it2);
    ++it1; ++it2;
    if (it2==vec2_end) it2=vec2;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hCrossCorrelateComplex( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) {
hCrossCorrelateComplex ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

inline void hCrossCorrelateComplex( casa::Vector<HComplex> & vec1 , casa::Vector<HComplex> & vec2) {
hCrossCorrelateComplex ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

inline void hCrossCorrelateComplex( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) {
bool iterate=true;
while(iterate) {
hCrossCorrelateComplex ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hCrossCorrelateComplex_STL_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hCrossCorrelateComplex;
void (*fptr_hCrossCorrelateComplex_hARRAY_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hCrossCorrelateComplex;

 inline void hCrossCorrelateComplex_hSLICED ( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hCrossCorrelateComplex ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

inline void hCrossCorrelateComplex_hSLICED ( casa::Vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hCrossCorrelateComplex ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hCrossCorrelateComplex_hSLICED_STL_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hCrossCorrelateComplex_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$ITERATE MFUNC arg,imag,norm,real
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the real of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hReal(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=real(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hReal( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hReal ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hReal( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hReal ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

inline void hReal( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hReal ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hReal_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hReal;
void (*fptr_hReal_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hReal;

 inline void hReal_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hReal ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hReal_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hReal ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hReal_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hReal_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the arg of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hArg(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=arg(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hArg( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hArg ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hArg( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hArg ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

inline void hArg( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hArg ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hArg_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hArg;
void (*fptr_hArg_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hArg;

 inline void hArg_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hArg ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hArg_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hArg ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hArg_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hArg_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the imag of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hImag(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=imag(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hImag( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hImag ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hImag( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hImag ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

inline void hImag( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hImag ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hImag_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hImag;
void (*fptr_hImag_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hImag;

 inline void hImag_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hImag ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hImag_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hImag ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hImag_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hImag_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Take the norm of all the elements in the complex vector and return results in a float vector.

    \param vec: Complex input vector

    \param vecout: Float output vector


The following functions are available for getting real values from
complex numbers:
  abs - absolute value of a complex number
  norm - magnitude of a complex number squared, i.e. c * conj(c)
  arg - phase angle of a complex number
  imag - imaginary part of a complex number
  real - real part of a complex number
*/
template <class Iter, class Iterout>
void hNorm(const Iter vec,const Iter vec_end, const Iterout vecout,const Iterout vecout_end)
{
  Iter it=vec;
  Iterout itout=vecout;
  while ((it!=vec_end) && (itout !=vecout_end)) {
    *itout=norm(*it);
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hNorm( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) {
hNorm ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
}

inline void hNorm( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & vecout) {
hNorm ( vec.cbegin(),vec.cend() , vecout.cbegin(),vecout.cend());
}

inline void hNorm( hArray<HComplex> & vec , hArray<HNumber> & vecout) {
bool iterate=true;
while(iterate) {
hNorm ( vec.begin(),vec.end() , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hNorm_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & vecout) = &hNorm;
void (*fptr_hNorm_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & vecout) = &hNorm;

 inline void hNorm_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hNorm ( vec.begin() + vecslice1,vec.begin() + vecslice2 , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

inline void hNorm_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
hNorm ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


void (*fptr_hNorm_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hNorm_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//-----------------------------------------------------------------------
/*!
  \brief Multiplies each element in the vector with -1 in place, i.e. the input vector is also the output vector.

    \param vec: Numeric input vector

*/
template <class Iter>
void hNegate(const Iter vec,const Iter vec_end)
{
  Iter it=vec;
  typename Iter::value_type fac = -1;
  while (it!=vec_end) {
    *it=(*it) * fac;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hNegate( std::vector<T> & vec) {
hNegate ( vec.begin(),vec.end());
}

template < class T > inline void hNegate( casa::Vector<T> & vec) {
hNegate ( vec.cbegin(),vec.cend());
}

template < class T > inline void hNegate( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hNegate ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hNegate_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hNegate;
void (*fptr_hNegate_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hNegate;
void (*fptr_hNegate_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hNegate;
void (*fptr_hNegate_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hNegate;

template < class T > inline void hNegate_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNegate ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hNegate_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNegate ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hNegate_hSLICED_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;
void (*fptr_hNegate_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;
void (*fptr_hNegate_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNegate_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Performs a sum over the values in a vector and returns the value.

    \param vec: Numeric input vector

*/
template <class Iter>
typename Iter::value_type hSum (const Iter vec,const Iter vec_end)
{
  typedef typename Iter::value_type T;
  T sum=hfnull<T>();
  Iter it=vec;
  while (it!=vec_end) {sum+=*it; ++it;};
  return sum;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hSum( std::vector<T> & vec) {
return hSum ( vec.begin(),vec.end());
}

template < class T > inline T hSum( casa::Vector<T> & vec) {
return hSum ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<T> hSum( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hSum ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HComplex (*fptr_hSum_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSum;
vector<HComplex > (*fptr_hSum_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSum;
HNumber (*fptr_hSum_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSum;
vector<HNumber > (*fptr_hSum_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSum;
HInteger (*fptr_hSum_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSum;
vector<HInteger > (*fptr_hSum_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSum;

template < class T > inline T hSum_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSum ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hSum_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSum ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HComplex (*fptr_hSum_hSLICED_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;
HNumber (*fptr_hSum_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;
HInteger (*fptr_hSum_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSum_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  hMulSum(Vector([a,b,c,...]),Vector([x,y,z,...]) -> a*x + b*y + c*z + ....

  \brief Piecewise multiplication of the elements in a vector and summing of the results

    \param vec1: Numeric input vector

    \param vec2: Numeric input vector

*/
template <class Iter>
typename Iter::value_type hMulSum (const Iter vec1,const Iter vec1_end,const Iter vec2,const Iter vec2_end)
{
  typedef typename Iter::value_type T;
  T sum=hfnull<T>();
  Iter it1=vec1,it2=vec2;
  while (it1!=vec1_end && it2!=vec2_end) {sum+=*it1 * *it2; ++it1; ++it2;};
  return sum;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hMulSum( std::vector<T> & vec1 , std::vector<T> & vec2) {
return hMulSum ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T > inline T hMulSum( casa::Vector<T> & vec1 , casa::Vector<T> & vec2) {
return hMulSum ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T > inline vector<T> hMulSum( hArray<T> & vec1 , hArray<T> & vec2) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hMulSum ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HComplex (*fptr_hMulSum_STL_HComplex_vec1vec2_11_STDITSTDIT)( std::vector<HComplex> & vec1 , std::vector<HComplex> & vec2) = &hMulSum;
vector<HComplex > (*fptr_hMulSum_hARRAY_HComplex_vec1vec2_11_STDITSTDIT)( hArray<HComplex> & vec1 , hArray<HComplex> & vec2) = &hMulSum;
HNumber (*fptr_hMulSum_STL_HNumber_vec1vec2_11_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hMulSum;
vector<HNumber > (*fptr_hMulSum_hARRAY_HNumber_vec1vec2_11_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hMulSum;
HInteger (*fptr_hMulSum_STL_HInteger_vec1vec2_11_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hMulSum;
vector<HInteger > (*fptr_hMulSum_hARRAY_HInteger_vec1vec2_11_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hMulSum;

template < class T > inline T hMulSum_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
return hMulSum ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T > inline T hMulSum_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
return hMulSum ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


HComplex (*fptr_hMulSum_hSLICED_STL_HComplex_vec1vec2_11_STDITSTDIT)( std::vector<HComplex> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HComplex> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMulSum_hSLICED;
HNumber (*fptr_hMulSum_hSLICED_STL_HNumber_vec1vec2_11_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMulSum_hSLICED;
HInteger (*fptr_hMulSum_hSLICED_STL_HInteger_vec1vec2_11_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hMulSum_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Multiplies all elements in the vector with each other and return the result

    \param vec: Numeric input vector

 
 hProduct(vec) -> vec[0]*vec[1]*vec[2]* ... * vec[N]

*/
template <class Iter>
typename Iter::value_type hProduct (const Iter vec,const Iter vec_end)
{
  typedef typename Iter::value_type T;
  T prod=1.0;
  Iter it=vec;
  while (it!=vec_end) {prod *= *it; ++it;};
  return prod;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hProduct( std::vector<T> & vec) {
return hProduct ( vec.begin(),vec.end());
}

template < class T > inline T hProduct( casa::Vector<T> & vec) {
return hProduct ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<T> hProduct( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hProduct ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HComplex (*fptr_hProduct_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hProduct;
vector<HComplex > (*fptr_hProduct_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hProduct;
HNumber (*fptr_hProduct_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hProduct;
vector<HNumber > (*fptr_hProduct_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hProduct;
HInteger (*fptr_hProduct_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hProduct;
vector<HInteger > (*fptr_hProduct_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hProduct;

template < class T > inline T hProduct_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hProduct ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hProduct_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hProduct ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HComplex (*fptr_hProduct_hSLICED_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;
HNumber (*fptr_hProduct_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;
HInteger (*fptr_hProduct_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hProduct_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the lengths or norm of a vector (i.e. Sqrt(Sum_i(xi*+2))).

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hNorm (const Iter vec,const Iter vec_end)
{
  HNumber sum=0;
  Iter it=vec;
  while (it!=vec_end) {sum += (*it) * (*it); ++it;};
  return sqrt(sum);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hNorm( std::vector<T> & vec) {
return hNorm ( vec.begin(),vec.end());
}

template < class T > inline HNumber hNorm( casa::Vector<T> & vec) {
return hNorm ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<HNumber> hNorm( hArray<T> & vec) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hNorm ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hNorm_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hNorm;
vector<HNumber > (*fptr_hNorm_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hNorm;
HNumber (*fptr_hNorm_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hNorm;
vector<HNumber > (*fptr_hNorm_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hNorm;

template < class T > inline HNumber hNorm_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hNorm ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hNorm_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hNorm ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hNorm_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNorm_hSLICED;
HNumber (*fptr_hNorm_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNorm_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Normalizes a vector to length unity.

    \param vec: Numeric input and output vector

*/
template <class Iter>
void hNormalize (const Iter vec,const Iter vec_end)
{
  HNumber norm=hNorm(vec,vec_end);
  Iter it=vec;
  while (it!=vec_end) {*it=(*it)/norm; ++it;};
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hNormalize( std::vector<T> & vec) {
hNormalize ( vec.begin(),vec.end());
}

template < class T > inline void hNormalize( casa::Vector<T> & vec) {
hNormalize ( vec.cbegin(),vec.cend());
}

template < class T > inline void hNormalize( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hNormalize ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hNormalize_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hNormalize;
void (*fptr_hNormalize_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hNormalize;
void (*fptr_hNormalize_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hNormalize;
void (*fptr_hNormalize_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hNormalize;

template < class T > inline void hNormalize_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNormalize ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hNormalize_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hNormalize ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hNormalize_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNormalize_hSLICED;
void (*fptr_hNormalize_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hNormalize_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$SECTION:           Statistics Functions
//========================================================================
//-----------------------------------------------------------------------
/*!
  hRandom(vector,-1,1) -> [-0.5,0.3,0.1, ...]
  vector.random(-1,1) -> [-0.5,0.3,0.1, ...]

  \brief Fills a vector with random values between minimum and maximum limits

    \param vec: Output vector which will be filled with random numbers.

    \param minimum: Random numbers will not go below that value.

    \param maximum: Random numbers will not exceed that value.

*/
template <class Iter>
void hRandom(const Iter vec,const Iter vec_end, const typename Iter::value_type minimum, const typename Iter::value_type maximum)
{
  Iter it=vec;
  typename Iter::value_type scale=(maximum-minimum)/0x7fffffff;
  while (it!=vec_end) {
    *it=rand()*scale+minimum;
    ++it;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hRandom( std::vector<T> & vec , T minimum , T maximum) {
hRandom ( vec.begin(),vec.end() , minimum , maximum);
}

template < class T > inline void hRandom( casa::Vector<T> & vec , T minimum , T maximum) {
hRandom ( vec.cbegin(),vec.cend() , minimum , maximum);
}

template < class T > inline void hRandom( hArray<T> & vec , T minimum , T maximum) {
bool iterate=true;
while(iterate) {
hRandom ( vec.begin(),vec.end() , minimum , maximum);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hRandom( hArray<T> & vec , vector<T> & minimum , vector<T> & maximum) {
bool iterate=true;
vector< T >::iterator minimum_iterator = minimum.begin();
vector< T >::iterator maximum_iterator = maximum.begin();
while(iterate) {
hRandom ( vec.begin(),vec.end() , *minimum_iterator , *maximum_iterator);
vec.next();
minimum_iterator++; if (minimum.end()==minimum_iterator) minimum_iterator = minimum.begin();
maximum_iterator++; if (maximum.end()==maximum_iterator) maximum_iterator = maximum.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hRandom_STL_HComplex_vecminimummaximum_111_STDIT)( std::vector<HComplex> & vec , HComplex minimum , HComplex maximum) = &hRandom;
void (*fptr_hRandom_hARRAY_HComplex_vecminimummaximum_111_STDIT)( hArray<HComplex> & vec , HComplex minimum , HComplex maximum) = &hRandom;
void (*fptr_hRandom_hARRAYALL_HComplex_vecminimummaximum_111_STDIT)( hArray<HComplex> & vec , vector<HComplex> & minimum , vector<HComplex> & maximum) = &hRandom;
void (*fptr_hRandom_STL_HNumber_vecminimummaximum_111_STDIT)( std::vector<HNumber> & vec , HNumber minimum , HNumber maximum) = &hRandom;
void (*fptr_hRandom_hARRAY_HNumber_vecminimummaximum_111_STDIT)( hArray<HNumber> & vec , HNumber minimum , HNumber maximum) = &hRandom;
void (*fptr_hRandom_hARRAYALL_HNumber_vecminimummaximum_111_STDIT)( hArray<HNumber> & vec , vector<HNumber> & minimum , vector<HNumber> & maximum) = &hRandom;
void (*fptr_hRandom_STL_HInteger_vecminimummaximum_111_STDIT)( std::vector<HInteger> & vec , HInteger minimum , HInteger maximum) = &hRandom;
void (*fptr_hRandom_hARRAY_HInteger_vecminimummaximum_111_STDIT)( hArray<HInteger> & vec , HInteger minimum , HInteger maximum) = &hRandom;
void (*fptr_hRandom_hARRAYALL_HInteger_vecminimummaximum_111_STDIT)( hArray<HInteger> & vec , vector<HInteger> & minimum , vector<HInteger> & maximum) = &hRandom;

template < class T > inline void hRandom_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T minimum , T maximum ) {
hRandom ( vec.begin() + vecslice1,vec.begin() + vecslice2 , minimum , maximum);
}

template < class T > inline void hRandom_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T minimum , T maximum ) {
hRandom ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , minimum , maximum);
}


void (*fptr_hRandom_hSLICED_STL_HComplex_vecminimummaximum_111_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HComplex minimum , HComplex maximum ) = &hRandom_hSLICED;
void (*fptr_hRandom_hSLICED_STL_HNumber_vecminimummaximum_111_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber minimum , HNumber maximum ) = &hRandom_hSLICED;
void (*fptr_hRandom_hSLICED_STL_HInteger_vecminimummaximum_111_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger minimum , HInteger maximum ) = &hRandom_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the mean value of all elements in a vector.

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hMean (const Iter vec,const Iter vec_end)
{
  HNumber mean=hSum(vec,vec_end);
  if (vec_end>vec) mean/=(vec_end-vec);
  return mean;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hMean( std::vector<T> & vec) {
return hMean ( vec.begin(),vec.end());
}

template < class T > inline HNumber hMean( casa::Vector<T> & vec) {
return hMean ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<HNumber> hMean( hArray<T> & vec) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hMean ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hMean_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hMean;
vector<HNumber > (*fptr_hMean_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hMean;
HNumber (*fptr_hMean_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hMean;
vector<HNumber > (*fptr_hMean_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hMean;

template < class T > inline HNumber hMean_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hMean ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hMean_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hMean ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hMean_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hMean_hSLICED;
HNumber (*fptr_hMean_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hMean_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Sorts a vector in place.

    \param vec: Numeric input vector


  Attention!!! The vector will be sorted in place. Hence, if you want to
  keep the data in its original order, you need to copy the data first
  to a scratch vector and then call this function with the scratch vector!
*/
template <class Iter>
void hSort(const Iter vec, const Iter vec_end)
{
  sort(vec,vec_end);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hSort( std::vector<T> & vec) {
hSort ( vec.begin(),vec.end());
}

template < class T > inline void hSort( casa::Vector<T> & vec) {
hSort ( vec.cbegin(),vec.cend());
}

template < class T > inline void hSort( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hSort ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSort_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hSort;
void (*fptr_hSort_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSort;
void (*fptr_hSort_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSort;
void (*fptr_hSort_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSort;

template < class T > inline void hSort_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSort ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hSort_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hSort ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hSort_hSLICED_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;
void (*fptr_hSort_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;
void (*fptr_hSort_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSort_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Sorts a vector in place and returns the median value of the elements.

    \param vec: Numeric input vector


  Attention!!! The vector will be sorted first. Hence, if you want to
  keep the data in its original order, you need to copy the data first
  to a scratch vector and then call this function with the scratch vector!
*/
template <class Iter>
typename Iter::value_type hSortMedian(const Iter vec, const Iter vec_end)
{
  sort(vec,vec_end);
  if (vec_end!=vec) return *(vec+(vec_end-vec)/2);
  else return hfnull<typename Iter::value_type>();
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline T hSortMedian( std::vector<T> & vec) {
return hSortMedian ( vec.begin(),vec.end());
}

template < class T > inline T hSortMedian( casa::Vector<T> & vec) {
return hSortMedian ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<T> hSortMedian( hArray<T> & vec) {
bool iterate=true;
vector<T> returnvector;
T returnvalue;
while(iterate) {
returnvalue = hSortMedian ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hSortMedian_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hSortMedian;
vector<HNumber > (*fptr_hSortMedian_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hSortMedian;
HInteger (*fptr_hSortMedian_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hSortMedian;
vector<HInteger > (*fptr_hSortMedian_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hSortMedian;

template < class T > inline T hSortMedian_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSortMedian ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline T hSortMedian_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hSortMedian ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hSortMedian_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSortMedian_hSLICED;
HInteger (*fptr_hSortMedian_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hSortMedian_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns the median value of the elements.

    \param vec: Numeric input vector

*/
template <class T>
T hMedian(std::vector<T> & vec)
{
  std::vector<T> scratch(vec);
  return hSortMedian(scratch);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HNumber (*fptr_hMedian_STL_HNumber_vec_1_STL)( std::vector<HNumber> & vec) = &hMedian;
HInteger (*fptr_hMedian_STL_HInteger_vec_1_STL)( std::vector<HInteger> & vec) = &hMedian;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the standard deviation around a mean value.

    \param vec: Numeric input vector

    \param mean: The mean value of the vector caluclated beforehand

*/
template <class Iter>
HNumber hStdDev (const Iter vec,const Iter vec_end, const typename Iter::value_type mean)
{
  typedef typename Iter::value_type T;
  HNumber scrt,sum=0.0;
  HInteger len=vec_end-vec;
  Iter it=vec;
  while (it<vec_end) {
    scrt = *it - mean;
    sum += scrt * scrt;
    ++it;
  };
  if (len>1) return sqrt(sum / (len-1));
  else return sqrt(sum);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hStdDev( std::vector<T> & vec , HNumber mean) {
return hStdDev ( vec.begin(),vec.end() , mean);
}

template < class T > inline HNumber hStdDev( casa::Vector<T> & vec , HNumber mean) {
return hStdDev ( vec.cbegin(),vec.cend() , mean);
}

template < class T > inline vector<HNumber> hStdDev( hArray<T> & vec , HNumber mean) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hStdDev ( vec.begin(),vec.end() , mean);
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HNumber> hStdDev( hArray<T> & vec , vector<HNumber> & mean) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
vector< HNumber >::iterator mean_iterator = mean.begin();
while(iterate) {
returnvalue = hStdDev ( vec.begin(),vec.end() , *mean_iterator);
vec.next();
mean_iterator++; if (mean.end()==mean_iterator) mean_iterator = mean.begin();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hStdDev_STL_HNumber_vecmean_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber mean) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAY_HNumber_vecmean_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber mean) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAYALL_HNumber_vecmean_1HNumber_STDIT)( hArray<HNumber> & vec , vector<HNumber> & mean) = &hStdDev;
HNumber (*fptr_hStdDev_STL_HInteger_vecmean_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber mean) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAY_HInteger_vecmean_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber mean) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAYALL_HInteger_vecmean_1HNumber_STDIT)( hArray<HInteger> & vec , vector<HNumber> & mean) = &hStdDev;

template < class T > inline HNumber hStdDev_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) {
return hStdDev ( vec.begin() + vecslice1,vec.begin() + vecslice2 , mean);
}

template < class T > inline HNumber hStdDev_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) {
return hStdDev ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , mean);
}


HNumber (*fptr_hStdDev_hSLICED_STL_HNumber_vecmean_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) = &hStdDev_hSLICED;
HNumber (*fptr_hStdDev_hSLICED_STL_HInteger_vecmean_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber mean ) = &hStdDev_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the standard deviation of a vector of values.

    \param vec: Numeric input vector

*/
template <class Iter>
HNumber hStdDev (const Iter vec,const Iter vec_end)
{
  return hStdDev(vec,vec_end,hMean(vec,vec_end));
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HNumber hStdDev( std::vector<T> & vec) {
return hStdDev ( vec.begin(),vec.end());
}

template < class T > inline HNumber hStdDev( casa::Vector<T> & vec) {
return hStdDev ( vec.cbegin(),vec.cend());
}

template < class T > inline vector<HNumber> hStdDev( hArray<T> & vec) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hStdDev ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hStdDev_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hStdDev;
HNumber (*fptr_hStdDev_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hStdDev;
vector<HNumber > (*fptr_hStdDev_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hStdDev;

template < class T > inline HNumber hStdDev_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hStdDev ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline HNumber hStdDev_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
return hStdDev ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


HNumber (*fptr_hStdDev_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hStdDev_hSLICED;
HNumber (*fptr_hStdDev_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hStdDev_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//$SECTION:           Comparison and Selection
//========================================================================
//========================================================================
//$ITERATE MFUNC GreaterThan,GreaterEqual,LessThan,LessEqual
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessEqual (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it <= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessEqual( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindLessEqual( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessEqual ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindLessEqual( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindLessEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindLessEqual( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindLessEqual ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindLessEqual_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessEqual;
vector<HInteger > (*fptr_hFindLessEqual_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessEqual;
vector<HInteger > (*fptr_hFindLessEqual_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindLessEqual;
HInteger (*fptr_hFindLessEqual_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessEqual;
vector<HInteger > (*fptr_hFindLessEqual_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessEqual;
vector<HInteger > (*fptr_hFindLessEqual_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindLessEqual;

template < class T > inline HInteger hFindLessEqual_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqual ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessEqual_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqual ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessEqual_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqual_hSLICED;
HInteger (*fptr_hFindLessEqual_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqual_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are LessEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessEqualAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) <= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessEqualAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindLessEqualAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessEqualAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindLessEqualAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindLessEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindLessEqualAbs( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindLessEqualAbs ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindLessEqualAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessEqualAbs;
vector<HInteger > (*fptr_hFindLessEqualAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;
vector<HInteger > (*fptr_hFindLessEqualAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;
HInteger (*fptr_hFindLessEqualAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessEqualAbs;
vector<HInteger > (*fptr_hFindLessEqualAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;
vector<HInteger > (*fptr_hFindLessEqualAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindLessEqualAbs;

template < class T > inline HInteger hFindLessEqualAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqualAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessEqualAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessEqualAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessEqualAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqualAbs_hSLICED;
HInteger (*fptr_hFindLessEqualAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessEqualAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterThan (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it > threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterThan( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindGreaterThan( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterThan ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindGreaterThan( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindGreaterThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindGreaterThan( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindGreaterThan ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindGreaterThan_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterThan;
vector<HInteger > (*fptr_hFindGreaterThan_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;
vector<HInteger > (*fptr_hFindGreaterThan_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;
HInteger (*fptr_hFindGreaterThan_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterThan;
vector<HInteger > (*fptr_hFindGreaterThan_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;
vector<HInteger > (*fptr_hFindGreaterThan_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindGreaterThan;

template < class T > inline HInteger hFindGreaterThan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThan ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterThan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThan ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterThan_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThan_hSLICED;
HInteger (*fptr_hFindGreaterThan_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are GreaterThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterThanAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) > threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterThanAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindGreaterThanAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterThanAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindGreaterThanAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindGreaterThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindGreaterThanAbs( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindGreaterThanAbs ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindGreaterThanAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterThanAbs;
vector<HInteger > (*fptr_hFindGreaterThanAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;
vector<HInteger > (*fptr_hFindGreaterThanAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;
HInteger (*fptr_hFindGreaterThanAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterThanAbs;
vector<HInteger > (*fptr_hFindGreaterThanAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;
vector<HInteger > (*fptr_hFindGreaterThanAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindGreaterThanAbs;

template < class T > inline HInteger hFindGreaterThanAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThanAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterThanAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterThanAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterThanAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThanAbs_hSLICED;
HInteger (*fptr_hFindGreaterThanAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterThanAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterEqual (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it >= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterEqual( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindGreaterEqual( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterEqual ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindGreaterEqual( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindGreaterEqual ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindGreaterEqual( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindGreaterEqual ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindGreaterEqual_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqual;
vector<HInteger > (*fptr_hFindGreaterEqual_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;
vector<HInteger > (*fptr_hFindGreaterEqual_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;
HInteger (*fptr_hFindGreaterEqual_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqual;
vector<HInteger > (*fptr_hFindGreaterEqual_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;
vector<HInteger > (*fptr_hFindGreaterEqual_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindGreaterEqual;

template < class T > inline HInteger hFindGreaterEqual_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqual ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterEqual_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqual ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterEqual_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqual_hSLICED;
HInteger (*fptr_hFindGreaterEqual_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqual_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are GreaterEqual a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindGreaterEqualAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) >= threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindGreaterEqualAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindGreaterEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindGreaterEqualAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindGreaterEqualAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindGreaterEqualAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindGreaterEqualAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindGreaterEqualAbs( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindGreaterEqualAbs ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindGreaterEqualAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqualAbs;
vector<HInteger > (*fptr_hFindGreaterEqualAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;
vector<HInteger > (*fptr_hFindGreaterEqualAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;
HInteger (*fptr_hFindGreaterEqualAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindGreaterEqualAbs;
vector<HInteger > (*fptr_hFindGreaterEqualAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;
vector<HInteger > (*fptr_hFindGreaterEqualAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindGreaterEqualAbs;

template < class T > inline HInteger hFindGreaterEqualAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqualAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindGreaterEqualAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindGreaterEqualAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindGreaterEqualAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqualAbs_hSLICED;
HInteger (*fptr_hFindGreaterEqualAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindGreaterEqualAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Find the samples that are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessThan (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (*it < threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessThan( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindLessThan( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessThan ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindLessThan( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindLessThan ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindLessThan( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindLessThan ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindLessThan_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessThan;
vector<HInteger > (*fptr_hFindLessThan_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessThan;
vector<HInteger > (*fptr_hFindLessThan_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindLessThan;
HInteger (*fptr_hFindLessThan_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessThan;
vector<HInteger > (*fptr_hFindLessThan_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessThan;
vector<HInteger > (*fptr_hFindLessThan_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindLessThan;

template < class T > inline HInteger hFindLessThan_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThan ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessThan_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThan ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessThan_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThan_hSLICED;
HInteger (*fptr_hFindLessThan_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThan_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Find the samples whose absolute values are LessThan a certain threshold value and returns the number of samples found and the positions of the samples in a second vector.

    \param vec: Numeric input vector to search through

    \param threshold: The threshold value

    \param vecout: Output vector - contains a list of positions in input vector which are above threshold

*/
template <class Iter>
HInteger hFindLessThanAbs (const Iter vec , const Iter vec_end, const typename Iter::value_type threshold, const typename vector<HInteger>::iterator vecout, const typename vector<HInteger>::iterator vecout_end)
{
  Iter it=vec;
  typename vector<HInteger>::iterator itout=vecout;
  while (it<vec_end) {
    if (abs(*it) < threshold) {
      if (itout < vecout_end) {
 *itout=(it-vec);
 ++itout;
      };
    };
    ++it;
  };
  return (itout-vecout);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLessThanAbs( std::vector<T> & vec , T threshold , std::vector<HInteger> & vecout) {
return hFindLessThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
}

template < class T > inline HInteger hFindLessThanAbs( casa::Vector<T> & vec , T threshold , casa::Vector<HInteger> & vecout) {
return hFindLessThanAbs ( vec.cbegin(),vec.cend() , threshold , vecout.cbegin(),vecout.cend());
}

template < class T > inline vector<HInteger> hFindLessThanAbs( hArray<T> & vec , T threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindLessThanAbs ( vec.begin(),vec.end() , threshold , vecout.begin(),vecout.end());
vec.next();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindLessThanAbs( hArray<T> & vec , vector<T> & threshold , hArray<HInteger> & vecout) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator threshold_iterator = threshold.begin();
while(iterate) {
returnvalue = hFindLessThanAbs ( vec.begin(),vec.end() , *threshold_iterator , vecout.begin(),vecout.end());
vec.next();
threshold_iterator++; if (threshold.end()==threshold_iterator) threshold_iterator = threshold.begin();
vecout.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindLessThanAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HNumber threshold , std::vector<HInteger> & vecout) = &hFindLessThanAbs;
vector<HInteger > (*fptr_hFindLessThanAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , HNumber threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;
vector<HInteger > (*fptr_hFindLessThanAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HNumber> & vec , vector<HNumber> & threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;
HInteger (*fptr_hFindLessThanAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger threshold , std::vector<HInteger> & vecout) = &hFindLessThanAbs;
vector<HInteger > (*fptr_hFindLessThanAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , HInteger threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;
vector<HInteger > (*fptr_hFindLessThanAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( hArray<HInteger> & vec , vector<HInteger> & threshold , hArray<HInteger> & vecout) = &hFindLessThanAbs;

template < class T > inline HInteger hFindLessThanAbs_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThanAbs ( vec.begin() + vecslice1,vec.begin() + vecslice2 , threshold , vecout.begin() + vecoutslice1,vecout.begin() + vecoutslice2);
}

template < class T > inline HInteger hFindLessThanAbs_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T threshold , casa::Vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) {
return hFindLessThanAbs ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , threshold , vecout.cbegin() + vecoutslice1,vecout.cbegin() + vecoutslice2);
}


HInteger (*fptr_hFindLessThanAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThanAbs_hSLICED;
HInteger (*fptr_hFindLessThanAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger threshold , std::vector<HInteger> & vecout , HInteger vecoutslice1 , HInteger vecoutslice2) = &hFindLessThanAbs_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//$ENDITERATE
//-----------------------------------------------------------------------
/*!
  \brief Downsample the input vector to a smaller output vector.

    \param vec1: Numeric input vector

    \param vec2: Numeric output vector


 Downsample the input vector to a smaller output vector, by replacing
     subsequent blocks of values by their mean value. The block size
     is automatically chosen such that the input vector fits exactly
     into the output vector. All blocks have the same length with a
     possible exception of the last block.
*/
template <class Iter>
void hDownsample (const Iter vec1,
    const Iter vec1_end,
    const Iter vec2,
    const Iter vec2_end)
{
  if (vec2>=vec2_end) return; //If size 0 do nothing
  if (vec1>=vec1_end) return; //If size 0 do nothing
  HInteger ilen=(vec1_end-vec1);
  HInteger olen=(vec2_end-vec2);
  HInteger blen=max(ilen/(olen-1),1);
  //use max to avoid infinite loops if output vector is too large
  Iter it2,it1=vec1;
  Iter ito=vec2,ito_end=vec2_end-1;
  //only produce the first N-1 blocks in the output vector
  while ((it1<vec1_end) && (ito<ito_end)) {
    it2=min(it1+blen,vec1_end);
    *ito=hMean(it1,it2);
    it1=it2;
    ++ito;
    }
  *ito=hMean(it2,vec1_end);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hDownsample( std::vector<T> & vec1 , std::vector<T> & vec2) {
hDownsample ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
}

template < class T > inline void hDownsample( casa::Vector<T> & vec1 , casa::Vector<T> & vec2) {
hDownsample ( vec1.cbegin(),vec1.cend() , vec2.cbegin(),vec2.cend());
}

template < class T > inline void hDownsample( hArray<T> & vec1 , hArray<T> & vec2) {
bool iterate=true;
while(iterate) {
hDownsample ( vec1.begin(),vec1.end() , vec2.begin(),vec2.end());
vec1.next();
vec2.next();
iterate = vec1.doLoopAgain();
};
}


void (*fptr_hDownsample_STL_HNumber_vec1vec2_11_STDITSTDIT)( std::vector<HNumber> & vec1 , std::vector<HNumber> & vec2) = &hDownsample;
void (*fptr_hDownsample_hARRAY_HNumber_vec1vec2_11_STDITSTDIT)( hArray<HNumber> & vec1 , hArray<HNumber> & vec2) = &hDownsample;
void (*fptr_hDownsample_STL_HInteger_vec1vec2_11_STDITSTDIT)( std::vector<HInteger> & vec1 , std::vector<HInteger> & vec2) = &hDownsample;
void (*fptr_hDownsample_hARRAY_HInteger_vec1vec2_11_STDITSTDIT)( hArray<HInteger> & vec1 , hArray<HInteger> & vec2) = &hDownsample;

template < class T > inline void hDownsample_hSLICED ( std::vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDownsample ( vec1.begin() + vec1slice1,vec1.begin() + vec1slice2 , vec2.begin() + vec2slice1,vec2.begin() + vec2slice2);
}

template < class T > inline void hDownsample_hSLICED ( casa::Vector<T> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , casa::Vector<T> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) {
hDownsample ( vec1.cbegin() + vec1slice1,vec1.cbegin() + vec1slice2 , vec2.cbegin() + vec2slice1,vec2.cbegin() + vec2slice2);
}


void (*fptr_hDownsample_hSLICED_STL_HNumber_vec1vec2_11_STDITSTDIT)( std::vector<HNumber> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HNumber> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDownsample_hSLICED;
void (*fptr_hDownsample_hSLICED_STL_HInteger_vec1vec2_11_STDITSTDIT)( std::vector<HInteger> & vec1 , HInteger vec1slice1 , HInteger vec1slice2 , std::vector<HInteger> & vec2 , HInteger vec2slice1 , HInteger vec2slice2) = &hDownsample_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Downsample the input vector by a cetain factor and return a new vector.

    \param vec: Numeric input vector

    \param downsample_factor: Factor by which to reduce original size


 Downsample the input vector to a new smaller output vector, by replacing
     subsequent blocks of values by their mean value. The block size
     is automatically chosen such that the input vector fits exactly
     into the output vector. All blocks have the same length with a
     possible exception of the last block.
*/
template <class T>
std::vector<T> hDownsample (
    std::vector<T> & vec,
    HNumber downsample_factor
    )
{
  std::vector<T> newvec(floor(vec.size()/downsample_factor+0.5));
  hDownsample(vec,newvec);
  return newvec;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hDownsample_STL_HNumber_vecdownsample_factor_1HNumber_STL)( std::vector<HNumber> & vec , HNumber downsample_factor) = &hDownsample;
std::vector<HInteger> (*fptr_hDownsample_STL_HInteger_vecdownsample_factor_1HNumber_STL)( std::vector<HInteger> & vec , HNumber downsample_factor) = &hDownsample;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!

  \brief Finds the location (i.e., returns integer) in a monotonically increasing vector, where the input search value is just above or equal to the value in the vector.

    \param vec: Sorted numeric input vector

    \param value: value to search for


Finds -- through a binary search and interpolation -- the location in
  a monotonically increasing vector, where the search value is just
  above or equal to the value in the vector.

This requires random access iterators, in order to have an optimal search result.

*/
template <class Iter>
HInteger hFindLowerBound (const Iter vec,
    const Iter vec_end,
    const typename Iter::value_type value)
//iterator_traits<Iter>::value_type value)
{
  HNumber value_n=hfcast<HNumber>(value); //This also works for Complex then
  HInteger niter=0;
  if (vec==vec_end) return 0;
  HInteger maxpos=vec_end-vec-1,posguess;
  Iter it1=vec,it2=vec_end-1,it0;
  if (value_n<=hfcast<HNumber>(*it1)) return 0;
  if (value_n>=hfcast<HNumber>(*it2)) return maxpos;
  posguess=(value_n-hfcast<HNumber>(*it1))/(hfcast<HNumber>(*it2)-hfcast<HNumber>(*it1))*maxpos;
  it0=vec+posguess;
  if (it0<it1) return hfcast<HInteger>(it1-vec); //Error, Non monotonic
  if (it0>=it2) return hfcast<HInteger>(it2-vec); //Error, Non monotonic
  //  cout << "hFindLowerBound(" << value_n << "): niter=" << niter << ", posguess=" << posguess << ", val=" << *it0 << " vals=(" << hfcast<HNumber>(*(it0)) << ", " << hfcast<HNumber>(*(it0+1)) << "), bracket=(" << it1-vec << ", " << it2-vec <<")" <<endl;
  while (!((value_n < hfcast<HNumber>(*(it0+1))) && (value_n >= hfcast<HNumber>(*it0)))) {
    if (value_n > hfcast<HNumber>(*it0)) {
      it1=it0;
    } else {
      it2=it0;
    };
    it0=it1+(it2-it1)/2;
    if (*it0>value_n) it2=it0; //Binary search step
    else it1=it0;
    posguess=(value_n-hfcast<HNumber>(*it1))/(hfcast<HNumber>(*it2)-hfcast<HNumber>(*it1))*(it2-it1)+(it1-vec);
    it0=vec+posguess;
    ++niter;
    //cout << "hFindLowerBound(" << value_n << "): niter=" << niter << ", posguess=" << posguess << ", val=" << *it0 << " vals=(" << hfcast<HNumber>(*(it0)) << ", " << hfcast<HNumber>(*(it0+1)) << "), bracket=(" << it1-vec << ", " << it2-vec <<")" <<endl;
    if (it0<it1) return it1-vec; //Error, Non monotonic
    if (it0>it2) return it2-vec; //Error, Non monotonic
  };
  return posguess;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline HInteger hFindLowerBound( std::vector<T> & vec , T value) {
return hFindLowerBound ( vec.begin(),vec.end() , value);
}

template < class T > inline HInteger hFindLowerBound( casa::Vector<T> & vec , T value) {
return hFindLowerBound ( vec.cbegin(),vec.cend() , value);
}

template < class T > inline vector<HInteger> hFindLowerBound( hArray<T> & vec , T value) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
while(iterate) {
returnvalue = hFindLowerBound ( vec.begin(),vec.end() , value);
vec.next();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

template < class T > inline vector<HInteger> hFindLowerBound( hArray<T> & vec , vector<T> & value) {
bool iterate=true;
vector<HInteger> returnvector;
HInteger returnvalue;
vector< T >::iterator value_iterator = value.begin();
while(iterate) {
returnvalue = hFindLowerBound ( vec.begin(),vec.end() , *value_iterator);
vec.next();
value_iterator++; if (value.end()==value_iterator) value_iterator = value.begin();
iterate = vec.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HInteger (*fptr_hFindLowerBound_STL_HComplex_vecvalue_11_STDIT)( std::vector<HComplex> & vec , HComplex value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAY_HComplex_vecvalue_11_STDIT)( hArray<HComplex> & vec , HComplex value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAYALL_HComplex_vecvalue_11_STDIT)( hArray<HComplex> & vec , vector<HComplex> & value) = &hFindLowerBound;
HInteger (*fptr_hFindLowerBound_STL_HNumber_vecvalue_11_STDIT)( std::vector<HNumber> & vec , HNumber value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAY_HNumber_vecvalue_11_STDIT)( hArray<HNumber> & vec , HNumber value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAYALL_HNumber_vecvalue_11_STDIT)( hArray<HNumber> & vec , vector<HNumber> & value) = &hFindLowerBound;
HInteger (*fptr_hFindLowerBound_STL_HInteger_vecvalue_11_STDIT)( std::vector<HInteger> & vec , HInteger value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAY_HInteger_vecvalue_11_STDIT)( hArray<HInteger> & vec , HInteger value) = &hFindLowerBound;
vector<HInteger > (*fptr_hFindLowerBound_hARRAYALL_HInteger_vecvalue_11_STDIT)( hArray<HInteger> & vec , vector<HInteger> & value) = &hFindLowerBound;

template < class T > inline HInteger hFindLowerBound_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T value ) {
return hFindLowerBound ( vec.begin() + vecslice1,vec.begin() + vecslice2 , value);
}

template < class T > inline HInteger hFindLowerBound_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , T value ) {
return hFindLowerBound ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , value);
}


HInteger (*fptr_hFindLowerBound_hSLICED_STL_HComplex_vecvalue_11_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HComplex value ) = &hFindLowerBound_hSLICED;
HInteger (*fptr_hFindLowerBound_hSLICED_STL_HNumber_vecvalue_11_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber value ) = &hFindLowerBound_hSLICED;
HInteger (*fptr_hFindLowerBound_hSLICED_STL_HInteger_vecvalue_11_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HInteger value ) = &hFindLowerBound_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*
//Wrapper for c-style arrays
HInteger hFindLowerBound(const HNumber* vec,
			 const HInteger len,
			 const HNumber value)
{
  return hFindLowerBound(vec,vec+len,value);
}
*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length len with constant weights normalized to give a sum of unity. Can be used by hRunningAverageT.

    \param wlen: Lengths of weights vector

*/
 //template <class T>
std::vector<HNumber> hFlatWeights (HInteger wlen) {
  std::vector<HNumber> weights(wlen,1.0/wlen);
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hFlatWeights_STL_HInteger_wlen_HInteger_)( HInteger wlen) = &hFlatWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length wlen with linearly rising and decreasing weights centered at len/2.

    \param wlen: Lengths of weights vector


The vector is normalized to give a sum of unity. Can be used by
hRunningAverage.
*/
 //template <class T>
std::vector<HNumber> hLinearWeights (HInteger wlen) {
  std::vector<HNumber> weights(wlen,0.0);
  HInteger i,middle=wlen/2;
  HNumber f,sum=0.0;
  for (i=0; i<wlen; i++) {
    f=1.0-abs(middle-i)/(middle+1.0);
    weights[i]=f;
    sum+=f;
  };
  //Normalize to unity
  for (i=0; i<wlen; i++) weights[i]=weights[i]/sum;
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hLinearWeights_STL_HInteger_wlen_HInteger_)( HInteger wlen) = &hLinearWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Returns vector of weights of length wlen with Gaussian distribution centered at len/2 and sigma=len/4 (i.e. the Gaussian extends over 2 sigma in both directions).

    \param wlen: Lengths of weights vector

*/
 //template <class T>
std::vector<HNumber> hGaussianWeights (HInteger wlen) {
  vector<HNumber> weights(wlen,0.0);
  HInteger i,middle=wlen/2;
  HNumber f,sum=0.0;
  for (i=0; i<wlen; i++) {
    f=funcGaussian(i,max(wlen/4.0,1.0),middle);
    weights[i]=f;
    sum+=f;
  };
  //Normalize to unity
  for (i=0; i<wlen; i++) weights[i]=weights[i]/sum;
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hGaussianWeights_STL_HInteger_wlen_HInteger_)( HInteger wlen) = &hGaussianWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a normalized weight vector.

    \param wlen: Length of weight vector

    \param wtype: Type of weight vector

*/
vector<HNumber> hWeights(HInteger wlen, hWEIGHTS wtype){
  vector<HNumber> weights;
  if (wlen<1) wlen=1;
  switch (wtype) {
  case WEIGHTS_LINEAR:
    weights=hLinearWeights(wlen);
    break;
  case WEIGHTS_GAUSSIAN:
    weights=hGaussianWeights(wlen);
    break;
  default: //  WEIGHTS_FLAT:
    weights=hFlatWeights(wlen);
  };
  return weights;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

std::vector<HNumber> (*fptr_hWeights_STL_HInteger_wlenwtype_HIntegerhWEIGHTS_)( HInteger wlen , hWEIGHTS wtype) = &hWeights;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Calculate the running average of an input vector using a weight vector.

    \param idata: Input vector

    \param odata: Output vector

    \param weights: Weight vector

*/
template <class DataIter, class NumVecIter>
void hRunningAverage (const DataIter idata,
       const DataIter idata_end,
       const DataIter odata,
       const DataIter odata_end,
       const NumVecIter weights,
       const NumVecIter weights_end)
{
  HInteger l=(weights_end-weights);
  /* Index of the central element of the weights vector (i.e., where it
     typically would peak) */
  HInteger middle=l/2;
  /* To avoid too many rounding errors with Integers */
  //  typename DataIter::value_type fac = l*10;
  HNumber temp;
  DataIter dit;
  DataIter dit2;
  DataIter din(idata);
  DataIter dout(odata);
  NumVecIter wit;
  while (din<idata_end && dout<odata_end) {
    dit=din-middle; //data iterator set to the first element to be taken into account (left from current element)
    wit=weights; // weight iterators set to beginning of weights
    temp=0.0;
    while (wit<weights_end) {
      if (dit<idata) dit2=idata;
      else if (dit>=idata_end) dit2=idata_end-1;
      else dit2=dit;
      temp=temp+(*dit2)*(*wit);
      ++dit; ++wit;
    };
    *dout=temp;
    ++dout; ++din; //point to the next element in data input and output vector
  };
  return;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hRunningAverage( std::vector<HNumber> & idata , std::vector<HNumber> & odata , std::vector<HNumber> & weights) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , weights.begin(),weights.end());
}

inline void hRunningAverage( casa::Vector<HNumber> & idata , casa::Vector<HNumber> & odata , casa::Vector<HNumber> & weights) {
hRunningAverage ( idata.cbegin(),idata.cend() , odata.cbegin(),odata.cend() , weights.cbegin(),weights.cend());
}

inline void hRunningAverage( hArray<HNumber> & idata , hArray<HNumber> & odata , hArray<HNumber> & weights) {
bool iterate=true;
while(iterate) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , weights.begin(),weights.end());
idata.next();
odata.next();
weights.next();
iterate = idata.doLoopAgain();
};
}


void (*fptr_hRunningAverage_STL_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT)( std::vector<HNumber> & idata , std::vector<HNumber> & odata , std::vector<HNumber> & weights) = &hRunningAverage;
void (*fptr_hRunningAverage_hARRAY_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT)( hArray<HNumber> & idata , hArray<HNumber> & odata , hArray<HNumber> & weights) = &hRunningAverage;

 inline void hRunningAverage_hSLICED ( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , std::vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) {
hRunningAverage ( idata.begin() + idataslice1,idata.begin() + idataslice2 , odata.begin() + odataslice1,odata.begin() + odataslice2 , weights.begin() + weightsslice1,weights.begin() + weightsslice2);
}

inline void hRunningAverage_hSLICED ( casa::Vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , casa::Vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , casa::Vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) {
hRunningAverage ( idata.cbegin() + idataslice1,idata.cbegin() + idataslice2 , odata.cbegin() + odataslice1,odata.cbegin() + odataslice2 , weights.cbegin() + weightsslice1,weights.cbegin() + weightsslice2);
}


void (*fptr_hRunningAverage_hSLICED_STL_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT)( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , std::vector<HNumber> & weights , HInteger weightsslice1 , HInteger weightsslice2) = &hRunningAverage_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Overloaded function to automatically calculate weights.

    \param idata: Input vector

    \param odata: Output vector

    \param wlen: Length of weight vector

    \param wtype: Type of weight vector

*/
template <class DataIter>
void hRunningAverage (const DataIter idata,
       const DataIter idata_end,
       const DataIter odata,
       const DataIter odata_end,
       HInteger wlen,
       hWEIGHTS wtype)
{
  vector<HNumber> weights = hWeights(wlen, wtype);
  hRunningAverage<DataIter, vector<HNumber>::iterator> (idata,
       idata_end,
       odata,
       odata_end,
       weights.begin(),
       weights.end());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hRunningAverage( std::vector<HNumber> & idata , std::vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , wlen , wtype);
}

inline void hRunningAverage( casa::Vector<HNumber> & idata , casa::Vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
hRunningAverage ( idata.cbegin(),idata.cend() , odata.cbegin(),odata.cend() , wlen , wtype);
}

inline void hRunningAverage( hArray<HNumber> & idata , hArray<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) {
bool iterate=true;
while(iterate) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , wlen , wtype);
idata.next();
odata.next();
iterate = idata.doLoopAgain();
};
}

inline void hRunningAverage( hArray<HNumber> & idata , hArray<HNumber> & odata , vector<HInteger> & wlen , vector<hWEIGHTS> & wtype) {
bool iterate=true;
vector< HInteger >::iterator wlen_iterator = wlen.begin();
vector< hWEIGHTS >::iterator wtype_iterator = wtype.begin();
while(iterate) {
hRunningAverage ( idata.begin(),idata.end() , odata.begin(),odata.end() , *wlen_iterator , *wtype_iterator);
idata.next();
odata.next();
wlen_iterator++; if (wlen.end()==wlen_iterator) wlen_iterator = wlen.begin();
wtype_iterator++; if (wtype.end()==wtype_iterator) wtype_iterator = wtype.begin();
iterate = idata.doLoopAgain();
};
}


void (*fptr_hRunningAverage_STL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( std::vector<HNumber> & idata , std::vector<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) = &hRunningAverage;
void (*fptr_hRunningAverage_hARRAY_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( hArray<HNumber> & idata , hArray<HNumber> & odata , HInteger wlen , hWEIGHTS wtype) = &hRunningAverage;
void (*fptr_hRunningAverage_hARRAYALL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( hArray<HNumber> & idata , hArray<HNumber> & odata , vector<HInteger> & wlen , vector<hWEIGHTS> & wtype) = &hRunningAverage;

 inline void hRunningAverage_hSLICED ( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) {
hRunningAverage ( idata.begin() + idataslice1,idata.begin() + idataslice2 , odata.begin() + odataslice1,odata.begin() + odataslice2 , wlen , wtype);
}

inline void hRunningAverage_hSLICED ( casa::Vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , casa::Vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) {
hRunningAverage ( idata.cbegin() + idataslice1,idata.cbegin() + idataslice2 , odata.cbegin() + odataslice1,odata.cbegin() + odataslice2 , wlen , wtype);
}


void (*fptr_hRunningAverage_hSLICED_STL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT)( std::vector<HNumber> & idata , HInteger idataslice1 , HInteger idataslice2 , std::vector<HNumber> & odata , HInteger odataslice1 , HInteger odataslice2 , HInteger wlen , hWEIGHTS wtype ) = &hRunningAverage_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:           RF (Radio Frequency) Function
//========================================================================
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located in a certain direction in farfield (based on L. Bahren).

    \param antPosition: Cartesian antenna positions 

    \param skyDirection: Vector in Cartesian coordinates pointing towards a sky position from the antenna - vector of length 3

    \param length: Length of the skyDirection vector, used for normalization - provided to speed up calculation

*/
template <class Iter>
HNumber hGeometricDelayFarField (
   const Iter antPosition,
   const Iter skyDirection,
   HNumber length
   )
{
  return - (*skyDirection * *antPosition
     + *(skyDirection+1) * *(antPosition+1)
     + *(skyDirection+2) * *(antPosition+2))/length/CR::lightspeed;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline HNumber hGeometricDelayFarField( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyDirection , HNumber length) {
return hGeometricDelayFarField ( antPosition.begin() , skyDirection.begin() , length);
}

inline HNumber hGeometricDelayFarField( casa::Vector<HNumber> & antPosition , casa::Vector<HNumber> & skyDirection , HNumber length) {
return hGeometricDelayFarField ( antPosition.cbegin() , skyDirection.cbegin() , length);
}

inline vector<HNumber> hGeometricDelayFarField( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , HNumber length) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hGeometricDelayFarField ( antPosition.begin() , skyDirection.begin() , length);
antPosition.next();
skyDirection.next();
iterate = antPosition.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

inline vector<HNumber> hGeometricDelayFarField( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , vector<HNumber> & length) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
vector< HNumber >::iterator length_iterator = length.begin();
while(iterate) {
returnvalue = hGeometricDelayFarField ( antPosition.begin() , skyDirection.begin() , *length_iterator);
antPosition.next();
skyDirection.next();
length_iterator++; if (length.end()==length_iterator) length_iterator = length.begin();
iterate = antPosition.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hGeometricDelayFarField_STL_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyDirection , HNumber length) = &hGeometricDelayFarField;
vector<HNumber > (*fptr_hGeometricDelayFarField_hARRAY_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , HNumber length) = &hGeometricDelayFarField;
vector<HNumber > (*fptr_hGeometricDelayFarField_hARRAYALL_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyDirection , vector<HNumber> & length) = &hGeometricDelayFarField;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for a signal received at an antenna position relative to a phase center from a source located at a certain 3D space coordinate in nearfield (based on L. Bahren).

    \param antPosition: Cartesian antenna positions 

    \param skyPosition: Vector in Cartesian coordinates 

    \param distance: Distance of source, i.e. the length of skyPosition - provided to speed up calculation

*/
template <class Iter>
HNumber hGeometricDelayNearField (
   const Iter antPosition,
   const Iter skyPosition,
   const HNumber distance)
{
  return (
   sqrt(
        square(*skyPosition - *antPosition)
        +square(*(skyPosition+1) - *(antPosition+1))
        +square(*(skyPosition+2) - *(antPosition+2))
        ) - distance
   )/CR::lightspeed;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline HNumber hGeometricDelayNearField( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyPosition , HNumber distance) {
return hGeometricDelayNearField ( antPosition.begin() , skyPosition.begin() , distance);
}

inline HNumber hGeometricDelayNearField( casa::Vector<HNumber> & antPosition , casa::Vector<HNumber> & skyPosition , HNumber distance) {
return hGeometricDelayNearField ( antPosition.cbegin() , skyPosition.cbegin() , distance);
}

inline vector<HNumber> hGeometricDelayNearField( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , HNumber distance) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
while(iterate) {
returnvalue = hGeometricDelayNearField ( antPosition.begin() , skyPosition.begin() , distance);
antPosition.next();
skyPosition.next();
iterate = antPosition.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

inline vector<HNumber> hGeometricDelayNearField( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , vector<HNumber> & distance) {
bool iterate=true;
vector<HNumber> returnvector;
HNumber returnvalue;
vector< HNumber >::iterator distance_iterator = distance.begin();
while(iterate) {
returnvalue = hGeometricDelayNearField ( antPosition.begin() , skyPosition.begin() , *distance_iterator);
antPosition.next();
skyPosition.next();
distance_iterator++; if (distance.end()==distance_iterator) distance_iterator = distance.begin();
iterate = antPosition.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


HNumber (*fptr_hGeometricDelayNearField_STL_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & antPosition , std::vector<HNumber> & skyPosition , HNumber distance) = &hGeometricDelayNearField;
vector<HNumber > (*fptr_hGeometricDelayNearField_hARRAY_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , HNumber distance) = &hGeometricDelayNearField;
vector<HNumber > (*fptr_hGeometricDelayNearField_hARRAYALL_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED)( hArray<HNumber> & antPosition , hArray<HNumber> & skyPosition , vector<HNumber> & distance) = &hGeometricDelayNearField;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the time delay in seconds for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field.

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param delays: Output vector containing the delays in seconds for all antennas and positions [antenna index runs fastest: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter>
void hGeometricDelays (
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const Iter delays,
   const Iter delays_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    sky=skyPositions,
    del=delays,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  if (farfield) {
    while (sky < sky_end && del < delays_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && del < delays_end) {
 *del=hGeometricDelayFarField(ant,sky,distance);
 ant+=3; ++del;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && del < delays_end) {
      distance = hNorm(sky,sky+3); //distance from phase center
      ant=antPositions;
      while (ant < ant_end && del < delays_end) {
 *del=hGeometricDelayNearField(ant,sky,distance);
 ant+=3; ++del;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricDelays( std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & delays , bool farfield) {
hGeometricDelays ( antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , delays.begin(),delays.end() , farfield);
}

inline void hGeometricDelays( casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HNumber> & delays , bool farfield) {
hGeometricDelays ( antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , delays.cbegin(),delays.cend() , farfield);
}

inline void hGeometricDelays( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricDelays ( antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , delays.begin(),delays.end() , farfield);
antPositions.next();
skyPositions.next();
delays.next();
iterate = antPositions.doLoopAgain();
};
}

inline void hGeometricDelays( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , vector<bool> & farfield) {
bool iterate=true;
vector< bool >::iterator farfield_iterator = farfield.begin();
while(iterate) {
hGeometricDelays ( antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , delays.begin(),delays.end() , *farfield_iterator);
antPositions.next();
skyPositions.next();
delays.next();
farfield_iterator++; if (farfield.end()==farfield_iterator) farfield_iterator = farfield.begin();
iterate = antPositions.doLoopAgain();
};
}


void (*fptr_hGeometricDelays_STL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & delays , bool farfield) = &hGeometricDelays;
void (*fptr_hGeometricDelays_hARRAY_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , bool farfield) = &hGeometricDelays;
void (*fptr_hGeometricDelays_hARRAYALL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & delays , vector<bool> & farfield) = &hGeometricDelays;

 inline void hGeometricDelays_hSLICED ( std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) {
hGeometricDelays ( antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , delays.begin() + delaysslice1,delays.begin() + delaysslice2 , farfield);
}

inline void hGeometricDelays_hSLICED ( casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) {
hGeometricDelays ( antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , delays.cbegin() + delaysslice1,delays.cbegin() + delaysslice2 , farfield);
}


void (*fptr_hGeometricDelays_hSLICED_STL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT)( std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & delays , HInteger delaysslice1 , HInteger delaysslice2 , bool farfield ) = &hGeometricDelays_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the phase gradients for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.

    \param frequencies: Vector of frequencies 

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param phases: Output vector containing the phases in radians for all frequencies, antennas and positions [frequency index, runs fastest, then antenna index: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter>
void hGeometricPhases (
   const Iter frequencies,
   const Iter frequencies_end,
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const Iter phases,
   const Iter phases_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    freq,
    sky=skyPositions,
    phase=phases,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  if (farfield) {
    while (sky < sky_end && phase < phases_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && phase < phases_end) {
 freq=frequencies;
 while (freq < frequencies_end && phase < phases_end) {
   *phase=hPhase(*freq,hGeometricDelayFarField(ant,sky,distance));
   ++phase; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && phase < phases_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && phase < phases_end) {
 freq=frequencies;
 while (freq < frequencies_end && phase < phases_end) {
   *phase=hPhase(*freq,hGeometricDelayNearField(ant,sky,distance));
   ++phase; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricPhases( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & phases , bool farfield) {
hGeometricPhases ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , phases.begin(),phases.end() , farfield);
}

inline void hGeometricPhases( casa::Vector<HNumber> & frequencies , casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HNumber> & phases , bool farfield) {
hGeometricPhases ( frequencies.cbegin(),frequencies.cend() , antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , phases.cbegin(),phases.cend() , farfield);
}

inline void hGeometricPhases( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricPhases ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , phases.begin(),phases.end() , farfield);
frequencies.next();
antPositions.next();
skyPositions.next();
phases.next();
iterate = frequencies.doLoopAgain();
};
}

inline void hGeometricPhases( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , vector<bool> & farfield) {
bool iterate=true;
vector< bool >::iterator farfield_iterator = farfield.begin();
while(iterate) {
hGeometricPhases ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , phases.begin(),phases.end() , *farfield_iterator);
frequencies.next();
antPositions.next();
skyPositions.next();
phases.next();
farfield_iterator++; if (farfield.end()==farfield_iterator) farfield_iterator = farfield.begin();
iterate = frequencies.doLoopAgain();
};
}


void (*fptr_hGeometricPhases_STL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HNumber> & phases , bool farfield) = &hGeometricPhases;
void (*fptr_hGeometricPhases_hARRAY_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , bool farfield) = &hGeometricPhases;
void (*fptr_hGeometricPhases_hARRAYALL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HNumber> & phases , vector<bool> & farfield) = &hGeometricPhases;

 inline void hGeometricPhases_hSLICED ( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) {
hGeometricPhases ( frequencies.begin() + frequenciesslice1,frequencies.begin() + frequenciesslice2 , antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , phases.begin() + phasesslice1,phases.begin() + phasesslice2 , farfield);
}

inline void hGeometricPhases_hSLICED ( casa::Vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) {
hGeometricPhases ( frequencies.cbegin() + frequenciesslice1,frequencies.cbegin() + frequenciesslice2 , antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , phases.cbegin() + phasesslice1,phases.cbegin() + phasesslice2 , farfield);
}


void (*fptr_hGeometricPhases_hSLICED_STL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HNumber> & phases , HInteger phasesslice1 , HInteger phasesslice2 , bool farfield ) = &hGeometricPhases_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Calculates the phase gradients as complex weights for signals received at various antenna positions relative to a phase center from sources located at certain 3D space coordinates in near or far field and for different frequencies.

    \param frequencies: Vector of frequencies 

    \param antPositions: Cartesian antenna positions 

    \param skyPositions: Vector in Cartesian coordinates 

    \param weights: Output vector containing the phases in radians for all frequencies, antennas and positions [frequency index, runs fastest, then antenna index: 

    \param farfield: Calculate in farfield approximation if true, otherwise do near field calculation

*/
template <class Iter, class CIter>
void hGeometricWeights (
   const Iter frequencies,
   const Iter frequencies_end,
   const Iter antPositions,
   const Iter antPositions_end,
   const Iter skyPositions,
   const Iter skyPositions_end,
   const CIter weights,
   const CIter weights_end,
   const bool farfield
   )
{
  HNumber distance;
  Iter
    ant,
    freq,
    sky=skyPositions,
    ant_end=antPositions_end-2,
    sky_end=skyPositions_end-2;
  CIter weight=weights;
  if (farfield) {
    while (sky < sky_end && weight < weights_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && weight < weights_end) {
 freq=frequencies;
 while (freq < frequencies_end && weight < weights_end) {
   *weight=exp(HComplex(0.0,hPhase(*freq,hGeometricDelayFarField(ant,sky,distance))));
   ++weight; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  } else {
    while (sky < sky_end && weight < weights_end) {
      distance = hNorm(sky,sky+3);
      ant=antPositions;
      while (ant < ant_end && weight < weights_end) {
 freq=frequencies;
 while (freq < frequencies_end && weight < weights_end) {
   *weight=exp(HComplex(0.0,hPhase(*freq,hGeometricDelayNearField(ant,sky,distance))));
   ++weight; ++freq;
 };
 ant+=3;
      };
      sky+=3;
    };
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hGeometricWeights( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HComplex> & weights , bool farfield) {
hGeometricWeights ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , weights.begin(),weights.end() , farfield);
}

inline void hGeometricWeights( casa::Vector<HNumber> & frequencies , casa::Vector<HNumber> & antPositions , casa::Vector<HNumber> & skyPositions , casa::Vector<HComplex> & weights , bool farfield) {
hGeometricWeights ( frequencies.cbegin(),frequencies.cend() , antPositions.cbegin(),antPositions.cend() , skyPositions.cbegin(),skyPositions.cend() , weights.cbegin(),weights.cend() , farfield);
}

inline void hGeometricWeights( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , bool farfield) {
bool iterate=true;
while(iterate) {
hGeometricWeights ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , weights.begin(),weights.end() , farfield);
frequencies.next();
antPositions.next();
skyPositions.next();
weights.next();
iterate = frequencies.doLoopAgain();
};
}

inline void hGeometricWeights( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , vector<bool> & farfield) {
bool iterate=true;
vector< bool >::iterator farfield_iterator = farfield.begin();
while(iterate) {
hGeometricWeights ( frequencies.begin(),frequencies.end() , antPositions.begin(),antPositions.end() , skyPositions.begin(),skyPositions.end() , weights.begin(),weights.end() , *farfield_iterator);
frequencies.next();
antPositions.next();
skyPositions.next();
weights.next();
farfield_iterator++; if (farfield.end()==farfield_iterator) farfield_iterator = farfield.begin();
iterate = frequencies.doLoopAgain();
};
}


void (*fptr_hGeometricWeights_STL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , std::vector<HNumber> & antPositions , std::vector<HNumber> & skyPositions , std::vector<HComplex> & weights , bool farfield) = &hGeometricWeights;
void (*fptr_hGeometricWeights_hARRAY_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , bool farfield) = &hGeometricWeights;
void (*fptr_hGeometricWeights_hARRAYALL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( hArray<HNumber> & frequencies , hArray<HNumber> & antPositions , hArray<HNumber> & skyPositions , hArray<HComplex> & weights , vector<bool> & farfield) = &hGeometricWeights;

 inline void hGeometricWeights_hSLICED ( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) {
hGeometricWeights ( frequencies.begin() + frequenciesslice1,frequencies.begin() + frequenciesslice2 , antPositions.begin() + antPositionsslice1,antPositions.begin() + antPositionsslice2 , skyPositions.begin() + skyPositionsslice1,skyPositions.begin() + skyPositionsslice2 , weights.begin() + weightsslice1,weights.begin() + weightsslice2 , farfield);
}

inline void hGeometricWeights_hSLICED ( casa::Vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , casa::Vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , casa::Vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , casa::Vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) {
hGeometricWeights ( frequencies.cbegin() + frequenciesslice1,frequencies.cbegin() + frequenciesslice2 , antPositions.cbegin() + antPositionsslice1,antPositions.cbegin() + antPositionsslice2 , skyPositions.cbegin() + skyPositionsslice1,skyPositions.cbegin() + skyPositionsslice2 , weights.cbegin() + weightsslice1,weights.cbegin() + weightsslice2 , farfield);
}


void (*fptr_hGeometricWeights_hSLICED_STL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT)( std::vector<HNumber> & frequencies , HInteger frequenciesslice1 , HInteger frequenciesslice2 , std::vector<HNumber> & antPositions , HInteger antPositionsslice1 , HInteger antPositionsslice2 , std::vector<HNumber> & skyPositions , HInteger skyPositionsslice1 , HInteger skyPositionsslice2 , std::vector<HComplex> & weights , HInteger weightsslice1 , HInteger weightsslice2 , bool farfield ) = &hGeometricWeights_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!

  \brief Calculates the power of a complex spectrum and add it to an output vector.

    \param vec: Numeric input vector

    \param outvec: Vector containing a copy of the input values converted to a new type


  The fact that the result is added to the output vector allows one to
  call the function multiple times and get a summed spectrum. If you
  need it only once, just fill the vector with zeros.
*/
template <class Iterin, class Iter>
void hSpectralPower(const Iterin vec,const Iterin vec_end, const Iter out,const Iter out_end)
{
  Iterin it(vec);
  Iter itout(out);
  while ((it!=vec_end) && (itout !=out_end)) {
    *itout+=real((*it)*conj(*it));
    ++it; ++itout;
  };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hSpectralPower( std::vector<HComplex> & vec , std::vector<HNumber> & outvec) {
hSpectralPower ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
}

inline void hSpectralPower( casa::Vector<HComplex> & vec , casa::Vector<HNumber> & outvec) {
hSpectralPower ( vec.cbegin(),vec.cend() , outvec.cbegin(),outvec.cend());
}

inline void hSpectralPower( hArray<HComplex> & vec , hArray<HNumber> & outvec) {
bool iterate=true;
while(iterate) {
hSpectralPower ( vec.begin(),vec.end() , outvec.begin(),outvec.end());
vec.next();
outvec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hSpectralPower_STL_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , std::vector<HNumber> & outvec) = &hSpectralPower;
void (*fptr_hSpectralPower_hARRAY_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT)( hArray<HComplex> & vec , hArray<HNumber> & outvec) = &hSpectralPower;

 inline void hSpectralPower_hSLICED ( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hSpectralPower ( vec.begin() + vecslice1,vec.begin() + vecslice2 , outvec.begin() + outvecslice1,outvec.begin() + outvecslice2);
}

inline void hSpectralPower_hSLICED ( casa::Vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , casa::Vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) {
hSpectralPower ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , outvec.cbegin() + outvecslice1,outvec.cbegin() + outvecslice2);
}


void (*fptr_hSpectralPower_hSLICED_STL_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , std::vector<HNumber> & outvec , HInteger outvecslice1 , HInteger outvecslice2) = &hSpectralPower_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
  \brief Convert the ADC value to a voltage.

    \param vec: Numeric input and output vector

    \param adc2voltage: Scaling factor if the gain

*/
template <class Iter>
void hADC2Voltage(const Iter vec, const Iter vec_end, const HNumber adc2voltage) {
  Iter it = vec;
  while(it != vec_end) {
    *it *= adc2voltage;
    it++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hADC2Voltage( std::vector<T> & vec , HNumber adc2voltage) {
hADC2Voltage ( vec.begin(),vec.end() , adc2voltage);
}

template < class T > inline void hADC2Voltage( casa::Vector<T> & vec , HNumber adc2voltage) {
hADC2Voltage ( vec.cbegin(),vec.cend() , adc2voltage);
}

template < class T > inline void hADC2Voltage( hArray<T> & vec , HNumber adc2voltage) {
bool iterate=true;
while(iterate) {
hADC2Voltage ( vec.begin(),vec.end() , adc2voltage);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hADC2Voltage( hArray<T> & vec , vector<HNumber> & adc2voltage) {
bool iterate=true;
vector< HNumber >::iterator adc2voltage_iterator = adc2voltage.begin();
while(iterate) {
hADC2Voltage ( vec.begin(),vec.end() , *adc2voltage_iterator);
vec.next();
adc2voltage_iterator++; if (adc2voltage.end()==adc2voltage_iterator) adc2voltage_iterator = adc2voltage.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hADC2Voltage_STL_HComplex_vecadc2voltage_1HNumber_STDIT)( std::vector<HComplex> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HComplex_vecadc2voltage_1HNumber_STDIT)( hArray<HComplex> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAYALL_HComplex_vecadc2voltage_1HNumber_STDIT)( hArray<HComplex> & vec , vector<HNumber> & adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_STL_HNumber_vecadc2voltage_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HNumber_vecadc2voltage_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAYALL_HNumber_vecadc2voltage_1HNumber_STDIT)( hArray<HNumber> & vec , vector<HNumber> & adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_STL_HInteger_vecadc2voltage_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAY_HInteger_vecadc2voltage_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber adc2voltage) = &hADC2Voltage;
void (*fptr_hADC2Voltage_hARRAYALL_HInteger_vecadc2voltage_1HNumber_STDIT)( hArray<HInteger> & vec , vector<HNumber> & adc2voltage) = &hADC2Voltage;

template < class T > inline void hADC2Voltage_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) {
hADC2Voltage ( vec.begin() + vecslice1,vec.begin() + vecslice2 , adc2voltage);
}

template < class T > inline void hADC2Voltage_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) {
hADC2Voltage ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , adc2voltage);
}


void (*fptr_hADC2Voltage_hSLICED_STL_HComplex_vecadc2voltage_1HNumber_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;
void (*fptr_hADC2Voltage_hSLICED_STL_HNumber_vecadc2voltage_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;
void (*fptr_hADC2Voltage_hSLICED_STL_HInteger_vecadc2voltage_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber adc2voltage ) = &hADC2Voltage_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

    \param Beta: Width parameter of Hanning function

    \param BetaRise: Rising slope parameter of Hanning function

    \param BetaFall: Falling slope parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha,
         const uint Beta,
         const uint BetaRise,
         const uint BetaFall) {
  uint blocksize = vec_end - vec;
  CR::HanningFilter<HNumber> hanning_filter(blocksize, Alpha, Beta, BetaRise, BetaFall);
  Iter it_v = vec;
  casa::Vector<HNumber> filter = hanning_filter.weights();
  casa::Vector<HNumber>::iterator it_f = filter.begin();
  while ((it_v != vec_end) && (it_f != filter.end())) {
    *it_v = (typename Iter::value_type) *it_f;
    it_v++; it_f++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta , BetaRise , BetaFall);
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha , Beta , BetaRise , BetaFall);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta , BetaRise , BetaFall);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , vector<HNumber> & Alpha , vector<uint> & Beta , vector<uint> & BetaRise , vector<uint> & BetaFall) {
bool iterate=true;
vector< HNumber >::iterator Alpha_iterator = Alpha.begin();
vector< uint >::iterator Beta_iterator = Beta.begin();
vector< uint >::iterator BetaRise_iterator = BetaRise.begin();
vector< uint >::iterator BetaFall_iterator = BetaFall.begin();
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , *Alpha_iterator , *Beta_iterator , *BetaRise_iterator , *BetaFall_iterator);
vec.next();
Alpha_iterator++; if (Alpha.end()==Alpha_iterator) Alpha_iterator = Alpha.begin();
Beta_iterator++; if (Beta.end()==Beta_iterator) Beta_iterator = Beta.begin();
BetaRise_iterator++; if (BetaRise.end()==BetaRise_iterator) BetaRise_iterator = BetaRise.begin();
BetaFall_iterator++; if (BetaFall.end()==BetaFall_iterator) BetaFall_iterator = BetaFall.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hGetHanningFilter_STL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HComplex> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HComplex> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HComplex> & vec , vector<HNumber> & Alpha , vector<uint> & Beta , vector<uint> & BetaRise , vector<uint> & BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HNumber> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HNumber> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HNumber> & vec , vector<HNumber> & Alpha , vector<uint> & Beta , vector<uint> & BetaRise , vector<uint> & BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HInteger> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HInteger> & vec , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( hArray<HInteger> & vec , vector<HNumber> & Alpha , vector<uint> & Beta , vector<uint> & BetaRise , vector<uint> & BetaFall) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha , Beta , BetaRise , BetaFall);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha , Beta , BetaRise , BetaFall);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta , uint BetaRise , uint BetaFall ) = &hGetHanningFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

    \param Beta: Width parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha,
         const uint Beta) {
  uint blocksize = vec_end - vec;
  uint BetaRise = (blocksize - Beta)/2;
  uint BetaFall = (blocksize - Beta)/2;
  hGetHanningFilter(vec, vec_end, Alpha, Beta, BetaRise, BetaFall);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha , uint Beta) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta);
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha , uint Beta) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha , Beta);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha , uint Beta) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha , Beta);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , vector<HNumber> & Alpha , vector<uint> & Beta) {
bool iterate=true;
vector< HNumber >::iterator Alpha_iterator = Alpha.begin();
vector< uint >::iterator Beta_iterator = Beta.begin();
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , *Alpha_iterator , *Beta_iterator);
vec.next();
Alpha_iterator++; if (Alpha.end()==Alpha_iterator) Alpha_iterator = Alpha.begin();
Beta_iterator++; if (Beta.end()==Beta_iterator) Beta_iterator = Beta.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hGetHanningFilter_STL_HComplex_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HComplex> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HComplex> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HComplex> & vec , vector<HNumber> & Alpha , vector<uint> & Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HNumber> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HNumber> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HNumber> & vec , vector<HNumber> & Alpha , vector<uint> & Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HInteger> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HInteger> & vec , HNumber Alpha , uint Beta) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlphaBeta_1HNumberuint_STDIT)( hArray<HInteger> & vec , vector<HNumber> & Alpha , vector<uint> & Beta) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha , Beta);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha , Beta);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlphaBeta_1HNumberuint_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha , uint Beta ) = &hGetHanningFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

    \param Alpha: Height parameter of Hanning function

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end,
         const double Alpha) {
  uint Beta = 0;
  hGetHanningFilter(vec, vec_end, Alpha, Beta);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec , HNumber Alpha) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha);
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec , HNumber Alpha) {
hGetHanningFilter ( vec.cbegin(),vec.cend() , Alpha);
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , HNumber Alpha) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , Alpha);
vec.next();
iterate = vec.doLoopAgain();
};
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec , vector<HNumber> & Alpha) {
bool iterate=true;
vector< HNumber >::iterator Alpha_iterator = Alpha.begin();
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end() , *Alpha_iterator);
vec.next();
Alpha_iterator++; if (Alpha.end()==Alpha_iterator) Alpha_iterator = Alpha.begin();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hGetHanningFilter_STL_HComplex_vecAlpha_1HNumber_STDIT)( std::vector<HComplex> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_vecAlpha_1HNumber_STDIT)( hArray<HComplex> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlpha_1HNumber_STDIT)( hArray<HComplex> & vec , vector<HNumber> & Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_vecAlpha_1HNumber_STDIT)( std::vector<HNumber> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_vecAlpha_1HNumber_STDIT)( hArray<HNumber> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlpha_1HNumber_STDIT)( hArray<HNumber> & vec , vector<HNumber> & Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_vecAlpha_1HNumber_STDIT)( std::vector<HInteger> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_vecAlpha_1HNumber_STDIT)( hArray<HInteger> & vec , HNumber Alpha) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlpha_1HNumber_STDIT)( hArray<HInteger> & vec , vector<HNumber> & Alpha) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2 , Alpha);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2 , Alpha);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlpha_1HNumber_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlpha_1HNumber_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlpha_1HNumber_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2 , HNumber Alpha ) = &hGetHanningFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Create a Hanning filter.

    \param vec: Return vector containing Hanning filter

*/
template <class Iter>
void hGetHanningFilter(const Iter vec, const Iter vec_end){
  double Alpha = 0.5;
  hGetHanningFilter(vec, vec_end, Alpha);
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hGetHanningFilter( std::vector<T> & vec) {
hGetHanningFilter ( vec.begin(),vec.end());
}

template < class T > inline void hGetHanningFilter( casa::Vector<T> & vec) {
hGetHanningFilter ( vec.cbegin(),vec.cend());
}

template < class T > inline void hGetHanningFilter( hArray<T> & vec) {
bool iterate=true;
while(iterate) {
hGetHanningFilter ( vec.begin(),vec.end());
vec.next();
iterate = vec.doLoopAgain();
};
}


void (*fptr_hGetHanningFilter_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HComplex_vec_1_STDIT)( hArray<HComplex> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HNumber_vec_1_STDIT)( hArray<HNumber> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec) = &hGetHanningFilter;
void (*fptr_hGetHanningFilter_hARRAY_HInteger_vec_1_STDIT)( hArray<HInteger> & vec) = &hGetHanningFilter;

template < class T > inline void hGetHanningFilter_hSLICED ( std::vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hGetHanningFilter ( vec.begin() + vecslice1,vec.begin() + vecslice2);
}

template < class T > inline void hGetHanningFilter_hSLICED ( casa::Vector<T> & vec , HInteger vecslice1 , HInteger vecslice2) {
hGetHanningFilter ( vec.cbegin() + vecslice1,vec.cbegin() + vecslice2);
}


void (*fptr_hGetHanningFilter_hSLICED_STL_HComplex_vec_1_STDIT)( std::vector<HComplex> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HNumber_vec_1_STDIT)( std::vector<HNumber> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;
void (*fptr_hGetHanningFilter_hSLICED_STL_HInteger_vec_1_STDIT)( std::vector<HInteger> & vec , HInteger vecslice1 , HInteger vecslice2) = &hGetHanningFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply a predefined filter on a vector.

    \param data: Vector containing the data on which the filter will be applied.

    \param filter: Vector containing the filter.

*/
template <class Iter, class IterFilter>
void hApplyFilter(const Iter data, const Iter data_end, const IterFilter filter, IterFilter filter_end){
  Iter it_d = data;
  IterFilter it_f = filter;
  while ((it_d != data_end) && (it_f != filter_end)) {
    *it_d *= (typename Iter::value_type) *it_f;
    it_d++; it_f++;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hApplyFilter( std::vector<T> & data , std::vector<T> & filter) {
hApplyFilter ( data.begin(),data.end() , filter.begin(),filter.end());
}

template < class T > inline void hApplyFilter( casa::Vector<T> & data , casa::Vector<T> & filter) {
hApplyFilter ( data.cbegin(),data.cend() , filter.cbegin(),filter.cend());
}

template < class T > inline void hApplyFilter( hArray<T> & data , hArray<T> & filter) {
bool iterate=true;
while(iterate) {
hApplyFilter ( data.begin(),data.end() , filter.begin(),filter.end());
data.next();
filter.next();
iterate = data.doLoopAgain();
};
}


void (*fptr_hApplyFilter_STL_HComplex_datafilter_11_STDITSTDIT)( std::vector<HComplex> & data , std::vector<HComplex> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HComplex_datafilter_11_STDITSTDIT)( hArray<HComplex> & data , hArray<HComplex> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_STL_HNumber_datafilter_11_STDITSTDIT)( std::vector<HNumber> & data , std::vector<HNumber> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HNumber_datafilter_11_STDITSTDIT)( hArray<HNumber> & data , hArray<HNumber> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_STL_HInteger_datafilter_11_STDITSTDIT)( std::vector<HInteger> & data , std::vector<HInteger> & filter) = &hApplyFilter;
void (*fptr_hApplyFilter_hARRAY_HInteger_datafilter_11_STDITSTDIT)( hArray<HInteger> & data , hArray<HInteger> & filter) = &hApplyFilter;

template < class T > inline void hApplyFilter_hSLICED ( std::vector<T> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<T> & filter , HInteger filterslice1 , HInteger filterslice2) {
hApplyFilter ( data.begin() + dataslice1,data.begin() + dataslice2 , filter.begin() + filterslice1,filter.begin() + filterslice2);
}

template < class T > inline void hApplyFilter_hSLICED ( casa::Vector<T> & data , HInteger dataslice1 , HInteger dataslice2 , casa::Vector<T> & filter , HInteger filterslice1 , HInteger filterslice2) {
hApplyFilter ( data.cbegin() + dataslice1,data.cbegin() + dataslice2 , filter.cbegin() + filterslice1,filter.cbegin() + filterslice2);
}


void (*fptr_hApplyFilter_hSLICED_STL_HComplex_datafilter_11_STDITSTDIT)( std::vector<HComplex> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HComplex> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;
void (*fptr_hApplyFilter_hSLICED_STL_HNumber_datafilter_11_STDITSTDIT)( std::vector<HNumber> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HNumber> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;
void (*fptr_hApplyFilter_hSLICED_STL_HInteger_datafilter_11_STDITSTDIT)( std::vector<HInteger> & data , HInteger dataslice1 , HInteger dataslice2 , std::vector<HInteger> & filter , HInteger filterslice1 , HInteger filterslice2) = &hApplyFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply a Hanning filter on a vector.

    \param data: Input and return vector containing the data on which the Hanning filter will be applied.

*/
template <class Iter>
void hApplyHanningFilter(const Iter data, const Iter data_end){
  uint blocksize = data_end - data;
  vector<HNumber> filter(blocksize);
  hGetHanningFilter(filter.begin(), filter.end());
  hApplyFilter(data, data_end, filter.begin(), filter.end());
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
template < class T > inline void hApplyHanningFilter( std::vector<T> & data) {
hApplyHanningFilter ( data.begin(),data.end());
}

template < class T > inline void hApplyHanningFilter( casa::Vector<T> & data) {
hApplyHanningFilter ( data.cbegin(),data.cend());
}

template < class T > inline void hApplyHanningFilter( hArray<T> & data) {
bool iterate=true;
while(iterate) {
hApplyHanningFilter ( data.begin(),data.end());
data.next();
iterate = data.doLoopAgain();
};
}


void (*fptr_hApplyHanningFilter_STL_HComplex_data_1_STDIT)( std::vector<HComplex> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HComplex_data_1_STDIT)( hArray<HComplex> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_STL_HNumber_data_1_STDIT)( std::vector<HNumber> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HNumber_data_1_STDIT)( hArray<HNumber> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_STL_HInteger_data_1_STDIT)( std::vector<HInteger> & data) = &hApplyHanningFilter;
void (*fptr_hApplyHanningFilter_hARRAY_HInteger_data_1_STDIT)( hArray<HInteger> & data) = &hApplyHanningFilter;

template < class T > inline void hApplyHanningFilter_hSLICED ( std::vector<T> & data , HInteger dataslice1 , HInteger dataslice2) {
hApplyHanningFilter ( data.begin() + dataslice1,data.begin() + dataslice2);
}

template < class T > inline void hApplyHanningFilter_hSLICED ( casa::Vector<T> & data , HInteger dataslice1 , HInteger dataslice2) {
hApplyHanningFilter ( data.cbegin() + dataslice1,data.cbegin() + dataslice2);
}


void (*fptr_hApplyHanningFilter_hSLICED_STL_HComplex_data_1_STDIT)( std::vector<HComplex> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;
void (*fptr_hApplyHanningFilter_hSLICED_STL_HNumber_data_1_STDIT)( std::vector<HNumber> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;
void (*fptr_hApplyHanningFilter_hSLICED_STL_HInteger_data_1_STDIT)( std::vector<HInteger> & data , HInteger dataslice1 , HInteger dataslice2) = &hApplyHanningFilter_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply an FFT on a vector.

    \param data_in: Vector containing the data on which the FFT will be applied.

    \param data_out: Return vector in which the FFT transformed data is stored.

    \param nyquistZone: Nyquist zone

*/
template <class IterIn, class IterOut>
void hFFT(const IterIn data_in, const IterIn data_in_end,
      const IterOut data_out, const IterOut data_out_end,
      const HInteger nyquistZone) {
  uint channel;
  uint blocksize(data_in_end - data_in);
  uint fftLength(blocksize/2+1);
  uint nofChannels(fftLength);
  IPosition shape_in(1,blocksize);
  IPosition shape_out(1,fftLength);
  FFTServer<Double,DComplex> fftserver(shape_in, FFTEnums::REALTOCOMPLEX);
  //  Vector<Double> cvec_in(shape_in, reinterpret_cast<Double*>(&(*data_in)), casa::SHARE);
  Vector<Double> cvec_in(shape_in, 0.);
  Vector<DComplex> cvec_out(shape_out, 0.);
  IterIn it_in = data_in;
  IterOut it_out = data_out;
  Vector<Double>::iterator it_vin=cvec_in.begin();
  // make copy of input vector since fft will also modify the order of the input data.
  while ((it_in != data_in_end) && (it_vin != cvec_in.end())) {
    *it_vin = *it_in;
    it_in++; it_vin++;
  }
  // Apply FFT
  fftserver.fft(cvec_out, cvec_in);
  // Is there some aftercare needed (checking/setting the size of the in/output vector)
  switch (nyquistZone) {
  case 1:
  case 3:
  case 5:
    {
      it_out = data_out;
      channel = 0;
      while ((it_out != data_out_end) && (channel < nofChannels)) {
 *it_out = cvec_out(channel);
 it_out++; channel++;
      }
    }
    break;
  case 2:
  case 4:
  case 6:
    {
      /// See datareader for implementation.
      it_out = data_out;
      channel = 0;
      while ((it_out != data_out_end) && (channel < nofChannels)) {
 *it_out = conj(cvec_out(fftLength - channel - 1));
 it_out++; channel++;
      }
    }
    break;
  }
  /// TODO: Check if output is correct.
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hFFT( std::vector<HNumber> & data_in , std::vector<HComplex> & data_out , HInteger nyquistZone) {
hFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
}

inline void hFFT( casa::Vector<HNumber> & data_in , casa::Vector<HComplex> & data_out , HInteger nyquistZone) {
hFFT ( data_in.cbegin(),data_in.cend() , data_out.cbegin(),data_out.cend() , nyquistZone);
}

inline void hFFT( hArray<HNumber> & data_in , hArray<HComplex> & data_out , HInteger nyquistZone) {
bool iterate=true;
while(iterate) {
hFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
data_in.next();
data_out.next();
iterate = data_in.doLoopAgain();
};
}

inline void hFFT( hArray<HNumber> & data_in , hArray<HComplex> & data_out , vector<HInteger> & nyquistZone) {
bool iterate=true;
vector< HInteger >::iterator nyquistZone_iterator = nyquistZone.begin();
while(iterate) {
hFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , *nyquistZone_iterator);
data_in.next();
data_out.next();
nyquistZone_iterator++; if (nyquistZone.end()==nyquistZone_iterator) nyquistZone_iterator = nyquistZone.begin();
iterate = data_in.doLoopAgain();
};
}


void (*fptr_hFFT_STL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT)( std::vector<HNumber> & data_in , std::vector<HComplex> & data_out , HInteger nyquistZone) = &hFFT;
void (*fptr_hFFT_hARRAY_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT)( hArray<HNumber> & data_in , hArray<HComplex> & data_out , HInteger nyquistZone) = &hFFT;
void (*fptr_hFFT_hARRAYALL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT)( hArray<HNumber> & data_in , hArray<HComplex> & data_out , vector<HInteger> & nyquistZone) = &hFFT;

 inline void hFFT_hSLICED ( std::vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hFFT ( data_in.begin() + data_inslice1,data_in.begin() + data_inslice2 , data_out.begin() + data_outslice1,data_out.begin() + data_outslice2 , nyquistZone);
}

inline void hFFT_hSLICED ( casa::Vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , casa::Vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hFFT ( data_in.cbegin() + data_inslice1,data_in.cbegin() + data_inslice2 , data_out.cbegin() + data_outslice1,data_out.cbegin() + data_outslice2 , nyquistZone);
}


void (*fptr_hFFT_hSLICED_STL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT)( std::vector<HNumber> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HComplex> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) = &hFFT_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
  \brief Apply an Inverse FFT on a vector.

    \param data_in: Vector containing the input data on which the inverse FFT will be applied.

    \param data_out: Return vector in which the inverse FFT transformed data is stored.

    \param nyquistZone: Nyquist zone

*/
template <class IterIn, class IterOut>
void hInvFFT(const IterIn data_in, const IterIn data_in_end,
      const IterOut data_out, const IterOut data_out_end,
      const HInteger nyquistZone) {
  uint channel;
  uint blocksize(data_out_end - data_out);
  uint fftLength(blocksize/2+1);
  uint nofChannels(fftLength);
  IPosition shape_in(1,fftLength);
  IPosition shape_out(1,blocksize);
  Vector<DComplex> cvec_f(shape_in, reinterpret_cast<DComplex*>(&(*data_in)), casa::SHARE);
  Vector<DComplex> cvec_in(fftLength);
  Vector<Double> cvec_out(shape_out, 0.);
  if ((data_in_end - data_in) != (int)fftLength) {
    cerr << "[invfft] Bad input: len(data_in) != fftLength" << endl;
    cerr << "  len(data_in) = " << (data_in_end - data_in) << endl;
    cerr << "  fftLength    = " << fftLength << endl;
  };
  try {
    FFTServer<Double,DComplex> server(shape_out,
          FFTEnums::REALTOCOMPLEX);
    switch (nyquistZone) {
    case 1:
    case 3:
      for (channel=0; channel<nofChannels; channel++) {
    cvec_in(channel) = cvec_f(channel);
      }
      break;
    case 2:
      for (channel=0; channel<nofChannels; channel++) {
   cvec_in(channel) = conj(cvec_f(fftLength - channel - 1));
      }
      break;
    }
    server.fft(cvec_out,cvec_in);
    // Copy result back to data_out
    Vector<Double>::iterator it_vout= cvec_out.begin();
    IterOut it_dout = data_out;
    while ((it_vout != cvec_out.end()) && (it_dout != data_out_end)) {
      *it_dout = *it_vout;
      it_vout++; it_dout++;
    }
  } catch (AipsError x) {
    cerr << "[invfft]" << x.getMesg() << endl;
  }
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline void hInvFFT( std::vector<HComplex> & data_in , std::vector<HNumber> & data_out , HInteger nyquistZone) {
hInvFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
}

inline void hInvFFT( casa::Vector<HComplex> & data_in , casa::Vector<HNumber> & data_out , HInteger nyquistZone) {
hInvFFT ( data_in.cbegin(),data_in.cend() , data_out.cbegin(),data_out.cend() , nyquistZone);
}

inline void hInvFFT( hArray<HComplex> & data_in , hArray<HNumber> & data_out , HInteger nyquistZone) {
bool iterate=true;
while(iterate) {
hInvFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , nyquistZone);
data_in.next();
data_out.next();
iterate = data_in.doLoopAgain();
};
}

inline void hInvFFT( hArray<HComplex> & data_in , hArray<HNumber> & data_out , vector<HInteger> & nyquistZone) {
bool iterate=true;
vector< HInteger >::iterator nyquistZone_iterator = nyquistZone.begin();
while(iterate) {
hInvFFT ( data_in.begin(),data_in.end() , data_out.begin(),data_out.end() , *nyquistZone_iterator);
data_in.next();
data_out.next();
nyquistZone_iterator++; if (nyquistZone.end()==nyquistZone_iterator) nyquistZone_iterator = nyquistZone.begin();
iterate = data_in.doLoopAgain();
};
}


void (*fptr_hInvFFT_STL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT)( std::vector<HComplex> & data_in , std::vector<HNumber> & data_out , HInteger nyquistZone) = &hInvFFT;
void (*fptr_hInvFFT_hARRAY_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT)( hArray<HComplex> & data_in , hArray<HNumber> & data_out , HInteger nyquistZone) = &hInvFFT;
void (*fptr_hInvFFT_hARRAYALL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT)( hArray<HComplex> & data_in , hArray<HNumber> & data_out , vector<HInteger> & nyquistZone) = &hInvFFT;

 inline void hInvFFT_hSLICED ( std::vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hInvFFT ( data_in.begin() + data_inslice1,data_in.begin() + data_inslice2 , data_out.begin() + data_outslice1,data_out.begin() + data_outslice2 , nyquistZone);
}

inline void hInvFFT_hSLICED ( casa::Vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , casa::Vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) {
hInvFFT ( data_in.cbegin() + data_inslice1,data_in.cbegin() + data_inslice2 , data_out.cbegin() + data_outslice1,data_out.cbegin() + data_outslice2 , nyquistZone);
}


void (*fptr_hInvFFT_hSLICED_STL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT)( std::vector<HComplex> & data_in , HInteger data_inslice1 , HInteger data_inslice2 , std::vector<HNumber> & data_out , HInteger data_outslice1 , HInteger data_outslice2 , HInteger nyquistZone ) = &hInvFFT_hSLICED;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:              I/O Function (DataReader)
//========================================================================
//------------------------------------------------------------------------
/*!
 \brief Print a brief summary of the file contents and current settings.

    \param dr: DataReader object

*/
void hFileSummary(CRDataReader & dr) {
  dr.summary();
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hFileSummary_STL_HInteger_dr_CRDataReader_)( CRDataReader & dr) = &hFileSummary;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
/*!
 \brief Function to open a file based on a filename and returning a datareader object.

    \param Filename: Filename of file to opwn including full directory name

*/
CRDataReader & hFileOpen(HString Filename) {
  bool opened;
  //Create the a pointer to the DataReader object and store the pointer
  CR::DataReader* drp;
  HString Filetype = hgetFiletype(Filename);
  if (Filetype=="LOPESEvent") {
    CR::LopesEventIn* lep = new CR::LopesEventIn;
    opened=lep->attachFile(Filename);
    drp=lep;
    cout << "Opening LOPES File="<<Filename<<endl; drp->summary();
  } else if (Filetype=="LOFAR_TBB") {
    drp = new CR::LOFAR_TBB(Filename,1024);
    opened=drp!=__null;
    cout << "Opening LOFAR File="<<Filename<<endl; drp->summary();
  } else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5073 << ": " << "hFileOpen" << ": Unknown Filetype = " << Filetype << ", Filename=" << Filename << endl );
    opened=false;
  }
  if (!opened){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5077 << ": " << "hFileOpen" << ": Opening file " << Filename << " failed." << endl );
    CR::LopesEventIn* lep = new CR::LopesEventIn; //Make a dummy data reader ....  
    drp=lep;
  };
  return *drp;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileOpen_STL_HInteger_Filename_HString_)( HString Filename) = &hFileOpen;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return information from a data file as a Python object.

    \param dr: Datareader object openen, e.g. with hFileOpen or crfile.

    \param keyword: Keyword ro be read out from the file metadata

*/
HPyObject hFileGetParameter(CRDataReader &dr, HString key)
{
  DataReader *drp=&dr;
  if (key== "nofAntennas") {
uint result(drp->nofAntennas ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nofSelectedChannels") {
uint result(drp->nofSelectedChannels ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nofSelectedAntennas") {
uint result(drp->nofSelectedAntennas ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "blocksize") {
uint result(drp->blocksize ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "fftLength") {
uint result(drp->fftLength ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "block") {
uint result(drp->block ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "stride") {
uint result(drp->stride ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "nyquistZone") {
uint result(drp->nyquistZone ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "sampleInterval") {
double result(drp->sampleInterval ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "referenceTime") {
double result(drp->referenceTime ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "sampleFrequency") {
double result(drp->sampleFrequency ());
HPyObject pyob((double)result);
return pyob;} else
    if (key== "nofBaselines") {
uint result(drp->nofBaselines ());
HPyObject pyob((uint)result);
return pyob;} else
    if (key== "antennas") {
casa::Vector<uint> casavec(drp->antennas ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "selectedAntennas") {
casa::Vector<uint> casavec(drp->selectedAntennas ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "selectedChannels") {
casa::Vector<uint> casavec(drp->selectedChannels ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "positions") {
casa::Vector<uint> casavec(drp->positions ());
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "increment") {
casa::Vector<double> casavec(drp->increment ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "frequencyValues") {
casa::Vector<double> casavec(drp->frequencyValues ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    if (key== "frequencyRange") {
casa::Vector<double> casavec(drp->frequencyRange ());
std::vector<HNumber> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
      if (key== "Date") {
uint result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "Observatory") {
casa::String result;
drp->headerRecord().get(key,result);
HPyObject pyob((HString)result);
return pyob;} else
 if (key== "Filesize") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "dDate") {
double result;
drp->headerRecord().get(key,result);
HPyObject pyob((double)result);
return pyob;} else
 if (key== "presync") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "TL") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "LTL") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "EventClass") {
int result;
drp->headerRecord().get(key,result);
HPyObject pyob((int)result);
return pyob;} else
 if (key== "SampleFreq") {
casa::uChar result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "StartSample") {
uint result;
drp->headerRecord().get(key,result);
HPyObject pyob((uint)result);
return pyob;} else
 if (key== "AntennaIDs") {
casa::Vector<int> casavec;
drp->headerRecord().get(key,casavec);
std::vector<HInteger> result;
aipsvec2stlvec(casavec,result);
HPyObject pyob(result);
return pyob;} else
    { HString result; result = result
  + "nofAntennas" + ", "
    + "nofSelectedChannels" + ", "
    + "nofSelectedAntennas" + ", "
    + "nofBaselines" + ", "
    + "block" + ", "
    + "blocksize" + ", "
    + "stride" + ", "
    + "fftLength" + ", "
    + "nyquistZone" + ", "
    + "sampleInterval" + ", "
    + "referenceTime" + ", "
    + "sampleFrequency" + ", "
    + "antennas" + ", "
    + "selectedAntennas" + ", "
    + "selectedChannels" + ", "
    + "positions" + ", "
    + "increment" + ", "
    + "frequencyValues" + ", "
    + "frequencyRange" + ", "
      + "Date" + ", "
 + "Observatory" + ", "
 + "Filesize" + ", "
 + "dDate" + ", "
 + "presync" + ", "
 + "TL" + ", "
 + "LTL" + ", "
 + "EventClass" + ", "
 + "SampleFreq" + ", "
 + "StartSample" + ", "
//------------------------------------------------------------------------
 + "AntennaIDs" + ", "
       + "help";
      if (key!="help") cout << "Unknown keyword " << key <<"!"<<endl;
      cout << "hFileGetParameter" << " - available keywords: "<< result <<endl;
      HPyObject pyob(result);
      return pyob;
    };
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HPyObject (*fptr_hFileGetParameter_STL_HInteger_drkeyword_CRDataReaderHString_)( CRDataReader & dr , HString keyword) = &hFileGetParameter;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
 \brief Set parameters in a data file with a Python object as input.

    \param dr: Datareader object openen, e.g. with hFileOpen or crfile.

    \param keyword: Keyword to be set in the file

    \param pyob: Input paramter

*/
CRDataReader & hFileSetParameter(CRDataReader &dr, HString key, HPyObjectPtr pyob)
{
  DataReader *drp=&dr;
  if (key== "Block") {uint input(PyInt_AsLong (pyob)); drp->setBlock (input);} else
    if (key== "Blocksize") {uint input(PyInt_AsLong (pyob)); drp->setBlocksize (input);} else
    if (key== "StartBlock") {uint input(PyInt_AsLong (pyob)); drp->setStartBlock (input);} else
    if (key== "Stride") {uint input(PyInt_AsLong (pyob)); drp->setStride (input);} else
    if (key== "SampleOffset") {uint input(PyInt_AsLong (pyob)); drp->setSampleOffset (input);} else
    if (key== "NyquistZone") {uint input(PyInt_AsLong (pyob)); drp->setNyquistZone (input);} else
    if (key== "ReferenceTime") {double input(PyFloat_AsDouble (pyob)); drp->setReferenceTime (input);} else
    if (key== "SampleFrequency") {double input(PyFloat_AsDouble (pyob)); drp->setSampleFrequency (input);} else
    if (key== "Shift") {int input(PyInt_AsLong (pyob)); drp->setShift (input);} else
    if (key=="SelectedAntennas") {
      vector<uint> stlvec(PyList2STLuIntVec(pyob));
      uint * storage = &(stlvec[0]);
      casa::IPosition shape(1,stlvec.size()); //tell casa the size of the vector
      casa::Vector<uint> casavec(shape,storage,casa::SHARE);
      drp->setSelectedAntennas(casavec);
    } else
    { HString txt; txt = txt
  + "Blocksize" + ", "
    + "StartBlock" + ", "
    + "Block" + ", "
    + "Stride" + ", "
    + "SampleOffset" + ", "
    + "NyquistZone" + ", "
    + "ReferenceTime" + ", "
    + "SampleFrequency" + ", "
    + "Shift" + ", "
    + "SelectedAntennas" + ", "
       + "help";
      if (key!="help") cout << "Unknown keyword " << key <<"!"<<endl;
      cout << "hFileSetParameter" << " - available keywords: "<< txt <<endl;
    };
  return dr;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileSetParameter_STL_HInteger_drkeywordpyob_CRDataReaderHStringHPyObjectPtr_)( CRDataReader & dr , HString keyword , HPyObjectPtr pyob) = &hFileSetParameter;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//-----------------------------------------------------------------------
/*!
 \brief Read data from a Datareader object (pointer in iptr) into a vector, where the size should be pre-allocated.

    \param dr: Datareader object, opened e.g. with hFileOpen or crfile.

    \param Datatype: Name of the data column to be retrieved 

    \param vec: Data 


Example on how to use this with the Python wrapper

file=hFileOpen("data/lofar/RS307C-readfullsecond.h5")
file=hFileOpen("/Users/falcke/LOFAR/usg/data/lopes/test.event")

#offsets=IntVec()
idata=IntVec()
hReadFile(file,"Fx",idata)
hCloseFile(file)

The data will then be in the vector idata. You can covert that to a
Python list with [].extend(idata)
*/
template <class T>
CRDataReader & hFileRead(
      CRDataReader &dr,
      HString Datatype,
      std::vector<T> & vec
      )
{
  //Create a DataReader Pointer from an interger variable
  DataReader *drp=&dr;
  //Check whether it is non-NULL.
  if (drp==reinterpret_cast<HPointer>(__null)){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5291 << ": " << "hFileRead" << ": pointer to FileObject is NULL, DataReader not found." << endl );
    return dr;
  };
  //------TIME------------------------------
  if (Datatype=="Time") {
    if (typeid(vec) == typeid(vector<double>)) {
      std::vector<double> * vec_p;
      vec_p=reinterpret_cast<vector<double>*>(&vec); //That is just a trick to fool the compiler
      drp->timeValues(*vec_p);
    } else {
      cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
    };
  //------FREQUENCY------------------------------
  } else if (Datatype=="Frequency") {
    if (typeid(vec) == typeid(vector<double>)) {
    casa::Vector<double> val = drp->frequencyValues();
    aipsvec2stlvec(val,vec);
    } else {
      cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
    };
  }
//..........................................................................................
//Conversion from aips to stl using shared memory space
//..........................................................................................
//..........................................................................................
  //------FX------------------------------
  else if (Datatype=="Fx") {if (typeid(vec)==typeid(std::vector<HNumber>)) {
casa::IPosition shape(2);
shape(0)=drp->blocksize (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<double> casamtrx(shape,reinterpret_cast<double*>(&(vec[0])),casa::SHARE);
drp->fx (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------VOLTAGE------------------------------
  else if (Datatype=="Voltage") {if (typeid(vec)==typeid(std::vector<HNumber>)) {
casa::IPosition shape(2);
shape(0)=drp->blocksize (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<double> casamtrx(shape,reinterpret_cast<double*>(&(vec[0])),casa::SHARE);
drp->voltage (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------FFT------------------------------
  else if (Datatype=="FFT") {if (typeid(vec)==typeid(std::vector<HComplex>)) {
casa::IPosition shape(2);
shape(0)=drp->fftLength (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<CasaComplex> casamtrx(shape,reinterpret_cast<CasaComplex*>(&(vec[0])),casa::SHARE);
drp->fft (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  //------CALFFT------------------------------
  else if (Datatype=="CalFFT") {if (typeid(vec)==typeid(std::vector<HComplex>)) {
casa::IPosition shape(2);
shape(0)=drp->fftLength (); shape(1)=drp->nofSelectedAntennas();
casa::Matrix<CasaComplex> casamtrx(shape,reinterpret_cast<CasaComplex*>(&(vec[0])),casa::SHARE);
drp->calfft (casamtrx);
} else {
cout << "hFileRead" << ": Datatype " << typeid(vec).name() << " not supported for data field = " << Datatype << "." <<endl;
};}
  else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5336 << ": " << "hFileRead" << ": Datatype=" << Datatype << " is unknown." << endl );
    vec.clear();
  };
  return dr;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

CRDataReader & (*fptr_hFileRead_STL_HComplex_drDatatypevec_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HComplex> & vec) = &hFileRead;
CRDataReader & (*fptr_hFileRead_STL_HNumber_drDatatypevec_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HNumber> & vec) = &hFileRead;
CRDataReader & (*fptr_hFileRead_STL_HInteger_drDatatypevec_CRDataReaderHString1_STL)( CRDataReader & dr , HString Datatype , std::vector<HInteger> & vec) = &hFileRead;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
/*!
 \brief Return a list of antenna positions from the CalTables - this is a test.

    \param filename: Filename of the caltable

    \param keyword: Keyword to be read out from the file metadata 

    \param date: Date for which the information is requested

    \param pyob: 


Example:
antennaIDs=hFileGetParameter(file,"AntennaIDs")
x=hCalTable("~/LOFAR/usg/data/lopes/LOPES-CalTable",obsdate,list(antennaIDs))

*/
HPyObjectPtr hCalTable(HString filename, HString keyword, HInteger date, HPyObjectPtr pyob) {
  CR::CalTableReader* CTRead = new CR::CalTableReader(filename);
  HInteger i,ant,size;
  casa::Vector<Double> tmpvec;
  HPyObjectPtr list=PyList_New(0),tuple;
  if (CTRead != __null && ((((((PyObject*)(pyob))->ob_type))->tp_flags & ((1L<<25))) != 0)) { //Check if CalTable was opened ... and Python object is a list
    size=PyList_Size(pyob);
    for (i=0;i<size;++i){ //loop over all antennas
      ant=PyInt_AsLong(PyList_GetItem(pyob,i)); //Get the ith element of the list, i.e. the antenna ID
      CTRead->GetData((uint)date, ant, keyword, &tmpvec);
      tuple=PyTuple_Pack(3,PyFloat_FromDouble(tmpvec[0]),PyFloat_FromDouble(tmpvec[1]),PyFloat_FromDouble(tmpvec[2]));
      PyList_Append(list,tuple);
    };
  };
  return list;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

HPyObjectPtr (*fptr_hCalTable_STL_HInteger_filenamekeyworddatepyob_HStringHStringHIntegerHPyObjectPtr_)( HString filename , HString keyword , HInteger date , HPyObjectPtr pyob) = &hCalTable;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//
//========================================================================
//$SECTION:      Coordinate Conversion (VectorConversion.cc)
//========================================================================
//$ORIGIN: Math/VectorConversion.cc
//-----------------------------------------------------------------------
/*!
  \brief Converts a 3D spatial vector into a different Coordinate type (e.g. Spherical to Cartesian).

    \param source: Coordinates of the source to be converted - vector of length 3

    \param sourceCoordinate: Type of the coordinates for the source

    \param target: Coordinates of the source to be converted - vector of length 3

    \param targetCoordinate: Type of the coordinates for the target 

    \param anglesInDegrees: True if the angles are in degree, otherwise in radians


Available Coordinate Types are:

      -  Azimuth-Elevation-Height, \f$ \vec x = (Az,El,H) \f$
      AzElHeight,
      -  Azimuth-Elevation-Radius, \f$ \vec x = (Az,El,R) \f$
      AzElRadius,
      -  Cartesian coordinates, \f$ \vec x = (x,y,z) \f$
      Cartesian,
      -  Cylindrical coordinates, \f$ \vec x = (r,\phi,h) \f$
      Cylindrical,
      -  Direction on the sky, \f$ \vec x = (Lon,Lat) \f$
      Direction,
      -  Direction on the sky with radial distance, \f$ \vec x = (Lon,Lat,R) \f$
      DirectionRadius,
      -  Frquency
      Frequency,
      -  Longitude-Latitude-Radius
      LongLatRadius,
      -  North-East-Height
      NorthEastHeight,
      -  Spherical coordinates, \f$ \vec x = (r,\phi,\theta) \f$
      Spherical,
      - Time
      Time
*/
template <class Iter>
bool hCoordinateConvert (Iter source,
      CR::CoordinateType::Types const &sourceCoordinate,
      Iter target,
      CR::CoordinateType::Types const &targetCoordinate,
      bool anglesInDegrees
      )
{
  return CR::convertVector(
      *target,
      *(target+1),
      *(target+2),
      targetCoordinate,
      *source,
      *(source+1),
      *(source+2),
      sourceCoordinate,
      anglesInDegrees
          );
    }
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers
 inline bool hCoordinateConvert( std::vector<HNumber> & source , CRCoordinateType sourceCoordinate , std::vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
return hCoordinateConvert ( source.begin() , sourceCoordinate , target.begin() , targetCoordinate , anglesInDegrees);
}

inline bool hCoordinateConvert( casa::Vector<HNumber> & source , CRCoordinateType sourceCoordinate , casa::Vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
return hCoordinateConvert ( source.cbegin() , sourceCoordinate , target.cbegin() , targetCoordinate , anglesInDegrees);
}

inline vector<bool> hCoordinateConvert( hArray<HNumber> & source , CRCoordinateType sourceCoordinate , hArray<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) {
bool iterate=true;
vector<bool> returnvector;
bool returnvalue;
while(iterate) {
returnvalue = hCoordinateConvert ( source.begin() , sourceCoordinate , target.begin() , targetCoordinate , anglesInDegrees);
source.next();
target.next();
iterate = source.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}

inline vector<bool> hCoordinateConvert( hArray<HNumber> & source , vector<CRCoordinateType> & sourceCoordinate , hArray<HNumber> & target , vector<CRCoordinateType> & targetCoordinate , vector<bool> & anglesInDegrees) {
bool iterate=true;
vector<bool> returnvector;
bool returnvalue;
vector< CRCoordinateType >::iterator sourceCoordinate_iterator = sourceCoordinate.begin();
vector< CRCoordinateType >::iterator targetCoordinate_iterator = targetCoordinate.begin();
vector< bool >::iterator anglesInDegrees_iterator = anglesInDegrees.begin();
while(iterate) {
returnvalue = hCoordinateConvert ( source.begin() , *sourceCoordinate_iterator , target.begin() , *targetCoordinate_iterator , *anglesInDegrees_iterator);
source.next();
sourceCoordinate_iterator++; if (sourceCoordinate.end()==sourceCoordinate_iterator) sourceCoordinate_iterator = sourceCoordinate.begin();
target.next();
targetCoordinate_iterator++; if (targetCoordinate.end()==targetCoordinate_iterator) targetCoordinate_iterator = targetCoordinate.begin();
anglesInDegrees_iterator++; if (anglesInDegrees.end()==anglesInDegrees_iterator) anglesInDegrees_iterator = anglesInDegrees.begin();
iterate = source.doLoopAgain();
returnvector.push_back(returnvalue); };
return returnvector;
}


bool (*fptr_hCoordinateConvert_STL_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED)( std::vector<HNumber> & source , CRCoordinateType sourceCoordinate , std::vector<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) = &hCoordinateConvert;
vector<bool > (*fptr_hCoordinateConvert_hARRAY_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED)( hArray<HNumber> & source , CRCoordinateType sourceCoordinate , hArray<HNumber> & target , CRCoordinateType targetCoordinate , bool anglesInDegrees) = &hCoordinateConvert;
vector<bool > (*fptr_hCoordinateConvert_hARRAYALL_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED)( hArray<HNumber> & source , vector<CRCoordinateType> & sourceCoordinate , hArray<HNumber> & target , vector<CRCoordinateType> & targetCoordinate , vector<bool> & anglesInDegrees) = &hCoordinateConvert;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//========================================================================================
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//========================================================================================
//-----------------------------------------------------------------------
//#define HFPP_PARDEF_8 (HInteger)(Offsets)()("Offsets per antenna")(HFPP_PAR_IS_VECTOR)(STL)(HFPP_PASS_AS_REFERENCE)
/*!
 \brief Read data from a Datareader object (pointer in iptr) into a vector.

    \param vec: Data 

    \param iptr: Integer containing pointer to the datareader object

    \param Datatype: Name of the data column to be retrieved 

    \param Antenna: Antenna number

    \param Blocksize: Length of the data block to read

    \param Block: Block number to read

    \param Stride: Stride between blocks

    \param Shift: Shift start of first block by n samples


Example on how to use this with the Python wrapper

file=hOpenFile("data/lofar/RS307C-readfullsecond.h5")
file=hOpenFile("/Users/falcke/LOFAR/usg/data/lopes/test.event")

#offsets=IntVec()
data=FloatVec()
idata=IntVec()
cdata=ComplexVec()
sdata=StringVec()
Datatype="Fx"
Antenna=1
Blocksize=1024
Block=10
Stride=0
Shift=0
hReadFile(idata,file,Datatype,Antenna,Blocksize,Block,Stride,Shift,offsets)
hCloseFile(file)

The data will then be in the vector idata. You can covert that to a
Python list with [].extend(idata)
*/
template <class T>
void hReadFileOld(std::vector<T> & vec,
      HIntPointer iptr,
      HString Datatype,
      HInteger Antenna,
      HInteger Blocksize,
      HInteger Block,
      HInteger Stride,
      HInteger Shift)
//	       std::vector<HInteger> & Offsets)
{
  DataReader *drp=reinterpret_cast<DataReader*>(iptr);
  //First retrieve the pointer to the pointer to the dataRead and check whether it is non-NULL.
  if (drp==reinterpret_cast<HPointer>(__null)){
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5548 << ": " << "dataRead: pointer to FileObject is NULL, DataReader not found." << endl );
    return;
  };
//!!!One Needs to verify somehow that the parameters make sense !!!
  if (Antenna > static_cast<HInteger>(drp->nofAntennas()-1)) {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5554 << ": " << "Requested Antenna number too large!" << endl );
    return;
  };
  drp->setBlocksize(Blocksize);
  drp->setBlock(Block);
  drp->setStride(Stride);
  drp->setShift(Shift);
  casa::Vector<uint> antennas(1,Antenna);
  drp->setSelectedAntennas(antennas);
  address ncol;
  if (Datatype=="Time") {
    if (typeid(vec) == typeid(vector<double>)) {
      std::vector<double> * vec_p;
      vec_p=reinterpret_cast<vector<double>*>(&vec); //That is just a tr
      drp->timeValues(*vec_p);
    } else {
      std::vector<double> tmpvec;
      drp->timeValues(tmpvec);
      hConvert(tmpvec,vec);
    };
  }
  else if (Datatype=="Frequency") {
    //vector<HNumber>* vp2; *vp2 = drp->frequencyValues().tovec();
    //    std::vector<double> vals;
    //copycast_vec(vals,vec);
    casa::Vector<double> val = drp->frequencyValues();
    aipsvec2stlvec(val,vec);
  }
  else if (Datatype=="Fx") {
//hf #define MAKE_UNION_CASA_MATRIX_AND_STLVEC(TYPECASA,STLVEC,CASAVEC) //     casa::IPosition shape(2,STLVEC.size()); shape(1)=1;	//     casa::Matrix<TYPECASA> CASAVEC(shape,reinterpret_cast<TYPECASA*>(&(STLVEC[0])),casa::SHARE)
//     if (typeid(vec)==typeid(std::vector<double>)) {
//       vec.resize(Blocksize);
//       MAKE_UNION_CASA_MATRIX_AND_STLVEC(double,vec,mtrx);
//       drp->fx(mtrx);
//     } else {
//       std::vector<double> nvec(Blocksize);
//       MAKE_UNION_CASA_MATRIX_AND_STLVEC(double,nvec,mtrx);
//       drp->fx(mtrx);
//       copycast_vec(nvec,vec); //Copy back to output vector and convert type
//     };
    casa::Matrix<CasaNumber> ary=drp->fx();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="Voltage") {
    //    std::vector<HNumber>* vp2 = new std::vector<HNumber>;
    casa::Matrix<CasaNumber> ary=drp->voltage();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="invFFT") {
    //    std::vector<HNumber>* vp2 = new std::vector<HNumber>;
    casa::Matrix<CasaNumber> ary=drp->invfft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="FFT") {
    //    std::vector<HComplex>* vp2 = new std::vector<HComplex>;
    casa::Matrix<CasaComplex> ary=drp->fft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else if (Datatype=="CalFFT") {
    //    std::vector<HComplex>* vp2 = new std::vector<HComplex>;
    casa::Matrix<CasaComplex> ary=drp->calfft();
    ncol=ary.ncolumn(); if (ncol>1 && Antenna<ncol) aipscol2stlvec(ary,vec,Antenna); else aipscol2stlvec(ary,vec,0);;
  }
  else {
    ( cout << endl << "ERROR in file " << "hftools.tmp.cc" << " line " << 5626 << ": " << "DataFunc_CR_dataRead: Datatype=" << Datatype << " is unknown." << endl );
    vec.clear();
    return;
  };
  return;
}
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

void (*fptr_hReadFileOld_STL_HComplex_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HComplex> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;
void (*fptr_hReadFileOld_STL_HNumber_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HNumber> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;
void (*fptr_hReadFileOld_STL_HInteger_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL)( std::vector<HInteger> & vec , HIntPointer iptr , HString Datatype , HInteger Antenna , HInteger Blocksize , HInteger Block , HInteger Stride , HInteger Shift) = &hReadFileOld;

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
/*
  else if (Datatype=="Fx") {aipscol2stlvec(drp->fx(),*vp,0);}
  else if (Datatype=="Voltage") {aipscol2stlvec(drp->voltage(),*vp,0);}
  else if (Datatype=="invFFT") {aipscol2stlvec(drp->invfft(),*vp,0);}
  else if (Datatype=="FFT") {aipscol2stlvec(drp->fft(),*vp,0);}
  else if (Datatype=="CalFFT") {aipscol2stlvec(drp->calfft(),*vp,0);}
*/
//       std::vector<double> tmpvec;
//       STL2CASA_SHARED(double,tmpvec,casavec); //Create casa vector sharing memory with the stl vector
//       casa::Vector<double> * vec_p;  //Get pointer to casa vector
//       vec_p=reinterpret_cast<casa::Vector<double>*>(&casavec); //That is just a trick to fool the compiler to
//                                                               //compile this section for T!=double (even though it is then never used)
//       *vec_p=drp->frequencyValues(); //read data into the casa and hence also into the stl vector
//       hConvert(tmpvec,vec);
//     }  else {   //Input vector is not of the right format
//       std::vector<double> tmpvec;  //Create temporary stl vector
//       STL2CASA_SHARED(double,tmpvec,casavec);  //Create casa vector sharing memory with the tmp stl vector
//       casavec=drp->frequencyValues(); //read data into the casa vector (hence als tmp stl vector)
//       hConvert(tmpvec,vec); // Copy and convert data from tmp stl (=casa) vector to the output vector.
//     };
//========================================================================================
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!OUTDATED!!!
//========================================================================================
////////////////////////////////////////////////////////////////////////
//Definition of Python bindings for hftools ...
////////////////////////////////////////////////////////////////////////
// Tell the preprocessor (for generating wrappers) that this is a c++
// header file for Python exposure
//BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(hArray_setDimensions_overloads,setDimensions<HNumber>,1,2)
/*
std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_1)(HInteger dim0) = &std::hArray<HNumber>::setDimensions1;
std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_2)(HInteger dim0, HInteger dim1)= &std::hArray<HNumber>::setDimensions;
*/
//std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_1)(HInteger dim0) = &std::hArray::setDimensions;
//std::hArray<HNumber>& (*fptr_hArray_setDimensions_overloads_2)(HInteger dim0, HInteger dim1) = &std::hArray::setDimensions;
void init_module_hftools(); extern "C" __attribute__ ((visibility("default"))) void inithftools() { boost::python::detail::init_module("hftools", &init_module_hftools); } void init_module_hftools()
{
    using namespace boost::python;
    class_<CR::DataReader>("DataReader")
      //      .def("read",&hFileRead) -> This is defined in pycrtools.py, since it is templated
      .def("get",&hFileGetParameter)
      .def("set",&hFileSetParameter,return_internal_reference<>())
      .def("summary",&hFileSummary)
      ;
    /*
  class_<casa::Vector<HInteger> >("CasaIntVec")
    .def(vector_indexing_suite<casa::Vector<HInteger> >())
    ;
    */
  class_<std::vector<HInteger> >("IntVec")
    .def(vector_indexing_suite<std::vector<HInteger> >())
      /*.def("thiAdd",fptr_hiAdd_HComplexHComplex12)
	.def("thiAdd",fptr_hiAdd_HComplexHNumber12)
	.def("thiAdd",fptr_hiAdd_HComplexHInteger12)
	.def("thiAdd",fptr_hiAdd_HNumberHComplex12)
	.def("thiAdd",fptr_hiAdd_HNumberHNumber12)
	.def("thiAdd",fptr_hiAdd_HNumberHInteger12)
	.def("thiAdd",fptr_hiAdd_HIntegerHComplex12)
	.def("thiAdd",fptr_hiAdd_HIntegerHNumber12)
	.def("thiAdd",fptr_hiAdd_HIntegerHInteger12)
      */
      ;
    class_<std::vector<HNumber> >("FloatVec")
        .def(vector_indexing_suite<std::vector<HNumber> >())
      ;
    class_<std::vector<bool> >("BoolVec")
        .def(vector_indexing_suite<std::vector<bool> >())
      ;
    class_<std::vector<HComplex> >("ComplexVec")
        .def(vector_indexing_suite<std::vector<HComplex> >())
      ;
    class_<std::vector<HString> >("StringVec")
        .def(vector_indexing_suite<std::vector<HString> >())
      ;
    class_<hArray<HNumber> >("FloatArray") .def("getVector",&hArray<HNumber>::getVector,return_internal_reference<>()) .def("shared_copy",&hArray<HNumber>::shared_copy,return_internal_reference<>()) .def("getDimensions",&hArray<HNumber>::getDimensions,return_internal_reference<>()) .def("getSizes",&hArray<HNumber>::getSizes,return_internal_reference<>()) .def("setVector",&hArray<HNumber>::setVector,return_internal_reference<>()) .def("setDimensions",&hArray<HNumber>::setDimensions1) .def("setDimensions",&hArray<HNumber>::setDimensions2) .def("setDimensions",&hArray<HNumber>::setDimensions3) .def("setDimensions",&hArray<HNumber>::setDimensions4) .def("setSlice",&hArray<HNumber>::setSlice,return_internal_reference<>()) .def("setSliceVector",&hArray<HNumber>::setSliceVector,return_internal_reference<>()) .def("getNumberOfDimensions",&hArray<HNumber>::getNumberOfDimensions) .def("getBegin",&hArray<HNumber>::getBegin) .def("getEnd",&hArray<HNumber>::getEnd) .def("getSize",&hArray<HNumber>::getSize) .def("loopingMode",&hArray<HNumber>::loopingMode) .def("doLoopAgain",&hArray<HNumber>::doLoopAgain) .def("loop_i",&hArray<HNumber>::getLoop_i) .def("loop_nslice",&hArray<HNumber>::getLoop_nslice) .def("loop_start",&hArray<HNumber>::getLoop_start) .def("loop_end",&hArray<HNumber>::getLoop_end) .def("loop_increment",&hArray<HNumber>::getLoop_increment) .def("__len__",&hArray<HNumber>::length) .def("resize",&hArray<HNumber>::resize,return_internal_reference<>()) .def("loop",&hArray<HNumber>::loop,return_internal_reference<>()) .def("loop",&hArray<HNumber>::loopVector,return_internal_reference<>()) .def("resetLoop",&hArray<HNumber>::resetLoop,return_internal_reference<>()) .def("noOn",&hArray<HNumber>::loopOn,return_internal_reference<>()) .def("noOff",&hArray<HNumber>::loopOff,return_internal_reference<>()) .def("next",&hArray<HNumber>::next,return_internal_reference<>());
    class_<hArray<HInteger> >("IntArray") .def("getVector",&hArray<HInteger>::getVector,return_internal_reference<>()) .def("shared_copy",&hArray<HInteger>::shared_copy,return_internal_reference<>()) .def("getDimensions",&hArray<HInteger>::getDimensions,return_internal_reference<>()) .def("getSizes",&hArray<HInteger>::getSizes,return_internal_reference<>()) .def("setVector",&hArray<HInteger>::setVector,return_internal_reference<>()) .def("setDimensions",&hArray<HInteger>::setDimensions1) .def("setDimensions",&hArray<HInteger>::setDimensions2) .def("setDimensions",&hArray<HInteger>::setDimensions3) .def("setDimensions",&hArray<HInteger>::setDimensions4) .def("setSlice",&hArray<HInteger>::setSlice,return_internal_reference<>()) .def("setSliceVector",&hArray<HInteger>::setSliceVector,return_internal_reference<>()) .def("getNumberOfDimensions",&hArray<HInteger>::getNumberOfDimensions) .def("getBegin",&hArray<HInteger>::getBegin) .def("getEnd",&hArray<HInteger>::getEnd) .def("getSize",&hArray<HInteger>::getSize) .def("loopingMode",&hArray<HInteger>::loopingMode) .def("doLoopAgain",&hArray<HInteger>::doLoopAgain) .def("loop_i",&hArray<HInteger>::getLoop_i) .def("loop_nslice",&hArray<HInteger>::getLoop_nslice) .def("loop_start",&hArray<HInteger>::getLoop_start) .def("loop_end",&hArray<HInteger>::getLoop_end) .def("loop_increment",&hArray<HInteger>::getLoop_increment) .def("__len__",&hArray<HInteger>::length) .def("resize",&hArray<HInteger>::resize,return_internal_reference<>()) .def("loop",&hArray<HInteger>::loop,return_internal_reference<>()) .def("loop",&hArray<HInteger>::loopVector,return_internal_reference<>()) .def("resetLoop",&hArray<HInteger>::resetLoop,return_internal_reference<>()) .def("noOn",&hArray<HInteger>::loopOn,return_internal_reference<>()) .def("noOff",&hArray<HInteger>::loopOff,return_internal_reference<>()) .def("next",&hArray<HInteger>::next,return_internal_reference<>());
    class_<hArray<HComplex> >("ComplexArray") .def("getVector",&hArray<HComplex>::getVector,return_internal_reference<>()) .def("shared_copy",&hArray<HComplex>::shared_copy,return_internal_reference<>()) .def("getDimensions",&hArray<HComplex>::getDimensions,return_internal_reference<>()) .def("getSizes",&hArray<HComplex>::getSizes,return_internal_reference<>()) .def("setVector",&hArray<HComplex>::setVector,return_internal_reference<>()) .def("setDimensions",&hArray<HComplex>::setDimensions1) .def("setDimensions",&hArray<HComplex>::setDimensions2) .def("setDimensions",&hArray<HComplex>::setDimensions3) .def("setDimensions",&hArray<HComplex>::setDimensions4) .def("setSlice",&hArray<HComplex>::setSlice,return_internal_reference<>()) .def("setSliceVector",&hArray<HComplex>::setSliceVector,return_internal_reference<>()) .def("getNumberOfDimensions",&hArray<HComplex>::getNumberOfDimensions) .def("getBegin",&hArray<HComplex>::getBegin) .def("getEnd",&hArray<HComplex>::getEnd) .def("getSize",&hArray<HComplex>::getSize) .def("loopingMode",&hArray<HComplex>::loopingMode) .def("doLoopAgain",&hArray<HComplex>::doLoopAgain) .def("loop_i",&hArray<HComplex>::getLoop_i) .def("loop_nslice",&hArray<HComplex>::getLoop_nslice) .def("loop_start",&hArray<HComplex>::getLoop_start) .def("loop_end",&hArray<HComplex>::getLoop_end) .def("loop_increment",&hArray<HComplex>::getLoop_increment) .def("__len__",&hArray<HComplex>::length) .def("resize",&hArray<HComplex>::resize,return_internal_reference<>()) .def("loop",&hArray<HComplex>::loop,return_internal_reference<>()) .def("loop",&hArray<HComplex>::loopVector,return_internal_reference<>()) .def("resetLoop",&hArray<HComplex>::resetLoop,return_internal_reference<>()) .def("noOn",&hArray<HComplex>::loopOn,return_internal_reference<>()) .def("noOff",&hArray<HComplex>::loopOff,return_internal_reference<>()) .def("next",&hArray<HComplex>::next,return_internal_reference<>());
    class_<hArray<HString> >("StringArray") .def("getVector",&hArray<HString>::getVector,return_internal_reference<>()) .def("shared_copy",&hArray<HString>::shared_copy,return_internal_reference<>()) .def("getDimensions",&hArray<HString>::getDimensions,return_internal_reference<>()) .def("getSizes",&hArray<HString>::getSizes,return_internal_reference<>()) .def("setVector",&hArray<HString>::setVector,return_internal_reference<>()) .def("setDimensions",&hArray<HString>::setDimensions1) .def("setDimensions",&hArray<HString>::setDimensions2) .def("setDimensions",&hArray<HString>::setDimensions3) .def("setDimensions",&hArray<HString>::setDimensions4) .def("setSlice",&hArray<HString>::setSlice,return_internal_reference<>()) .def("setSliceVector",&hArray<HString>::setSliceVector,return_internal_reference<>()) .def("getNumberOfDimensions",&hArray<HString>::getNumberOfDimensions) .def("getBegin",&hArray<HString>::getBegin) .def("getEnd",&hArray<HString>::getEnd) .def("getSize",&hArray<HString>::getSize) .def("loopingMode",&hArray<HString>::loopingMode) .def("doLoopAgain",&hArray<HString>::doLoopAgain) .def("loop_i",&hArray<HString>::getLoop_i) .def("loop_nslice",&hArray<HString>::getLoop_nslice) .def("loop_start",&hArray<HString>::getLoop_start) .def("loop_end",&hArray<HString>::getLoop_end) .def("loop_increment",&hArray<HString>::getLoop_increment) .def("__len__",&hArray<HString>::length) .def("resize",&hArray<HString>::resize,return_internal_reference<>()) .def("loop",&hArray<HString>::loop,return_internal_reference<>()) .def("loop",&hArray<HString>::loopVector,return_internal_reference<>()) .def("resetLoop",&hArray<HString>::resetLoop,return_internal_reference<>()) .def("noOn",&hArray<HString>::loopOn,return_internal_reference<>()) .def("noOff",&hArray<HString>::loopOff,return_internal_reference<>()) .def("next",&hArray<HString>::next,return_internal_reference<>());
    class_<hArray<HBool> >("BoolArray") .def("getVector",&hArray<HBool>::getVector,return_internal_reference<>()) .def("shared_copy",&hArray<HBool>::shared_copy,return_internal_reference<>()) .def("getDimensions",&hArray<HBool>::getDimensions,return_internal_reference<>()) .def("getSizes",&hArray<HBool>::getSizes,return_internal_reference<>()) .def("setVector",&hArray<HBool>::setVector,return_internal_reference<>()) .def("setDimensions",&hArray<HBool>::setDimensions1) .def("setDimensions",&hArray<HBool>::setDimensions2) .def("setDimensions",&hArray<HBool>::setDimensions3) .def("setDimensions",&hArray<HBool>::setDimensions4) .def("setSlice",&hArray<HBool>::setSlice,return_internal_reference<>()) .def("setSliceVector",&hArray<HBool>::setSliceVector,return_internal_reference<>()) .def("getNumberOfDimensions",&hArray<HBool>::getNumberOfDimensions) .def("getBegin",&hArray<HBool>::getBegin) .def("getEnd",&hArray<HBool>::getEnd) .def("getSize",&hArray<HBool>::getSize) .def("loopingMode",&hArray<HBool>::loopingMode) .def("doLoopAgain",&hArray<HBool>::doLoopAgain) .def("loop_i",&hArray<HBool>::getLoop_i) .def("loop_nslice",&hArray<HBool>::getLoop_nslice) .def("loop_start",&hArray<HBool>::getLoop_start) .def("loop_end",&hArray<HBool>::getLoop_end) .def("loop_increment",&hArray<HBool>::getLoop_increment) .def("__len__",&hArray<HBool>::length) .def("resize",&hArray<HBool>::resize,return_internal_reference<>()) .def("loop",&hArray<HBool>::loop,return_internal_reference<>()) .def("loop",&hArray<HBool>::loopVector,return_internal_reference<>()) .def("resetLoop",&hArray<HBool>::resetLoop,return_internal_reference<>()) .def("noOn",&hArray<HBool>::loopOn,return_internal_reference<>()) .def("noOff",&hArray<HBool>::loopOff,return_internal_reference<>()) .def("next",&hArray<HBool>::next,return_internal_reference<>());
    //boost::python::converter::registry::insert(&extract_swig_wrapped_pointer, type_id<mglData>());
    // def("pytointptr",getPointerFromPythonObject);
    //def("getptr", PyGetPtr);
    def("hgetFiletype",hgetFiletype);
    def("hgetFileExtension",hgetFileExtension);
    enum_<DATATYPE>("TYPE")
      .value("POINTER",POINTER)
      .value("INTEGER",INTEGER)
      .value("NUMBER", NUMBER)
      .value("COMPLEX",COMPLEX)
      .value("STRING",STRING)
      .value("BOOLEAN",BOOLEAN)
      .value("UNDEF",UNDEF);
    enum_<hWEIGHTS>("hWEIGHTS")
      .value("FLAT",WEIGHTS_FLAT)
      .value("LINEAR",WEIGHTS_LINEAR)
      .value("GAUSSIAN", WEIGHTS_GAUSSIAN);
    enum_<CR::CoordinateType::Types>("CoordinateTypes")
      //! Azimuth-Elevation-Height, \f$ \vec x = (Az,El,H) \f$
      .value("AzElHeight",CR::CoordinateType::AzElHeight)
      //! Azimuth-Elevation-Radius, \f$ \vec x = (Az,El,R) \f$
      .value("AzElRadius",CR::CoordinateType::AzElRadius)
      //! Cartesian coordinates, \f$ \vec x = (x,y,z) \f$
      .value("Cartesian",CR::CoordinateType::Cartesian)
      //! Cylindrical coordinates, \f$ \vec x = (r,\phi,h) \f$
      .value("Cylindrical",CR::CoordinateType::Cylindrical)
      //! Direction on the sky, \f$ \vec x = (Lon,Lat) \f$
      .value("Direction",CR::CoordinateType::Direction)
      //! Direction on the sky with radial distance, \f$ \vec x = (Lon,Lat,R) \f$
      .value("DirectionRadius",CR::CoordinateType::DirectionRadius)
      //! Frquency
      .value("Frequency",CR::CoordinateType::Frequency)
      //! Longitude-Latitude-Radius
      .value("LongLatRadius",CR::CoordinateType::LongLatRadius)
      //! North-East-Height
      .value("NorthEastHeight",CR::CoordinateType::NorthEastHeight)
      //! Spherical coordinates, \f$ \vec x = (r,\phi,\theta) \f$
      .value("Spherical",CR::CoordinateType::Spherical)
      //! Time
      .value("Time",CR::CoordinateType::Time);
    //The following will include the automatically generated python wrappers
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hArray_intBegin",fptr_hArray_intBegin_STL_HInteger_pyob_HPyObjectPtr_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFill",fptr_hFill_STL_HString_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HString_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAYALL_HString_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_STL_HBool_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HBool_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAYALL_HBool_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_STL_HComplex_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HComplex_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAYALL_HComplex_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_STL_HNumber_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HNumber_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAYALL_HNumber_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_STL_HInteger_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAY_HInteger_vecfill_value_11_STDIT );
def("hFill",fptr_hFill_hARRAYALL_HInteger_vecfill_value_11_STDIT );




def("hFill_sliced",fptr_hFill_hSLICED_STL_HString_vecfill_value_11_STDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HBool_vecfill_value_11_STDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HComplex_vecfill_value_11_STDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HNumber_vecfill_value_11_STDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HInteger_vecfill_value_11_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFill",fptr_hFill_STL_HString_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_hARRAY_HString_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_STL_HBool_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_hARRAY_HBool_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_STL_HComplex_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_hARRAY_HComplex_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_STL_HNumber_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_hARRAY_HNumber_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_STL_HInteger_vecfill_vec_11_STDITSTDIT );
def("hFill",fptr_hFill_hARRAY_HInteger_vecfill_vec_11_STDITSTDIT );




def("hFill_sliced",fptr_hFill_hSLICED_STL_HString_vecfill_vec_11_STDITSTDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HBool_vecfill_vec_11_STDITSTDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HComplex_vecfill_vec_11_STDITSTDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HNumber_vecfill_vec_11_STDITSTDIT );
def("hFill_sliced",fptr_hFill_hSLICED_STL_HInteger_vecfill_vec_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hNew",fptr_hNew_STL_HString_vec_1_STL );
def("hNew",fptr_hNew_STL_HBool_vec_1_STL );
def("hNew",fptr_hNew_STL_HComplex_vec_1_STL );
def("hNew",fptr_hNew_STL_HNumber_vec_1_STL );
def("hNew",fptr_hNew_STL_HInteger_vec_1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HString_vecnewsize_1HInteger_STL );
def("hResize",fptr_hResize_STL_HBool_vecnewsize_1HInteger_STL );
def("hResize",fptr_hResize_STL_HComplex_vecnewsize_1HInteger_STL );
def("hResize",fptr_hResize_STL_HNumber_vecnewsize_1HInteger_STL );
def("hResize",fptr_hResize_STL_HInteger_vecnewsize_1HInteger_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HString_vecnewsizefill_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HBool_vecnewsizefill_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HComplex_vecnewsizefill_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HNumber_vecnewsizefill_1HInteger1_STL );
def("hResize",fptr_hResize_STL_HInteger_vecnewsizefill_1HInteger1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HStringHString_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHBool_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHComplex_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHNumber_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HStringHInteger_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHString_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHBool_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHComplex_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHNumber_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HBoolHInteger_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHString_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHBool_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHComplex_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHNumber_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HComplexHInteger_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHString_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHBool_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHComplex_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHNumber_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HNumberHInteger_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHString_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHBool_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHComplex_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHNumber_vec1vec2_12_STLSTL );
def("hResize",fptr_hResize_STL_HIntegerHInteger_vec1vec2_12_STLSTL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hResize",fptr_hResize_STL_HStringHString_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHBool_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHComplex_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHNumber_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HStringHInteger_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHString_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHBool_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHComplex_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHNumber_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HBoolHInteger_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHString_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHBool_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHComplex_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHNumber_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HComplexHInteger_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHString_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHBool_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHComplex_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHNumber_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HNumberHInteger_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHString_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHBool_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHComplex_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHNumber_vec1vec2_12_CASACASA );
def("hResize",fptr_hResize_STL_HIntegerHInteger_vec1vec2_12_CASACASA );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers


def("hConvert",fptr_hConvert_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert",fptr_hConvert_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );




def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hConvert_sliced",fptr_hConvert_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCopy",fptr_hCopy_STL_HComplex_vecoutvec_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HComplex_vecoutvec_11_STDITSTDIT );
def("hCopy",fptr_hCopy_STL_HNumber_vecoutvec_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HNumber_vecoutvec_11_STDITSTDIT );
def("hCopy",fptr_hCopy_STL_HInteger_vecoutvec_11_STDITSTDIT );
def("hCopy",fptr_hCopy_hARRAY_HInteger_vecoutvec_11_STDITSTDIT );




def("hCopy_sliced",fptr_hCopy_hSLICED_STL_HComplex_vecoutvec_11_STDITSTDIT );
def("hCopy_sliced",fptr_hCopy_hSLICED_STL_HNumber_vecoutvec_11_STDITSTDIT );
def("hCopy_sliced",fptr_hCopy_hSLICED_STL_HInteger_vecoutvec_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("square",fptr_square_STL_HComplex_val_1_ );
def("square",fptr_square_STL_HNumber_val_1_ );
def("square",fptr_square_STL_HInteger_val_1_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hPhase",fptr_hPhase_STL_HInteger_frequencytime_HNumberHNumber_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("funcGaussian",fptr_funcGaussian_STL_HInteger_xsigmamu_HNumberHNumberHNumber_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hExp",fptr_hExp1_STL_HComplex_vec_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HComplex_vec_1_STDIT );
def("hExp",fptr_hExp1_STL_HNumber_vec_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HNumber_vec_1_STDIT );
def("hExp",fptr_hExp1_STL_HInteger_vec_1_STDIT );
def("hExp",fptr_hExp1_hARRAY_HInteger_vec_1_STDIT );




def("hExp_sliced",fptr_hExp_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hExp_sliced",fptr_hExp_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hExp_sliced",fptr_hExp_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hExp",fptr_hExp2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hExp",fptr_hExp2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hExp",fptr_hExp2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hExp",fptr_hExp2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hExp_sliced",fptr_hExp_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hExp_sliced",fptr_hExp_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hExp_sliced",fptr_hExp_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog",fptr_hLog1_STL_HComplex_vec_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HComplex_vec_1_STDIT );
def("hLog",fptr_hLog1_STL_HNumber_vec_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HNumber_vec_1_STDIT );
def("hLog",fptr_hLog1_STL_HInteger_vec_1_STDIT );
def("hLog",fptr_hLog1_hARRAY_HInteger_vec_1_STDIT );




def("hLog_sliced",fptr_hLog_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hLog_sliced",fptr_hLog_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hLog_sliced",fptr_hLog_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog",fptr_hLog2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hLog",fptr_hLog2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hLog",fptr_hLog2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hLog",fptr_hLog2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hLog_sliced",fptr_hLog_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hLog_sliced",fptr_hLog_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hLog_sliced",fptr_hLog_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog10",fptr_hLog101_STL_HComplex_vec_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HComplex_vec_1_STDIT );
def("hLog10",fptr_hLog101_STL_HNumber_vec_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HNumber_vec_1_STDIT );
def("hLog10",fptr_hLog101_STL_HInteger_vec_1_STDIT );
def("hLog10",fptr_hLog101_hARRAY_HInteger_vec_1_STDIT );




def("hLog10_sliced",fptr_hLog10_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hLog10_sliced",fptr_hLog10_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hLog10_sliced",fptr_hLog10_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hLog10",fptr_hLog102_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hLog10",fptr_hLog102_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hLog10",fptr_hLog102_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hLog10",fptr_hLog102_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hLog10_sliced",fptr_hLog10_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hLog10_sliced",fptr_hLog10_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hLog10_sliced",fptr_hLog10_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSin",fptr_hSin1_STL_HComplex_vec_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HComplex_vec_1_STDIT );
def("hSin",fptr_hSin1_STL_HNumber_vec_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HNumber_vec_1_STDIT );
def("hSin",fptr_hSin1_STL_HInteger_vec_1_STDIT );
def("hSin",fptr_hSin1_hARRAY_HInteger_vec_1_STDIT );




def("hSin_sliced",fptr_hSin_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hSin_sliced",fptr_hSin_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hSin_sliced",fptr_hSin_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSin",fptr_hSin2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hSin",fptr_hSin2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hSin",fptr_hSin2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hSin",fptr_hSin2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hSin_sliced",fptr_hSin_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSin_sliced",fptr_hSin_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSin_sliced",fptr_hSin_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSinh",fptr_hSinh1_STL_HComplex_vec_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HComplex_vec_1_STDIT );
def("hSinh",fptr_hSinh1_STL_HNumber_vec_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HNumber_vec_1_STDIT );
def("hSinh",fptr_hSinh1_STL_HInteger_vec_1_STDIT );
def("hSinh",fptr_hSinh1_hARRAY_HInteger_vec_1_STDIT );




def("hSinh_sliced",fptr_hSinh_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hSinh_sliced",fptr_hSinh_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hSinh_sliced",fptr_hSinh_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSinh",fptr_hSinh2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hSinh",fptr_hSinh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hSinh_sliced",fptr_hSinh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSinh_sliced",fptr_hSinh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSinh_sliced",fptr_hSinh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSqrt",fptr_hSqrt1_STL_HComplex_vec_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HComplex_vec_1_STDIT );
def("hSqrt",fptr_hSqrt1_STL_HNumber_vec_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HNumber_vec_1_STDIT );
def("hSqrt",fptr_hSqrt1_STL_HInteger_vec_1_STDIT );
def("hSqrt",fptr_hSqrt1_hARRAY_HInteger_vec_1_STDIT );




def("hSqrt_sliced",fptr_hSqrt_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hSqrt_sliced",fptr_hSqrt_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hSqrt_sliced",fptr_hSqrt_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSqrt",fptr_hSqrt2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hSqrt",fptr_hSqrt2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hSqrt_sliced",fptr_hSqrt_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSqrt_sliced",fptr_hSqrt_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSqrt_sliced",fptr_hSqrt_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSquare",fptr_hSquare1_STL_HComplex_vec_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HComplex_vec_1_STDIT );
def("hSquare",fptr_hSquare1_STL_HNumber_vec_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HNumber_vec_1_STDIT );
def("hSquare",fptr_hSquare1_STL_HInteger_vec_1_STDIT );
def("hSquare",fptr_hSquare1_hARRAY_HInteger_vec_1_STDIT );




def("hSquare_sliced",fptr_hSquare_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hSquare_sliced",fptr_hSquare_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hSquare_sliced",fptr_hSquare_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSquare",fptr_hSquare2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hSquare",fptr_hSquare2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hSquare_sliced",fptr_hSquare_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hSquare_sliced",fptr_hSquare_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hSquare_sliced",fptr_hSquare_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTan",fptr_hTan1_STL_HComplex_vec_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HComplex_vec_1_STDIT );
def("hTan",fptr_hTan1_STL_HNumber_vec_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HNumber_vec_1_STDIT );
def("hTan",fptr_hTan1_STL_HInteger_vec_1_STDIT );
def("hTan",fptr_hTan1_hARRAY_HInteger_vec_1_STDIT );




def("hTan_sliced",fptr_hTan_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hTan_sliced",fptr_hTan_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hTan_sliced",fptr_hTan_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTan",fptr_hTan2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hTan",fptr_hTan2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hTan",fptr_hTan2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hTan",fptr_hTan2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hTan_sliced",fptr_hTan_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hTan_sliced",fptr_hTan_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hTan_sliced",fptr_hTan_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTanh",fptr_hTanh1_STL_HComplex_vec_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HComplex_vec_1_STDIT );
def("hTanh",fptr_hTanh1_STL_HNumber_vec_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HNumber_vec_1_STDIT );
def("hTanh",fptr_hTanh1_STL_HInteger_vec_1_STDIT );
def("hTanh",fptr_hTanh1_hARRAY_HInteger_vec_1_STDIT );




def("hTanh_sliced",fptr_hTanh_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hTanh_sliced",fptr_hTanh_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hTanh_sliced",fptr_hTanh_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hTanh",fptr_hTanh2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hTanh",fptr_hTanh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hTanh_sliced",fptr_hTanh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hTanh_sliced",fptr_hTanh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hTanh_sliced",fptr_hTanh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAbs",fptr_hAbs1_STL_HComplex_vec_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HComplex_vec_1_STDIT );
def("hAbs",fptr_hAbs1_STL_HNumber_vec_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HNumber_vec_1_STDIT );
def("hAbs",fptr_hAbs1_STL_HInteger_vec_1_STDIT );
def("hAbs",fptr_hAbs1_hARRAY_HInteger_vec_1_STDIT );




def("hAbs_sliced",fptr_hAbs_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hAbs_sliced",fptr_hAbs_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hAbs_sliced",fptr_hAbs_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAbs",fptr_hAbs2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hAbs",fptr_hAbs2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hAbs_sliced",fptr_hAbs_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hAbs_sliced",fptr_hAbs_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hAbs_sliced",fptr_hAbs_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCos",fptr_hCos1_STL_HComplex_vec_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HComplex_vec_1_STDIT );
def("hCos",fptr_hCos1_STL_HNumber_vec_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HNumber_vec_1_STDIT );
def("hCos",fptr_hCos1_STL_HInteger_vec_1_STDIT );
def("hCos",fptr_hCos1_hARRAY_HInteger_vec_1_STDIT );




def("hCos_sliced",fptr_hCos_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hCos_sliced",fptr_hCos_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hCos_sliced",fptr_hCos_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCos",fptr_hCos2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hCos",fptr_hCos2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hCos",fptr_hCos2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hCos",fptr_hCos2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hCos_sliced",fptr_hCos_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hCos_sliced",fptr_hCos_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hCos_sliced",fptr_hCos_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCosh",fptr_hCosh1_STL_HComplex_vec_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HComplex_vec_1_STDIT );
def("hCosh",fptr_hCosh1_STL_HNumber_vec_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HNumber_vec_1_STDIT );
def("hCosh",fptr_hCosh1_STL_HInteger_vec_1_STDIT );
def("hCosh",fptr_hCosh1_hARRAY_HInteger_vec_1_STDIT );




def("hCosh_sliced",fptr_hCosh_hSLICED1_STL_HComplex_vec_1_STDIT );
def("hCosh_sliced",fptr_hCosh_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hCosh_sliced",fptr_hCosh_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCosh",fptr_hCosh2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HComplex_vecvecout_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HNumber_vecvecout_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_STL_HInteger_vecvecout_11_STDITSTDIT );
def("hCosh",fptr_hCosh2_hARRAY_HInteger_vecvecout_11_STDITSTDIT );




def("hCosh_sliced",fptr_hCosh_hSLICED2_STL_HComplex_vecvecout_11_STDITSTDIT );
def("hCosh_sliced",fptr_hCosh_hSLICED2_STL_HNumber_vecvecout_11_STDITSTDIT );
def("hCosh_sliced",fptr_hCosh_hSLICED2_STL_HInteger_vecvecout_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCeil",fptr_hCeil1_STL_HNumber_vec_1_STDIT );
def("hCeil",fptr_hCeil1_hARRAY_HNumber_vec_1_STDIT );
def("hCeil",fptr_hCeil1_STL_HInteger_vec_1_STDIT );
def("hCeil",fptr_hCeil1_hARRAY_HInteger_vec_1_STDIT );




def("hCeil_sliced",fptr_hCeil_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hCeil_sliced",fptr_hCeil_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCeil",fptr_hCeil2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );
def("hCeil",fptr_hCeil2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT );




def("hCeil_sliced",fptr_hCeil_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hCeil_sliced",fptr_hCeil_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hCeil_sliced",fptr_hCeil_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hCeil_sliced",fptr_hCeil_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFloor",fptr_hFloor1_STL_HNumber_vec_1_STDIT );
def("hFloor",fptr_hFloor1_hARRAY_HNumber_vec_1_STDIT );
def("hFloor",fptr_hFloor1_STL_HInteger_vec_1_STDIT );
def("hFloor",fptr_hFloor1_hARRAY_HInteger_vec_1_STDIT );




def("hFloor_sliced",fptr_hFloor_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hFloor_sliced",fptr_hFloor_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hFloor",fptr_hFloor2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );
def("hFloor",fptr_hFloor2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT );




def("hFloor_sliced",fptr_hFloor_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hFloor_sliced",fptr_hFloor_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hFloor_sliced",fptr_hFloor_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hFloor_sliced",fptr_hFloor_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAcos",fptr_hAcos1_STL_HNumber_vec_1_STDIT );
def("hAcos",fptr_hAcos1_hARRAY_HNumber_vec_1_STDIT );
def("hAcos",fptr_hAcos1_STL_HInteger_vec_1_STDIT );
def("hAcos",fptr_hAcos1_hARRAY_HInteger_vec_1_STDIT );




def("hAcos_sliced",fptr_hAcos_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hAcos_sliced",fptr_hAcos_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAcos",fptr_hAcos2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );
def("hAcos",fptr_hAcos2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT );




def("hAcos_sliced",fptr_hAcos_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAcos_sliced",fptr_hAcos_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAcos_sliced",fptr_hAcos_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAcos_sliced",fptr_hAcos_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAsin",fptr_hAsin1_STL_HNumber_vec_1_STDIT );
def("hAsin",fptr_hAsin1_hARRAY_HNumber_vec_1_STDIT );
def("hAsin",fptr_hAsin1_STL_HInteger_vec_1_STDIT );
def("hAsin",fptr_hAsin1_hARRAY_HInteger_vec_1_STDIT );




def("hAsin_sliced",fptr_hAsin_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hAsin_sliced",fptr_hAsin_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAsin",fptr_hAsin2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );
def("hAsin",fptr_hAsin2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT );




def("hAsin_sliced",fptr_hAsin_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAsin_sliced",fptr_hAsin_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAsin_sliced",fptr_hAsin_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAsin_sliced",fptr_hAsin_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAtan",fptr_hAtan1_STL_HNumber_vec_1_STDIT );
def("hAtan",fptr_hAtan1_hARRAY_HNumber_vec_1_STDIT );
def("hAtan",fptr_hAtan1_STL_HInteger_vec_1_STDIT );
def("hAtan",fptr_hAtan1_hARRAY_HInteger_vec_1_STDIT );




def("hAtan_sliced",fptr_hAtan_hSLICED1_STL_HNumber_vec_1_STDIT );
def("hAtan_sliced",fptr_hAtan_hSLICED1_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAtan",fptr_hAtan2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );
def("hAtan",fptr_hAtan2_hARRAY_HIntegerHInteger_vecvecout_12_STDITSTDIT );




def("hAtan_sliced",fptr_hAtan_hSLICED2_STL_HNumberHNumber_vecvecout_12_STDITSTDIT );
def("hAtan_sliced",fptr_hAtan_hSLICED2_STL_HNumberHInteger_vecvecout_12_STDITSTDIT );
def("hAtan_sliced",fptr_hAtan_hSLICED2_STL_HIntegerHNumber_vecvecout_12_STDITSTDIT );
def("hAtan_sliced",fptr_hAtan_hSLICED2_STL_HIntegerHInteger_vecvecout_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSub",fptr_hSub_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT );




def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hSub",fptr_hSub2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT );
def("hSub",fptr_hSub2_STL_HIntegerHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHInteger_vec1val_12_STDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT );




def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSub",fptr_hSub_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSubAdd",fptr_hSubAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd",fptr_hSubAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );




def("hSubAdd_sliced",fptr_hSubAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd_sliced",fptr_hSubAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hSubAdd_sliced",fptr_hSubAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv",fptr_hSubAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hSubAddConv_sliced",fptr_hSubAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hSub",fptr_hSub2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub",fptr_hSub2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );




def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hSub_sliced",fptr_hSub_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMul",fptr_hMul_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT );




def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hMul",fptr_hMul2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT );
def("hMul",fptr_hMul2_STL_HIntegerHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHInteger_vec1val_12_STDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT );




def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMul",fptr_hMul_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMulAdd",fptr_hMulAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd",fptr_hMulAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );




def("hMulAdd_sliced",fptr_hMulAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd_sliced",fptr_hMulAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hMulAdd_sliced",fptr_hMulAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv",fptr_hMulAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hMulAddConv_sliced",fptr_hMulAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hMul",fptr_hMul2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul",fptr_hMul2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );




def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hMul_sliced",fptr_hMul_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAdd",fptr_hAdd_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT );




def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hAdd",fptr_hAdd2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHInteger_vec1val_12_STDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT );




def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAdd",fptr_hAdd_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAddAdd",fptr_hAddAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd",fptr_hAddAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );




def("hAddAdd_sliced",fptr_hAddAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd_sliced",fptr_hAddAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hAddAdd_sliced",fptr_hAddAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv",fptr_hAddAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hAddAddConv_sliced",fptr_hAddAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hAdd",fptr_hAdd2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd",fptr_hAdd2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );




def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hAdd_sliced",fptr_hAdd_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDiv",fptr_hDiv_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHInteger_vec1vec2_12_STDITSTDIT );




def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHInteger_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHComplex_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHNumber_vec1vec2_12_STDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHInteger_vec1vec2_12_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hDiv",fptr_hDiv2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHComplex_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHNumber_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHInteger_vec1val_12_STDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHInteger_vec1val_12_STDIT );




def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHComplex_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHNumber_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHInteger_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHComplex_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHNumber_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHInteger_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHComplex_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHNumber_vec1val_12_STDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHInteger_vec1val_12_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDiv",fptr_hDiv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDivAdd",fptr_hDivAdd_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd",fptr_hDivAdd_hARRAY_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );




def("hDivAdd_sliced",fptr_hDivAdd_hSLICED_STL_HComplex_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd_sliced",fptr_hDivAdd_hSLICED_STL_HNumber_vec1vec2vec3_111_STDITSTDITSTDIT );
def("hDivAdd_sliced",fptr_hDivAdd_hSLICED_STL_HInteger_vec1vec2vec3_111_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv",fptr_hDivAddConv_hARRAY_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );




def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HComplexHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HNumberHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHComplexHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHNumberHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHComplex_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHNumber_vec1vec2vec3_123_STDITSTDITSTDIT );
def("hDivAddConv_sliced",fptr_hDivAddConv_hSLICED_STL_HIntegerHIntegerHInteger_vec1vec2vec3_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hDiv",fptr_hDiv2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAY_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv",fptr_hDiv2_hARRAYALL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );




def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HComplexHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HNumberHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHComplexHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHNumberHInteger_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHComplex_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHNumber_vec1valvec2_123_STDITSTDITSTDIT );
def("hDiv_sliced",fptr_hDiv_hSLICED2_STL_HIntegerHIntegerHInteger_vec1valvec2_123_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hConj",fptr_hConj_STL_HInteger_vec_HComplex_STDIT );
def("hConj",fptr_hConj_hARRAY_HInteger_vec_HComplex_STDIT );




def("hConj_sliced",fptr_hConj_hSLICED_STL_HInteger_vec_HComplex_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hCrossCorrelateComplex",fptr_hCrossCorrelateComplex_STL_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT );
def("hCrossCorrelateComplex",fptr_hCrossCorrelateComplex_hARRAY_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT );




def("hCrossCorrelateComplex_sliced",fptr_hCrossCorrelateComplex_hSLICED_STL_HInteger_vec1vec2_HComplexHComplex_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hReal",fptr_hReal_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );
def("hReal",fptr_hReal_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );




def("hReal_sliced",fptr_hReal_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hArg",fptr_hArg_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );
def("hArg",fptr_hArg_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );




def("hArg_sliced",fptr_hArg_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hImag",fptr_hImag_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );
def("hImag",fptr_hImag_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );




def("hImag_sliced",fptr_hImag_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNorm",fptr_hNorm_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );
def("hNorm",fptr_hNorm_hARRAY_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );




def("hNorm_sliced",fptr_hNorm_hSLICED_STL_HInteger_vecvecout_HComplexHNumber_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNegate",fptr_hNegate_STL_HComplex_vec_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HComplex_vec_1_STDIT );
def("hNegate",fptr_hNegate_STL_HNumber_vec_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HNumber_vec_1_STDIT );
def("hNegate",fptr_hNegate_STL_HInteger_vec_1_STDIT );
def("hNegate",fptr_hNegate_hARRAY_HInteger_vec_1_STDIT );




def("hNegate_sliced",fptr_hNegate_hSLICED_STL_HComplex_vec_1_STDIT );
def("hNegate_sliced",fptr_hNegate_hSLICED_STL_HNumber_vec_1_STDIT );
def("hNegate_sliced",fptr_hNegate_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSum",fptr_hSum_STL_HComplex_vec_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HComplex_vec_1_STDIT );
def("hSum",fptr_hSum_STL_HNumber_vec_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HNumber_vec_1_STDIT );
def("hSum",fptr_hSum_STL_HInteger_vec_1_STDIT );
def("hSum",fptr_hSum_hARRAY_HInteger_vec_1_STDIT );




def("hSum_sliced",fptr_hSum_hSLICED_STL_HComplex_vec_1_STDIT );
def("hSum_sliced",fptr_hSum_hSLICED_STL_HNumber_vec_1_STDIT );
def("hSum_sliced",fptr_hSum_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMulSum",fptr_hMulSum_STL_HComplex_vec1vec2_11_STDITSTDIT );
def("hMulSum",fptr_hMulSum_hARRAY_HComplex_vec1vec2_11_STDITSTDIT );
def("hMulSum",fptr_hMulSum_STL_HNumber_vec1vec2_11_STDITSTDIT );
def("hMulSum",fptr_hMulSum_hARRAY_HNumber_vec1vec2_11_STDITSTDIT );
def("hMulSum",fptr_hMulSum_STL_HInteger_vec1vec2_11_STDITSTDIT );
def("hMulSum",fptr_hMulSum_hARRAY_HInteger_vec1vec2_11_STDITSTDIT );




def("hMulSum_sliced",fptr_hMulSum_hSLICED_STL_HComplex_vec1vec2_11_STDITSTDIT );
def("hMulSum_sliced",fptr_hMulSum_hSLICED_STL_HNumber_vec1vec2_11_STDITSTDIT );
def("hMulSum_sliced",fptr_hMulSum_hSLICED_STL_HInteger_vec1vec2_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hProduct",fptr_hProduct_STL_HComplex_vec_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HComplex_vec_1_STDIT );
def("hProduct",fptr_hProduct_STL_HNumber_vec_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HNumber_vec_1_STDIT );
def("hProduct",fptr_hProduct_STL_HInteger_vec_1_STDIT );
def("hProduct",fptr_hProduct_hARRAY_HInteger_vec_1_STDIT );




def("hProduct_sliced",fptr_hProduct_hSLICED_STL_HComplex_vec_1_STDIT );
def("hProduct_sliced",fptr_hProduct_hSLICED_STL_HNumber_vec_1_STDIT );
def("hProduct_sliced",fptr_hProduct_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNorm",fptr_hNorm_STL_HNumber_vec_1_STDIT );
def("hNorm",fptr_hNorm_hARRAY_HNumber_vec_1_STDIT );
def("hNorm",fptr_hNorm_STL_HInteger_vec_1_STDIT );
def("hNorm",fptr_hNorm_hARRAY_HInteger_vec_1_STDIT );




def("hNorm_sliced",fptr_hNorm_hSLICED_STL_HNumber_vec_1_STDIT );
def("hNorm_sliced",fptr_hNorm_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hNormalize",fptr_hNormalize_STL_HNumber_vec_1_STDIT );
def("hNormalize",fptr_hNormalize_hARRAY_HNumber_vec_1_STDIT );
def("hNormalize",fptr_hNormalize_STL_HInteger_vec_1_STDIT );
def("hNormalize",fptr_hNormalize_hARRAY_HInteger_vec_1_STDIT );




def("hNormalize_sliced",fptr_hNormalize_hSLICED_STL_HNumber_vec_1_STDIT );
def("hNormalize_sliced",fptr_hNormalize_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hRandom",fptr_hRandom_STL_HComplex_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAY_HComplex_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAYALL_HComplex_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_STL_HNumber_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAY_HNumber_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAYALL_HNumber_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_STL_HInteger_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAY_HInteger_vecminimummaximum_111_STDIT );
def("hRandom",fptr_hRandom_hARRAYALL_HInteger_vecminimummaximum_111_STDIT );




def("hRandom_sliced",fptr_hRandom_hSLICED_STL_HComplex_vecminimummaximum_111_STDIT );
def("hRandom_sliced",fptr_hRandom_hSLICED_STL_HNumber_vecminimummaximum_111_STDIT );
def("hRandom_sliced",fptr_hRandom_hSLICED_STL_HInteger_vecminimummaximum_111_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hMean",fptr_hMean_STL_HNumber_vec_1_STDIT );
def("hMean",fptr_hMean_hARRAY_HNumber_vec_1_STDIT );
def("hMean",fptr_hMean_STL_HInteger_vec_1_STDIT );
def("hMean",fptr_hMean_hARRAY_HInteger_vec_1_STDIT );




def("hMean_sliced",fptr_hMean_hSLICED_STL_HNumber_vec_1_STDIT );
def("hMean_sliced",fptr_hMean_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSort",fptr_hSort_STL_HComplex_vec_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HComplex_vec_1_STDIT );
def("hSort",fptr_hSort_STL_HNumber_vec_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HNumber_vec_1_STDIT );
def("hSort",fptr_hSort_STL_HInteger_vec_1_STDIT );
def("hSort",fptr_hSort_hARRAY_HInteger_vec_1_STDIT );




def("hSort_sliced",fptr_hSort_hSLICED_STL_HComplex_vec_1_STDIT );
def("hSort_sliced",fptr_hSort_hSLICED_STL_HNumber_vec_1_STDIT );
def("hSort_sliced",fptr_hSort_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSortMedian",fptr_hSortMedian_STL_HNumber_vec_1_STDIT );
def("hSortMedian",fptr_hSortMedian_hARRAY_HNumber_vec_1_STDIT );
def("hSortMedian",fptr_hSortMedian_STL_HInteger_vec_1_STDIT );
def("hSortMedian",fptr_hSortMedian_hARRAY_HInteger_vec_1_STDIT );




def("hSortMedian_sliced",fptr_hSortMedian_hSLICED_STL_HNumber_vec_1_STDIT );
def("hSortMedian_sliced",fptr_hSortMedian_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hMedian",fptr_hMedian_STL_HNumber_vec_1_STL );
def("hMedian",fptr_hMedian_STL_HInteger_vec_1_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hStdDev",fptr_hStdDev_STL_HNumber_vecmean_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HNumber_vecmean_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAYALL_HNumber_vecmean_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_STL_HInteger_vecmean_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HInteger_vecmean_1HNumber_STDIT );
def("hStdDev",fptr_hStdDev_hARRAYALL_HInteger_vecmean_1HNumber_STDIT );




def("hStdDev_sliced",fptr_hStdDev_hSLICED_STL_HNumber_vecmean_1HNumber_STDIT );
def("hStdDev_sliced",fptr_hStdDev_hSLICED_STL_HInteger_vecmean_1HNumber_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hStdDev",fptr_hStdDev_STL_HNumber_vec_1_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HNumber_vec_1_STDIT );
def("hStdDev",fptr_hStdDev_STL_HInteger_vec_1_STDIT );
def("hStdDev",fptr_hStdDev_hARRAY_HInteger_vec_1_STDIT );




def("hStdDev_sliced",fptr_hStdDev_hSLICED_STL_HNumber_vec_1_STDIT );
def("hStdDev_sliced",fptr_hStdDev_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindLessEqual",fptr_hFindLessEqual_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual",fptr_hFindLessEqual_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindLessEqual_sliced",fptr_hFindLessEqual_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqual_sliced",fptr_hFindLessEqual_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs",fptr_hFindLessEqualAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindLessEqualAbs_sliced",fptr_hFindLessEqualAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessEqualAbs_sliced",fptr_hFindLessEqualAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindGreaterThan",fptr_hFindGreaterThan_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan",fptr_hFindGreaterThan_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindGreaterThan_sliced",fptr_hFindGreaterThan_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThan_sliced",fptr_hFindGreaterThan_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs",fptr_hFindGreaterThanAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindGreaterThanAbs_sliced",fptr_hFindGreaterThanAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterThanAbs_sliced",fptr_hFindGreaterThanAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindGreaterEqual",fptr_hFindGreaterEqual_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual",fptr_hFindGreaterEqual_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindGreaterEqual_sliced",fptr_hFindGreaterEqual_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqual_sliced",fptr_hFindGreaterEqual_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs",fptr_hFindGreaterEqualAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindGreaterEqualAbs_sliced",fptr_hFindGreaterEqualAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindGreaterEqualAbs_sliced",fptr_hFindGreaterEqualAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindLessThan",fptr_hFindLessThan_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan",fptr_hFindLessThan_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindLessThan_sliced",fptr_hFindLessThan_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThan_sliced",fptr_hFindLessThan_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindLessThanAbs",fptr_hFindLessThanAbs_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAY_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAYALL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAY_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs",fptr_hFindLessThanAbs_hARRAYALL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );




def("hFindLessThanAbs_sliced",fptr_hFindLessThanAbs_hSLICED_STL_HNumber_vecthresholdvecout_11HInteger_STDITSTDIT );
def("hFindLessThanAbs_sliced",fptr_hFindLessThanAbs_hSLICED_STL_HInteger_vecthresholdvecout_11HInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hDownsample",fptr_hDownsample_STL_HNumber_vec1vec2_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_hARRAY_HNumber_vec1vec2_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_STL_HInteger_vec1vec2_11_STDITSTDIT );
def("hDownsample",fptr_hDownsample_hARRAY_HInteger_vec1vec2_11_STDITSTDIT );




def("hDownsample_sliced",fptr_hDownsample_hSLICED_STL_HNumber_vec1vec2_11_STDITSTDIT );
def("hDownsample_sliced",fptr_hDownsample_hSLICED_STL_HInteger_vec1vec2_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hDownsample",fptr_hDownsample_STL_HNumber_vecdownsample_factor_1HNumber_STL );
def("hDownsample",fptr_hDownsample_STL_HInteger_vecdownsample_factor_1HNumber_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFindLowerBound",fptr_hFindLowerBound_STL_HComplex_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HComplex_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAYALL_HComplex_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_STL_HNumber_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HNumber_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAYALL_HNumber_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_STL_HInteger_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAY_HInteger_vecvalue_11_STDIT );
def("hFindLowerBound",fptr_hFindLowerBound_hARRAYALL_HInteger_vecvalue_11_STDIT );




def("hFindLowerBound_sliced",fptr_hFindLowerBound_hSLICED_STL_HComplex_vecvalue_11_STDIT );
def("hFindLowerBound_sliced",fptr_hFindLowerBound_hSLICED_STL_HNumber_vecvalue_11_STDIT );
def("hFindLowerBound_sliced",fptr_hFindLowerBound_hSLICED_STL_HInteger_vecvalue_11_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFlatWeights",fptr_hFlatWeights_STL_HInteger_wlen_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hLinearWeights",fptr_hLinearWeights_STL_HInteger_wlen_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hGaussianWeights",fptr_hGaussianWeights_STL_HInteger_wlen_HInteger_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hWeights",fptr_hWeights_STL_HInteger_wlenwtype_HIntegerhWEIGHTS_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hRunningAverage",fptr_hRunningAverage_STL_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT );
def("hRunningAverage",fptr_hRunningAverage_hARRAY_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT );




def("hRunningAverage_sliced",fptr_hRunningAverage_hSLICED_STL_HInteger_idataodataweights_HNumberHNumberHNumber_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hRunningAverage",fptr_hRunningAverage_STL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );
def("hRunningAverage",fptr_hRunningAverage_hARRAY_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );
def("hRunningAverage",fptr_hRunningAverage_hARRAYALL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );




def("hRunningAverage_sliced",fptr_hRunningAverage_hSLICED_STL_HInteger_idataodatawlenwtype_HNumberHNumberHIntegerhWEIGHTS_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGeometricDelayFarField",fptr_hGeometricDelayFarField_STL_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayFarField",fptr_hGeometricDelayFarField_hARRAY_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayFarField",fptr_hGeometricDelayFarField_hARRAYALL_HInteger_antPositionskyDirectionlength_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGeometricDelayNearField",fptr_hGeometricDelayNearField_STL_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayNearField",fptr_hGeometricDelayNearField_hARRAY_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );
def("hGeometricDelayNearField",fptr_hGeometricDelayNearField_hARRAYALL_HInteger_antPositionskyPositiondistance_HNumberHNumberHNumber_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGeometricDelays",fptr_hGeometricDelays_STL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT );
def("hGeometricDelays",fptr_hGeometricDelays_hARRAY_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT );
def("hGeometricDelays",fptr_hGeometricDelays_hARRAYALL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT );




def("hGeometricDelays_sliced",fptr_hGeometricDelays_hSLICED_STL_HInteger_antPositionsskyPositionsdelaysfarfield_HNumberHNumberHNumberbool_STDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGeometricPhases",fptr_hGeometricPhases_STL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );
def("hGeometricPhases",fptr_hGeometricPhases_hARRAY_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );
def("hGeometricPhases",fptr_hGeometricPhases_hARRAYALL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );




def("hGeometricPhases_sliced",fptr_hGeometricPhases_hSLICED_STL_HInteger_frequenciesantPositionsskyPositionsphasesfarfield_HNumberHNumberHNumberHNumberbool_STDITSTDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGeometricWeights",fptr_hGeometricWeights_STL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );
def("hGeometricWeights",fptr_hGeometricWeights_hARRAY_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );
def("hGeometricWeights",fptr_hGeometricWeights_hARRAYALL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );




def("hGeometricWeights_sliced",fptr_hGeometricWeights_hSLICED_STL_HInteger_frequenciesantPositionsskyPositionsweightsfarfield_HNumberHNumberHNumberHComplexbool_STDITSTDITSTDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hSpectralPower",fptr_hSpectralPower_STL_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT );
def("hSpectralPower",fptr_hSpectralPower_hARRAY_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT );




def("hSpectralPower_sliced",fptr_hSpectralPower_hSLICED_STL_HInteger_vecoutvec_HComplexHNumber_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hADC2Voltage",fptr_hADC2Voltage_STL_HComplex_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HComplex_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAYALL_HComplex_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_STL_HNumber_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HNumber_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAYALL_HNumber_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_STL_HInteger_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAY_HInteger_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage",fptr_hADC2Voltage_hARRAYALL_HInteger_vecadc2voltage_1HNumber_STDIT );




def("hADC2Voltage_sliced",fptr_hADC2Voltage_hSLICED_STL_HComplex_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage_sliced",fptr_hADC2Voltage_hSLICED_STL_HNumber_vecadc2voltage_1HNumber_STDIT );
def("hADC2Voltage_sliced",fptr_hADC2Voltage_hSLICED_STL_HInteger_vecadc2voltage_1HNumber_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );




def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlphaBetaBetaRiseBetaFall_1HNumberuintuintuint_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlphaBeta_1HNumberuint_STDIT );




def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlphaBeta_1HNumberuint_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlphaBeta_1HNumberuint_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HComplex_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HNumber_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAYALL_HInteger_vecAlpha_1HNumber_STDIT );




def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HComplex_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HNumber_vecAlpha_1HNumber_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HInteger_vecAlpha_1HNumber_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HComplex_vec_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HComplex_vec_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HNumber_vec_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HNumber_vec_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_STL_HInteger_vec_1_STDIT );
def("hGetHanningFilter",fptr_hGetHanningFilter_hARRAY_HInteger_vec_1_STDIT );




def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HComplex_vec_1_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HNumber_vec_1_STDIT );
def("hGetHanningFilter_sliced",fptr_hGetHanningFilter_hSLICED_STL_HInteger_vec_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hApplyFilter",fptr_hApplyFilter_STL_HComplex_datafilter_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HComplex_datafilter_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_STL_HNumber_datafilter_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HNumber_datafilter_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_STL_HInteger_datafilter_11_STDITSTDIT );
def("hApplyFilter",fptr_hApplyFilter_hARRAY_HInteger_datafilter_11_STDITSTDIT );




def("hApplyFilter_sliced",fptr_hApplyFilter_hSLICED_STL_HComplex_datafilter_11_STDITSTDIT );
def("hApplyFilter_sliced",fptr_hApplyFilter_hSLICED_STL_HNumber_datafilter_11_STDITSTDIT );
def("hApplyFilter_sliced",fptr_hApplyFilter_hSLICED_STL_HInteger_datafilter_11_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS NO SCALARS
$$$$ (STL) (CASA) (hARRAY)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers




def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HComplex_data_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HComplex_data_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HNumber_data_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HNumber_data_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_STL_HInteger_data_1_STDIT );
def("hApplyHanningFilter",fptr_hApplyHanningFilter_hARRAY_HInteger_data_1_STDIT );




def("hApplyHanningFilter_sliced",fptr_hApplyHanningFilter_hSLICED_STL_HComplex_data_1_STDIT );
def("hApplyHanningFilter_sliced",fptr_hApplyHanningFilter_hSLICED_STL_HNumber_data_1_STDIT );
def("hApplyHanningFilter_sliced",fptr_hApplyHanningFilter_hSLICED_STL_HInteger_data_1_STDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hFFT",fptr_hFFT_STL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT );
def("hFFT",fptr_hFFT_hARRAY_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT );
def("hFFT",fptr_hFFT_hARRAYALL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT );




def("hFFT_sliced",fptr_hFFT_hSLICED_STL_HInteger_data_indata_outnyquistZone_HNumberHComplexHInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hInvFFT",fptr_hInvFFT_STL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT );
def("hInvFFT",fptr_hInvFFT_hARRAY_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT );
def("hInvFFT",fptr_hInvFFT_hARRAYALL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT );




def("hInvFFT_sliced",fptr_hInvFFT_hSLICED_STL_HInteger_data_indata_outnyquistZone_HComplexHNumberHInteger_STDITSTDIT );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileSummary",fptr_hFileSummary_STL_HInteger_dr_CRDataReader_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//------------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileOpen",fptr_hFileOpen_STL_HInteger_Filename_HString_ , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileGetParameter",fptr_hFileGetParameter_STL_HInteger_drkeyword_CRDataReaderHString_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileSetParameter",fptr_hFileSetParameter_STL_HInteger_drkeywordpyob_CRDataReaderHStringHPyObjectPtr_ , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hFileRead",fptr_hFileRead_STL_HComplex_drDatatypevec_CRDataReaderHString1_STL , return_internal_reference<>());
def("hFileRead",fptr_hFileRead_STL_HNumber_drDatatypevec_CRDataReaderHString1_STL , return_internal_reference<>());
def("hFileRead",fptr_hFileRead_STL_HInteger_drDatatypevec_CRDataReaderHString1_STL , return_internal_reference<>());

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hCalTable",fptr_hCalTable_STL_HInteger_filenamekeyworddatepyob_HStringHStringHIntegerHPyObjectPtr_ );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers





def("hCoordinateConvert",fptr_hCoordinateConvert_STL_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED );
def("hCoordinateConvert",fptr_hCoordinateConvert_hARRAY_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED );
def("hCoordinateConvert",fptr_hCoordinateConvert_hARRAYALL_HInteger_sourcesourceCoordinatetargettargetCoordinateanglesInDegrees_HNumberCRCoordinateTypeHNumberCRCoordinateTypebool_STDITFIXEDSTDITFIXED );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
//==================================================================================
// ATTENTION: DON'T EDIT THIS FILE!!! IT IS GENERATED AUTOMATICALLY BY hfsplit2h.awk
//==================================================================================
//     File was generated from /Users/falcke/LOFAR/usg/build/cr/implement/Pypeline/hftools.iter.cc on Wed Mar 24 12:16:44 CET 2010
//----------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------
//#define HFPP_PARDEF_8 (HInteger)(Offsets)()("Offsets per antenna")(HFPP_PAR_IS_VECTOR)(STL)(HFPP_PASS_AS_REFERENCE)
/* hfppnew-generatewrappers.def - START ..........................................*/
//
//GENERATING WRAPPERS
//
//First set all the values to default values, if not present
//------------------------------------------------------------------------------
//#ifndef HFPP_FUNC_hARRAY
//#define HFPP_FUNC_hARRAY 1
//#endif
//Defines all the different types of wrappers that will be built (STL, CASA, ...)
//Defines all the different base types (int, double, ...) that will be
//instantiated for template parameters. Important e.g. for pythn
//bindings
//Defines names of the template parameters (e.g., T, S) that are being
//used in templated function defintions (e.g., template <class T>)
//Now set some definitions based on conditionals
//------------------------------------------------------------------------------
//Unless, explicitly set, yields a "return" statement if the function
//type is not void (actually, HFPP_VOID, which is = -1)
/* Python code to generate the following blocks
s="""
#ifdef HFPP_PARDEF_$$$
#undef HFPP_GET_FUNC_PARNUM
#define HFPP_GET_FUNC_PARNUM %%%
//Check if parameter is a vector
#if HFPP_GET_PAR_DIM($$$)>0
#undef HFPP_FUNC_HAS_VECTORS
#define HFPP_FUNC_HAS_VECTORS 1
#else
#undef HFPP_FUNC_HAS_SCALARS
#define HFPP_FUNC_HAS_SCALARS 1
#endif // HAS_VECTORS
#if HFPP_GET_PAR_BASETYPE_VAL($$$) > 0
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_TRUE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  HFPP_GET_PAR_BASETYPE_VAL($$$)
#if HFPP_GET_PAR_TEMPLATE_VALUE_$$$ > HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#undef HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS
#define HFPP_FUNC_NUMBER_OF_TEMPLATE_PARAMETERS HFPP_GET_PAR_TEMPLATE_VALUE_$$$
#endif
#else
#define HFPP_PAR_TYPE_IS_TEMPLATED_$$$ HFPP_FALSE
#define HFPP_GET_PAR_TEMPLATE_VALUE_$$$  0
#endif
#endif
"""
for i in range(15): print s.replace("$$$",str(i)).replace("%%%",str(i+1))
*/
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//Check if parameter is a vector
//------------------------------------------------------------------------
//If function has no vectors don't make multiple Python wrappers for
//different vector classes
//Don't do the wrapper class for hArrays, where the scalars become
//vectors, if there are no scalars ...
$$$$FUNC HAS SCALARS
$$$$ (STL) (CASA) (hARRAY) (hARRAYALL)
////////////////////////////////////////////////////////////////////////////////
//Generate wrappers

def("hReadFileOld",fptr_hReadFileOld_STL_HComplex_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );
def("hReadFileOld",fptr_hReadFileOld_STL_HNumber_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );
def("hReadFileOld",fptr_hReadFileOld_STL_HInteger_veciptrDatatypeAntennaBlocksizeBlockStrideShift_1HIntPointerHStringHIntegerHIntegerHIntegerHIntegerHInteger_STL );

////////////////////////////////////////////////////////////////////////////////
//
//========================================================================
//--Undefine parameters
//========================================================================
//--Undefine user-defined parameters from cc file
/* hfppnew-generatewrappers.def - END ............................................*/
}
